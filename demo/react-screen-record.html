<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reactå½•å±+éŸ³é¢‘è½¬å­—å¹•ç³»ç»Ÿ</title>
    
    <!-- å…¨å±€é”™è¯¯æ‹¦æˆªå™¨ - å¿…é¡»åœ¨æ‰€æœ‰è„šæœ¬åŠ è½½å‰è®¾ç½® -->
    <script>
        (function() {
            // ä¿å­˜åŸå§‹æ–¹æ³•
            const originalWarn = console.warn;
            const originalError = console.error;
            
            // é‡å†™console.warn
            console.warn = function(...args) {
                const message = args[0];
                if (typeof message === 'string' && 
                    (message.includes('findDOMNode') || 
                     message.includes('Warning: findDOMNode'))) {
                    return; // é™é»˜å¿½ç•¥findDOMNodeè­¦å‘Š
                }
                originalWarn.apply(console, args);
            };
            
            // é‡å†™console.error
            console.error = function(...args) {
                const message = args[0];
                if (typeof message === 'string' && 
                    (message.includes('findDOMNode') || 
                     message.includes('Warning: findDOMNode'))) {
                    return; // é™é»˜å¿½ç•¥findDOMNodeé”™è¯¯
                }
                originalError.apply(console, args);
            };
            
            // è®¾ç½®ç”Ÿäº§ç¯å¢ƒ
            window.NODE_ENV = 'production';
        })();
    </script>
    
    <!-- React 18 - ä½¿ç”¨ç”Ÿäº§ç‰ˆæœ¬ -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Day.js -->
    <script src="https://unpkg.com/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/plugin/customParseFormat.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/plugin/weekday.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/plugin/localeData.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/plugin/weekOfYear.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/plugin/weekYear.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/plugin/advancedFormat.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/plugin/quarterOfYear.js"></script>
    <script src="https://unpkg.com/dayjs@1.11.10/locale/zh-cn.js"></script>
    
    <!-- Ant Design CSS - æœ€æ–°ç‰ˆæœ¬ -->
    <link rel="stylesheet" href="https://unpkg.com/antd@5.16.1/dist/reset.css">
    
    <!-- Ant Design JS - æœ€æ–°ç‰ˆæœ¬ -->
    <script src="https://unpkg.com/antd@5.16.1/dist/antd.min.js"></script>
    
    <!-- Ant Design Icons - æœ€æ–°ç‰ˆæœ¬ -->
    <script src="https://unpkg.com/@ant-design/icons@5.3.6/dist/index.umd.js"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            min-height: 100vh;
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .control-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            border: 1px solid #f0f0f0;
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2c3e50;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-container video {
            width: 100%;
            height: auto;
            max-height: 400px;
        }

        .video-placeholder {
            color: #666;
            font-size: 1.1rem;
            text-align: center;
        }

        .recording-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #ff4757;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .transcript-panel, .translation-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            border: 1px solid #f0f0f0;
        }

        .transcript-content, .translation-content {
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 10px;
            padding: 20px;
            min-height: 150px;
            font-size: 1rem;
            line-height: 1.6;
            color: #495057;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin-bottom: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .settings-panel {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            border: 1px solid #f0f0f0;
        }

        .setting-item {
            margin-bottom: 20px;
        }

        .setting-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #2c3e50;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .control-row {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .content {
                padding: 20px;
            }
            
            .button-group {
                flex-direction: column;
            }
        }

        .loading-message {
            text-align: center;
            padding: 50px;
            color: #666;
        }

        .error-message {
            text-align: center;
            padding: 50px;
            color: red;
        }

        .translation-status {
            background: #e6f7ff;
            border: 1px solid #91d5ff;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
            color: #0050b3;
        }
        
        .translation-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
    </style>
</head>
<body>
    <div id="root">
        <div class="loading-message">
            <h2>â³ æ­£åœ¨åŠ è½½ä¾èµ–...</h2>
            <p>è¯·ç¨å€™ï¼Œç³»ç»Ÿæ­£åœ¨åˆå§‹åŒ–</p>
        </div>
    </div>

    <script>
        // ç­‰å¾…æ‰€æœ‰ä¾èµ–åŠ è½½å®Œæˆ
        function waitForDependencies() {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 50; // 5ç§’è¶…æ—¶
                
                const checkDependencies = () => {
                    attempts++;
                    
                    if (typeof React !== 'undefined' && 
                        typeof ReactDOM !== 'undefined' && 
                        typeof antd !== 'undefined' &&
                        typeof dayjs !== 'undefined') {
                        
                        // é…ç½®dayjsæ’ä»¶
                        if (dayjs.extend) {
                            dayjs.extend(dayjs_plugin_customParseFormat);
                            dayjs.extend(dayjs_plugin_weekday);
                            dayjs.extend(dayjs_plugin_localeData);
                            dayjs.extend(dayjs_plugin_weekOfYear);
                            dayjs.extend(dayjs_plugin_weekYear);
                            dayjs.extend(dayjs_plugin_advancedFormat);
                            dayjs.extend(dayjs_plugin_quarterOfYear);
                            dayjs.locale('zh-cn');
                        }
                        
                        // é¢å¤–çš„è­¦å‘ŠæŠ‘åˆ¶ - åŒé‡ä¿é™©
                        const suppressFindDOMNodeWarnings = () => {
                            const originalWarn = console.warn;
                            const originalError = console.error;
                            
                            console.warn = function(...args) {
                                const message = args[0];
                                if (typeof message === 'string' && 
                                    (message.includes('findDOMNode') || 
                                     message.includes('Warning: findDOMNode') ||
                                     message.includes('ReactDOM.findDOMNode'))) {
                                    return;
                                }
                                originalWarn.apply(console, args);
                            };
                            
                            console.error = function(...args) {
                                const message = args[0];
                                if (typeof message === 'string' && 
                                    (message.includes('findDOMNode') || 
                                     message.includes('Warning: findDOMNode') ||
                                     message.includes('ReactDOM.findDOMNode'))) {
                                    return;
                                }
                                originalError.apply(console, args);
                            };
                        };
                        
                        suppressFindDOMNodeWarnings();
                        
                        resolve();
                    } else if (attempts >= maxAttempts) {
                        reject(new Error('ä¾èµ–åŠ è½½è¶…æ—¶'));
                    } else {
                        setTimeout(checkDependencies, 100);
                    }
                };
                
                checkDependencies();
            });
        }

        // åˆå§‹åŒ–åº”ç”¨
        async function initApp() {
            try {
                await waitForDependencies();
                
                const { useState, useEffect, useRef, useCallback } = React;
                const { 
                    Button, 
                    Alert, 
                    Progress, 
                    Card, 
                    Select, 
                    Switch, 
                    message 
                } = antd;
                
                // æ£€æŸ¥å›¾æ ‡æ˜¯å¦å¯ç”¨
                let icons = {};
                if (typeof window.icons !== 'undefined' && window.icons) {
                    icons = window.icons;
                } else {
                    // ä½¿ç”¨æ–‡æœ¬æ›¿ä»£å›¾æ ‡
                    icons = {
                        VideoCameraOutlined: () => React.createElement('span', {}, 'ğŸ“¹'),
                        PauseCircleOutlined: () => React.createElement('span', {}, 'â¸ï¸'),
                        DownloadOutlined: () => React.createElement('span', {}, 'â¬‡ï¸'),
                        DeleteOutlined: () => React.createElement('span', {}, 'ğŸ—‘ï¸'),
                        FileTextOutlined: () => React.createElement('span', {}, 'ğŸ“„'),
                        CopyOutlined: () => React.createElement('span', {}, 'ğŸ“‹'),
                        FolderOutlined: () => React.createElement('span', {}, 'ğŸ“'),
                        ReloadOutlined: () => React.createElement('span', {}, 'ğŸ”„'),
                        SettingOutlined: () => React.createElement('span', {}, 'âš™ï¸')
                    };
                }

                const { 
                    VideoCameraOutlined,
                    PauseCircleOutlined,
                    DownloadOutlined,
                    DeleteOutlined,
                    FileTextOutlined,
                    CopyOutlined,
                    FolderOutlined,
                    ReloadOutlined,
                    SettingOutlined
                } = icons;

                const ScreenRecordApp = () => {
                    // å½•åˆ¶ç›¸å…³çŠ¶æ€
                    const [mediaRecorder, setMediaRecorder] = useState(null);
                    const [recordedChunks, setRecordedChunks] = useState([]);
                    const [stream, setStream] = useState(null);
                    const [recognition, setRecognition] = useState(null);
                    const [isRecording, setIsRecording] = useState(false);
                    const [startTime, setStartTime] = useState(null);
                    const [videoUrl, setVideoUrl] = useState('');
                    const [recordedVideo, setRecordedVideo] = useState(false);
                    
                    // å­—å¹•ç›¸å…³
                    const [transcriptText, setTranscriptText] = useState('');
                    
                    // ç¿»è¯‘ç›¸å…³
                    const [translationText, setTranslationText] = useState('');
                    const [isTranslating, setIsTranslating] = useState(false);
                    const [translationSettings, setTranslationSettings] = useState({
                        targetLanguage: 'en'
                    });
                    const [translationStatus, setTranslationStatus] = useState({
                        show: false,
                        message: '',
                        type: 'info'
                    });
                    
                    // ç¿»è¯‘APIé…ç½®
                    const [translateApis] = useState({
                        localTranslate: {
                            url: 'local',
                            name: 'æœ¬åœ°ç¿»è¯‘ (æ— CORSé—®é¢˜)',
                            cors: true
                        },
                        myMemory: {
                            url: 'https://api.mymemory.translated.net/get',
                            name: 'MyMemory (å…è´¹)',
                            cors: true
                        },
                        googleTranslate: {
                            url: 'https://translate.googleapis.com/translate_a/single',
                            name: 'Google Translate (å…è´¹)',
                            cors: true
                        },
                        libreTranslate: {
                            url: 'https://libretranslate.de/translate',
                            name: 'LibreTranslate (å…è´¹)',
                            cors: false
                        }
                    });
                    
                    // æ£€æµ‹æ˜¯å¦ä¸ºæœ¬åœ°æ–‡ä»¶è¿è¡Œ
                    const [isLocalFile] = useState(window.location.protocol === 'file:');
                    const [currentTranslateApi, setCurrentTranslateApi] = useState(
                        window.location.protocol === 'file:' ? 'localTranslate' : 'myMemory'
                    );
                    
                    // çŠ¶æ€ç›¸å…³
                    const [statusMessage, setStatusMessage] = useState('ç³»ç»Ÿå°±ç»ª');
                    const [statusType, setStatusType] = useState('success');
                    const [recordingInfo, setRecordingInfo] = useState('ç­‰å¾…å¼€å§‹å½•åˆ¶...');
                    const [recordingTime, setRecordingTime] = useState('');
                    const [recordingProgress, setRecordingProgress] = useState(0);
                    const [browserSupported, setBrowserSupported] = useState(true);
                    
                    // è®¾ç½®
                    const [settings, setSettings] = useState({
                        videoQuality: '720p',
                        audioSource: 'system',
                        language: 'zh-CN',
                        continuous: true
                    });

                    const videoRef = useRef(null);
                    const timerRef = useRef(null);

                    // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
                    useEffect(() => {
                        const checkBrowserSupport = () => {
                            const supported = !!(
                                navigator.mediaDevices &&
                                navigator.mediaDevices.getDisplayMedia &&
                                window.MediaRecorder &&
                                (window.webkitSpeechRecognition || window.SpeechRecognition)
                            );
                            
                            setBrowserSupported(supported);
                            
                            if (!supported) {
                                setStatusMessage('æµè§ˆå™¨ä¸æ”¯æŒå½•å±æˆ–è¯­éŸ³è¯†åˆ«åŠŸèƒ½');
                                setStatusType('error');
                                message.error('è¯·ä½¿ç”¨æ”¯æŒçš„æµè§ˆå™¨ï¼ˆChromeã€Edgeç­‰ï¼‰');
                            }
                        };

                        checkBrowserSupport();
                    }, []);

                    // è·å–è§†é¢‘çº¦æŸ
                    const getVideoConstraints = () => {
                        const constraints = {
                            '1080p': { width: 1920, height: 1080, frameRate: 30 },
                            '720p': { width: 1280, height: 720, frameRate: 30 },
                            '480p': { width: 854, height: 480, frameRate: 24 }
                        };
                        
                        return constraints[settings.videoQuality];
                    };

                    // è·å–æ—¶é—´æˆ³
                    const getTimestamp = () => {
                        if (!startTime) return '00:00:00';
                        
                        const elapsed = Date.now() - startTime;
                        const hours = Math.floor(elapsed / 3600000);
                        const minutes = Math.floor((elapsed % 3600000) / 60000);
                        const seconds = Math.floor((elapsed % 60000) / 1000);
                        
                        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    };

                    // åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«
                    const initSpeechRecognition = () => {
                        if (!window.webkitSpeechRecognition && !window.SpeechRecognition) {
                            console.warn('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«');
                            message.error('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½');
                            return false;
                        }

                        try {
                            const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;
                            const newRecognition = new SpeechRecognition();
                            
                            newRecognition.continuous = settings.continuous;
                            newRecognition.interimResults = true;
                            newRecognition.lang = settings.language;
                            newRecognition.maxAlternatives = 1;

                            newRecognition.onstart = () => {
                                console.log('è¯­éŸ³è¯†åˆ«å·²å¯åŠ¨');
                                message.success('è¯­éŸ³è¯†åˆ«å·²å¯åŠ¨');
                            };

                            newRecognition.onresult = (event) => {
                                let finalTranscript = '';
                                let interimTranscript = '';

                                for (let i = event.resultIndex; i < event.results.length; i++) {
                                    const transcript = event.results[i][0].transcript;
                                    if (event.results[i].isFinal) {
                                        finalTranscript += transcript;
                                    } else {
                                        interimTranscript += transcript;
                                    }
                                }

                                if (finalTranscript) {
                                    const timestamp = getTimestamp();
                                    const newLine = `[${timestamp}] ${finalTranscript}\n`;
                                    setTranscriptText(prev => prev + newLine);
                                    console.log('è¯†åˆ«ç»“æœ:', finalTranscript);
                                }

                                // æ˜¾ç¤ºä¸´æ—¶ç»“æœï¼ˆå¯é€‰ï¼‰
                                if (interimTranscript && !finalTranscript) {
                                    console.log('ä¸´æ—¶ç»“æœ:', interimTranscript);
                                }
                            };

                            newRecognition.onerror = (event) => {
                                console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', event.error);
                                switch(event.error) {
                                    case 'not-allowed':
                                        message.error('è¯·å…è®¸éº¦å…‹é£æƒé™ä»¥å¯ç”¨è¯­éŸ³è¯†åˆ«');
                                        break;
                                    case 'no-speech':
                                        console.log('æœªæ£€æµ‹åˆ°è¯­éŸ³ï¼Œç»§ç»­ç›‘å¬...');
                                        break;
                                    case 'audio-capture':
                                        message.error('æ— æ³•æ•è·éŸ³é¢‘ï¼Œè¯·æ£€æŸ¥éº¦å…‹é£');
                                        break;
                                    case 'network':
                                        message.error('ç½‘ç»œé”™è¯¯ï¼Œè¯­éŸ³è¯†åˆ«æœåŠ¡ä¸å¯ç”¨');
                                        break;
                                    default:
                                        message.error(`è¯­éŸ³è¯†åˆ«é”™è¯¯: ${event.error}`);
                                }
                            };

                            newRecognition.onend = () => {
                                console.log('è¯­éŸ³è¯†åˆ«ç»“æŸ');
                                if (isRecording) {
                                    // å¦‚æœè¿˜åœ¨å½•åˆ¶ä¸­ï¼Œé‡æ–°å¯åŠ¨è¯­éŸ³è¯†åˆ«
                                    setTimeout(() => {
                                        try {
                                            if (recognition && isRecording) {
                                                newRecognition.start();
                                                console.log('é‡æ–°å¯åŠ¨è¯­éŸ³è¯†åˆ«');
                                            }
                                        } catch (error) {
                                            console.error('é‡å¯è¯­éŸ³è¯†åˆ«å¤±è´¥:', error);
                                        }
                                    }, 100);
                                }
                            };

                            setRecognition(newRecognition);
                            return true;
                        } catch (error) {
                            console.error('åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«å¤±è´¥:', error);
                            message.error('åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«å¤±è´¥: ' + error.message);
                            return false;
                        }
                    };

                    // æµ‹è¯•è¯­éŸ³è¯†åˆ«ï¼ˆç‹¬ç«‹äºå½•åˆ¶ï¼‰
                    const testSpeechRecognition = () => {
                        if (!window.webkitSpeechRecognition && !window.SpeechRecognition) {
                            message.error('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½');
                            return;
                        }

                        try {
                            const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;
                            const testRecognition = new SpeechRecognition();
                            
                            testRecognition.continuous = false;
                            testRecognition.interimResults = true;
                            testRecognition.lang = settings.language;
                            testRecognition.maxAlternatives = 1;

                            testRecognition.onstart = () => {
                                message.info('è¯­éŸ³è¯†åˆ«æµ‹è¯•å¼€å§‹ï¼Œè¯·è¯´è¯...');
                            };

                            testRecognition.onresult = (event) => {
                                let finalTranscript = '';
                                for (let i = event.resultIndex; i < event.results.length; i++) {
                                    if (event.results[i].isFinal) {
                                        finalTranscript += event.results[i][0].transcript;
                                    }
                                }

                                if (finalTranscript) {
                                    const timestamp = new Date().toLocaleTimeString();
                                    const newLine = `[${timestamp}] ${finalTranscript}\n`;
                                    setTranscriptText(prev => prev + newLine);
                                    message.success('è¯­éŸ³è¯†åˆ«æˆåŠŸï¼');
                                }
                            };

                            testRecognition.onerror = (event) => {
                                message.error(`è¯­éŸ³è¯†åˆ«é”™è¯¯: ${event.error}`);
                            };

                            testRecognition.onend = () => {
                                message.info('è¯­éŸ³è¯†åˆ«æµ‹è¯•ç»“æŸ');
                            };

                            testRecognition.start();
                        } catch (error) {
                            message.error('è¯­éŸ³è¯†åˆ«æµ‹è¯•å¤±è´¥: ' + error.message);
                        }
                    };

                    // å¼€å§‹å½•åˆ¶
                    const startRecording = async () => {
                        try {
                            setRecordedChunks([]);
                            setRecordedVideo(false);
                            setVideoUrl('');
                            setTranscriptText(''); // æ¸…ç©ºä¹‹å‰çš„å­—å¹•

                            const displayStream = await navigator.mediaDevices.getDisplayMedia({
                                video: getVideoConstraints(),
                                audio: settings.audioSource === 'system' || settings.audioSource === 'both'
                            });

                            let audioStream = null;
                            if (settings.audioSource === 'microphone' || settings.audioSource === 'both') {
                                try {
                                    audioStream = await navigator.mediaDevices.getUserMedia({
                                        audio: true,
                                        video: false
                                    });
                                    
                                    const audioTrack = audioStream.getAudioTracks()[0];
                                    displayStream.addTrack(audioTrack);
                                } catch (err) {
                                    console.warn('æ— æ³•è·å–éº¦å…‹é£æƒé™:', err);
                                    message.warning('æ— æ³•è·å–éº¦å…‹é£æƒé™');
                                }
                            }

                            setStream(displayStream);

                            // è®¾ç½®å®æ—¶é¢„è§ˆ
                            if (videoRef.current) {
                                videoRef.current.srcObject = displayStream;
                                videoRef.current.onloadedmetadata = () => {
                                    videoRef.current.play().catch(e => 
                                        console.log('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢:', e)
                                    );
                                };
                            }

                            let mimeType = 'video/webm;codecs=vp9,opus';
                            if (!MediaRecorder.isTypeSupported(mimeType)) {
                                mimeType = 'video/webm;codecs=vp8,opus';
                            }
                            if (!MediaRecorder.isTypeSupported(mimeType)) {
                                mimeType = 'video/webm';
                            }

                            const recorder = new MediaRecorder(displayStream, { mimeType });

                            recorder.ondataavailable = (event) => {
                                if (event.data.size > 0) {
                                    setRecordedChunks(prev => [...prev, event.data]);
                                }
                            };

                            recorder.onstop = () => {
                                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                                const url = URL.createObjectURL(blob);
                                setVideoUrl(url);
                                setRecordedVideo(true);

                                // æ¸…é™¤å®æ—¶é¢„è§ˆ
                                if (videoRef.current) {
                                    videoRef.current.srcObject = null;
                                }

                                setStatusMessage('å½•åˆ¶å®Œæˆï¼Œå¯ä»¥ä¸‹è½½è§†é¢‘');
                                setStatusType('success');
                                message.success('å½•åˆ¶å®Œæˆ');
                            };

                            recorder.start(1000);
                            setMediaRecorder(recorder);
                            setIsRecording(true);
                            setStartTime(Date.now());

                            // å¯åŠ¨è¯­éŸ³è¯†åˆ«
                            if (initSpeechRecognition() && recognition) {
                                try {
                                    recognition.start();
                                    console.log('è¯­éŸ³è¯†åˆ«å·²å¯åŠ¨');
                                } catch (error) {
                                    console.error('å¯åŠ¨è¯­éŸ³è¯†åˆ«å¤±è´¥:', error);
                                    message.warning('è¯­éŸ³è¯†åˆ«å¯åŠ¨å¤±è´¥ï¼Œä½†å½•åˆ¶ç»§ç»­è¿›è¡Œ');
                                }
                            }

                            setStatusMessage('æ­£åœ¨å½•åˆ¶ä¸­...');
                            setStatusType('warning');
                            setRecordingInfo('å½•åˆ¶è¿›è¡Œä¸­ï¼Œè¯­éŸ³è¯†åˆ«å·²å¯åŠ¨...');
                            startTimer();

                            displayStream.getVideoTracks()[0].onended = () => {
                                stopRecording();
                            };

                            message.success('å½•åˆ¶å¼€å§‹ï¼Œè¯­éŸ³è¯†åˆ«å·²å¯åŠ¨');

                        } catch (err) {
                            console.error('å¼€å§‹å½•åˆ¶å¤±è´¥:', err);
                            message.error('å¼€å§‹å½•åˆ¶å¤±è´¥: ' + err.message);
                            setStatusMessage('å½•åˆ¶å¤±è´¥: ' + err.message);
                            setStatusType('error');
                        }
                    };

                    // åœæ­¢å½•åˆ¶
                    const stopRecording = () => {
                        if (!isRecording || !mediaRecorder) {
                            message.warning('å½“å‰æ²¡æœ‰è¿›è¡Œå½•åˆ¶');
                            return;
                        }

                        try {
                            mediaRecorder.stop();
                            
                            if (stream) {
                                stream.getTracks().forEach(track => track.stop());
                                setStream(null);
                            }

                            // åœæ­¢è¯­éŸ³è¯†åˆ«
                            if (recognition) {
                                try {
                                    recognition.stop();
                                    console.log('è¯­éŸ³è¯†åˆ«å·²åœæ­¢');
                                } catch (error) {
                                    console.error('åœæ­¢è¯­éŸ³è¯†åˆ«å¤±è´¥:', error);
                                }
                            }

                            setIsRecording(false);
                            setStartTime(null);
                            
                            if (timerRef.current) {
                                clearInterval(timerRef.current);
                                timerRef.current = null;
                            }

                            setRecordingInfo('å½•åˆ¶å·²åœæ­¢ï¼Œè¯­éŸ³è¯†åˆ«å·²å…³é—­');
                            setRecordingTime('');
                            setRecordingProgress(0);

                            message.success('å½•åˆ¶å·²åœæ­¢ï¼Œè¯­éŸ³è¯†åˆ«å·²å…³é—­');

                        } catch (err) {
                            console.error('åœæ­¢å½•åˆ¶å¤±è´¥:', err);
                            message.error('åœæ­¢å½•åˆ¶å¤±è´¥: ' + err.message);
                        }
                    };

                    // å¼€å§‹è®¡æ—¶å™¨
                    const startTimer = () => {
                        timerRef.current = setInterval(() => {
                            if (!isRecording) {
                                clearInterval(timerRef.current);
                                return;
                            }

                            const elapsed = Date.now() - startTime;
                            const minutes = Math.floor(elapsed / 60000);
                            const seconds = Math.floor((elapsed % 60000) / 1000);

                            setRecordingTime(`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`);

                            const maxTime = 30 * 60 * 1000;
                            setRecordingProgress(Math.min((elapsed / maxTime) * 100, 100));
                        }, 1000);
                    };

                    // ä¸‹è½½è§†é¢‘
                    const downloadVideo = () => {
                        if (!videoUrl) {
                            message.warning('æ²¡æœ‰å¯ä¸‹è½½çš„è§†é¢‘');
                            return;
                        }

                        const a = document.createElement('a');
                        a.href = videoUrl;
                        a.download = `react-screen-recording-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
                        a.click();

                        message.success('è§†é¢‘ä¸‹è½½å¼€å§‹');
                    };

                    // æ ¼å¼åŒ–è¿›åº¦
                    const formatProgress = (percentage) => {
                        return percentage === 100 ? 'å½•åˆ¶å³å°†ç»“æŸ' : `${percentage.toFixed(1)}%`;
                    };

                    // æ¸…ç©ºå­—å¹•
                    const clearTranscript = () => {
                        setTranscriptText('');
                        message.success('å­—å¹•å·²æ¸…ç©º');
                    };

                    // å¯¼å‡ºå­—å¹•
                    const exportTranscript = () => {
                        if (!transcriptText) {
                            message.warning('æ²¡æœ‰å­—å¹•å†…å®¹å¯å¯¼å‡º');
                            return;
                        }

                        const blob = new Blob([transcriptText], { type: 'text/plain;charset=utf-8' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `react-transcript-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
                        a.click();
                        URL.revokeObjectURL(url);

                        message.success('å­—å¹•å¯¼å‡ºæˆåŠŸ');
                    };

                    // å¤åˆ¶å­—å¹•
                    const copyTranscript = async () => {
                        if (!transcriptText) {
                            message.warning('æ²¡æœ‰å­—å¹•å†…å®¹å¯å¤åˆ¶');
                            return;
                        }

                        try {
                            await navigator.clipboard.writeText(transcriptText);
                            message.success('å­—å¹•å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                        } catch (error) {
                            console.error('å¤åˆ¶å¤±è´¥:', error);
                            message.error('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬å¤åˆ¶');
                        }
                    };

                    // ä¿å­˜å­—å¹•
                    const saveTranscript = () => {
                        if (!transcriptText) {
                            message.warning('æ²¡æœ‰å­—å¹•å†…å®¹å¯ä¿å­˜');
                            return;
                        }

                        localStorage.setItem('reactSavedTranscript', transcriptText);
                        localStorage.setItem('reactSavedTranscriptTime', new Date().toISOString());
                        message.success('å­—å¹•å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
                    };

                    // åŠ è½½ä¿å­˜çš„å­—å¹•
                    const loadSavedTranscript = () => {
                        const savedTranscript = localStorage.getItem('reactSavedTranscript');
                        if (savedTranscript) {
                            const savedTime = localStorage.getItem('reactSavedTranscriptTime');
                            if (window.confirm(`å‘ç°ä¿å­˜çš„å­—å¹•å†…å®¹ (${new Date(savedTime).toLocaleString()})ï¼Œæ˜¯å¦æ¢å¤ï¼Ÿ`)) {
                                setTranscriptText(savedTranscript);
                                message.success('å­—å¹•å†…å®¹å·²æ¢å¤');
                            }
                        } else {
                            message.info('æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„å­—å¹•å†…å®¹');
                        }
                    };

                    // ç¿»è¯‘å•è¡Œæ–‡æœ¬
                    const translateText = async (text, sourceLang, targetLang) => {
                        const api = translateApis[currentTranslateApi];
                        
                        try {
                            let response;
                            
                            switch (currentTranslateApi) {
                                case 'localTranslate':
                                    // æœ¬åœ°ç¿»è¯‘é€»è¾‘
                                    console.log('ä½¿ç”¨æœ¬åœ°ç¿»è¯‘API');
                                    // åœ¨æœ¬åœ°æ–‡ä»¶è¿è¡Œæ—¶ï¼Œç›´æ¥è¿”å›åŸå§‹æ–‡æœ¬
                                    if (isLocalFile) {
                                        return text;
                                    }
                                    // åœ¨æœåŠ¡å™¨ä¸Šè¿è¡Œæ—¶ï¼Œæ¨¡æ‹ŸAPIè°ƒç”¨
                                    await new Promise(resolve => setTimeout(resolve, 100)); // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
                                    return `[æœ¬åœ°ç¿»è¯‘] ${text}`; // ç¤ºä¾‹æœ¬åœ°ç¿»è¯‘
                                    
                                case 'myMemory':
                                    // MyMemory API - GETè¯·æ±‚ï¼ŒCORSå‹å¥½
                                    const myMemoryUrl = `${api.url}?q=${encodeURIComponent(text)}&langpair=${sourceLang}|${targetLang}`;
                                    response = await fetch(myMemoryUrl);
                                    if (!response.ok) {
                                        throw new Error(`MyMemory APIè¯·æ±‚å¤±è´¥: ${response.status}`);
                                    }
                                    const myMemoryData = await response.json();
                                    return myMemoryData.responseData.translatedText;
                                    
                                case 'googleTranslate':
                                    // Google Translate API - GETè¯·æ±‚ï¼ŒCORSå‹å¥½
                                    const googleUrl = `${api.url}?client=gtx&sl=${sourceLang}&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`;
                                    response = await fetch(googleUrl);
                                    if (!response.ok) {
                                        throw new Error(`Google Translate APIè¯·æ±‚å¤±è´¥: ${response.status}`);
                                    }
                                    const googleData = await response.json();
                                    return googleData[0][0][0];
                                    
                                case 'libreTranslate':
                                    // LibreTranslate API - POSTè¯·æ±‚ï¼Œå¯èƒ½æœ‰CORSé—®é¢˜
                                    response = await fetch(api.url, {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json',
                                        },
                                        body: JSON.stringify({
                                            q: text,
                                            source: sourceLang,
                                            target: targetLang,
                                            format: 'text'
                                        })
                                    });
                                    if (!response.ok) {
                                        throw new Error(`LibreTranslate APIè¯·æ±‚å¤±è´¥: ${response.status}`);
                                    }
                                    const libreData = await response.json();
                                    return libreData.translatedText;
                                    
                                default:
                                    throw new Error('æœªçŸ¥çš„ç¿»è¯‘API');
                            }
                        } catch (error) {
                            console.error('ç¿»è¯‘è¯·æ±‚å¤±è´¥:', error);
                            // å¦‚æœå½“å‰APIå¤±è´¥ï¼Œå°è¯•åˆ‡æ¢åˆ°å…¶ä»–API
                            if (currentTranslateApi !== 'localTranslate') { // é¿å…æ— é™å¾ªç¯
                                console.log('å°è¯•åˆ‡æ¢åˆ°æœ¬åœ°ç¿»è¯‘API...');
                                setCurrentTranslateApi('localTranslate');
                                return await translateText(text, sourceLang, targetLang);
                            }
                            throw error;
                        }
                    };

                    // ç¿»è¯‘å­—å¹•
                    const translateTranscript = async () => {
                        if (!transcriptText || transcriptText === 'ç­‰å¾…è¯­éŸ³è¾“å…¥...') {
                            message.warning('æ²¡æœ‰å­—å¹•å†…å®¹å¯ç¿»è¯‘');
                            return;
                        }

                        if (isTranslating) {
                            message.warning('æ­£åœ¨ç¿»è¯‘ä¸­ï¼Œè¯·ç¨å€™...');
                            return;
                        }

                        setIsTranslating(true);
                        setTranslationStatus({ 
                            show: true, 
                            message: 'æ­£åœ¨ç¿»è¯‘...', 
                            type: 'info' 
                        });
                        message.info('å¼€å§‹ç¿»è¯‘å­—å¹•...');

                        try {
                            const lines = transcriptText.split('\n').filter(line => line.trim());
                            let translatedLines = [];

                            for (let i = 0; i < lines.length; i++) {
                                const line = lines[i];
                                if (line.trim()) {
                                    const match = line.match(/^(\[.*?\]) (.*)$/);
                                    if (match) {
                                        const timestamp = match[1];
                                        const text = match[2];
                                        
                                        try {
                                            const translatedText = await translateText(text, 'zh', translationSettings.targetLanguage);
                                            translatedLines.push(`${timestamp} ${translatedText}`);
                                            setTranslationStatus({
                                                show: true,
                                                message: `æ­£åœ¨ç¿»è¯‘ç¬¬ ${i + 1}/${lines.length} è¡Œ...`,
                                                type: 'info'
                                            });
                                        } catch (err) {
                                            console.error('ç¿»è¯‘å¤±è´¥:', err);
                                            translatedLines.push(`${timestamp} [ç¿»è¯‘å¤±è´¥] ${text}`);
                                        }
                                    } else {
                                        translatedLines.push(line);
                                    }
                                }
                            }

                            setTranslationText(translatedLines.join('\n'));
                            setTranslationStatus({ 
                                show: true, 
                                message: 'ç¿»è¯‘å®Œæˆï¼', 
                                type: 'success' 
                            });
                            message.success('ç¿»è¯‘å®Œæˆ');
                            
                            setTimeout(() => {
                                setTranslationStatus({ show: false, message: '', type: 'info' });
                            }, 3000);
                        } catch (error) {
                            console.error('ç¿»è¯‘å¤±è´¥:', error);
                            let errorMessage = 'ç¿»è¯‘å¤±è´¥: ' + error.message;
                            
                            // å¦‚æœæ˜¯CORSé”™è¯¯ï¼Œæä¾›è§£å†³æ–¹æ¡ˆ
                            if (error.message.includes('CORS') || error.message.includes('preflight')) {
                                errorMessage = 'ç¿»è¯‘å¤±è´¥: CORSè·¨åŸŸé—®é¢˜ã€‚è¯·å°è¯•åˆ‡æ¢åˆ°å…¶ä»–ç¿»è¯‘APIï¼Œæˆ–ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œæ­¤æ–‡ä»¶ã€‚';
                            }
                            
                            setTranslationStatus({ 
                                show: true, 
                                message: errorMessage, 
                                type: 'error' 
                            });
                            message.error(errorMessage);
                            
                            setTimeout(() => {
                                setTranslationStatus({ show: false, message: '', type: 'info' });
                            }, 8000);
                        } finally {
                            setIsTranslating(false);
                        }
                    };

                    // æ¸…ç©ºç¿»è¯‘
                    const clearTranslation = () => {
                        setTranslationText('');
                        setTranslationStatus({ show: false, message: '', type: 'info' });
                        message.success('ç¿»è¯‘å·²æ¸…ç©º');
                    };

                    // å¯¼å‡ºç¿»è¯‘
                    const exportTranslation = () => {
                        if (!translationText || translationText === 'ç­‰å¾…ç¿»è¯‘...') {
                            message.warning('æ²¡æœ‰ç¿»è¯‘å†…å®¹å¯å¯¼å‡º');
                            return;
                        }

                        const blob = new Blob([translationText], { type: 'text/plain;charset=utf-8' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `react-translation-${translationSettings.targetLanguage}-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
                        a.click();
                        URL.revokeObjectURL(url);

                        message.success('ç¿»è¯‘å¯¼å‡ºæˆåŠŸ');
                    };

                    // å¤åˆ¶ç¿»è¯‘
                    const copyTranslation = async () => {
                        if (!translationText || translationText === 'ç­‰å¾…ç¿»è¯‘...') {
                            message.warning('æ²¡æœ‰ç¿»è¯‘å†…å®¹å¯å¤åˆ¶');
                            return;
                        }

                        try {
                            await navigator.clipboard.writeText(translationText);
                            message.success('ç¿»è¯‘å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                        } catch (error) {
                            console.error('å¤åˆ¶å¤±è´¥:', error);
                            message.error('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©æ–‡æœ¬å¤åˆ¶');
                        }
                    };
                    
                    // ä¿å­˜ç¿»è¯‘
                    const saveTranslation = () => {
                        if (!translationText || translationText === 'ç­‰å¾…ç¿»è¯‘...') {
                            message.warning('æ²¡æœ‰ç¿»è¯‘å†…å®¹å¯ä¿å­˜');
                            return;
                        }
                        
                        localStorage.setItem('reactSavedTranslation', translationText);
                        localStorage.setItem('reactSavedTranslationTime', new Date().toISOString());
                        localStorage.setItem('reactSavedTranslationLang', translationSettings.targetLanguage);
                        message.success('ç¿»è¯‘å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
                    };
                    
                    // åŠ è½½ä¿å­˜çš„ç¿»è¯‘
                    const loadSavedTranslation = () => {
                        const savedTranslation = localStorage.getItem('reactSavedTranslation');
                        if (savedTranslation) {
                            const savedTime = localStorage.getItem('reactSavedTranslationTime');
                            const savedLang = localStorage.getItem('reactSavedTranslationLang');
                            
                            if (window.confirm(`å‘ç°ä¿å­˜çš„ç¿»è¯‘å†…å®¹ (${new Date(savedTime).toLocaleString()}, è¯­è¨€: ${savedLang})ï¼Œæ˜¯å¦æ¢å¤ï¼Ÿ`)) {
                                setTranslationText(savedTranslation);
                                setTranslationSettings(prev => ({ ...prev, targetLanguage: savedLang || 'en' }));
                                message.success('ç¿»è¯‘å†…å®¹å·²æ¢å¤');
                            }
                        } else {
                            message.info('æ²¡æœ‰æ‰¾åˆ°ä¿å­˜çš„ç¿»è¯‘å†…å®¹');
                        }
                    };

                    // ç»„ä»¶å¸è½½æ—¶æ¸…ç†
                    useEffect(() => {
                        return () => {
                            if (timerRef.current) {
                                clearInterval(timerRef.current);
                            }
                            if (stream) {
                                stream.getTracks().forEach(track => track.stop());
                            }
                            if (videoUrl) {
                                URL.revokeObjectURL(videoUrl);
                            }
                        };
                    }, []);

                    // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥æ˜¯å¦æœ‰ä¿å­˜çš„å­—å¹•å’Œç¿»è¯‘
                    useEffect(() => {
                        const savedTranscript = localStorage.getItem('reactSavedTranscript');
                        if (savedTranscript) {
                            // å¯ä»¥é€‰æ‹©è‡ªåŠ¨åŠ è½½æˆ–æç¤ºç”¨æˆ·
                            console.log('å‘ç°ä¿å­˜çš„å­—å¹•å†…å®¹');
                        }
                        
                        // è‡ªåŠ¨åŠ è½½ä¿å­˜çš„ç¿»è¯‘
                        loadSavedTranslation();
                    }, []);

                    return React.createElement('div', { className: 'container' }, [
                        React.createElement('div', { className: 'header', key: 'header' }, [
                            React.createElement('h1', { key: 'title' }, 'ğŸ“¹ Reactå½•å±+éŸ³é¢‘è½¬å­—å¹•ç³»ç»Ÿ'),
                            React.createElement('p', { key: 'subtitle' }, 'åŸºäºReact 18 + Ant Designçš„ç°ä»£åŒ–å½•å±ä¸è¯­éŸ³è¯†åˆ«è§£å†³æ–¹æ¡ˆ')
                        ]),
                        React.createElement('div', { className: 'content', key: 'content' }, [
                            // æ§åˆ¶å’Œé¢„è§ˆé¢æ¿
                            React.createElement('div', { className: 'control-row', key: 'control-row' }, [
                                // æ§åˆ¶é¢æ¿
                                React.createElement('div', { className: 'panel', key: 'control-panel' }, [
                                    React.createElement('h2', { className: 'section-title', key: 'control-title' }, 'ğŸ® æ§åˆ¶é¢æ¿'),
                                    React.createElement(Alert, {
                                        key: 'status-alert',
                                        message: statusMessage,
                                        type: statusType,
                                        showIcon: true,
                                        style: { marginBottom: 20 },
                                        icon: isRecording ? React.createElement('span', { className: 'recording-indicator' }) : undefined
                                    }),
                                    React.createElement('div', { className: 'button-group', key: 'button-group' }, [
                                        React.createElement(Button, {
                                            key: 'start-btn',
                                            type: 'primary',
                                            icon: React.createElement(VideoCameraOutlined),
                                            onClick: startRecording,
                                            disabled: isRecording || !browserSupported
                                        }, 'å¼€å§‹å½•åˆ¶'),
                                        React.createElement(Button, {
                                            key: 'stop-btn',
                                            danger: true,
                                            icon: React.createElement(PauseCircleOutlined),
                                            onClick: stopRecording,
                                            disabled: !isRecording
                                        }, 'åœæ­¢å½•åˆ¶'),
                                        React.createElement(Button, {
                                            key: 'test-speech-btn',
                                            type: 'default',
                                            icon: React.createElement('span', {}, 'ğŸ¤'),
                                            onClick: testSpeechRecognition,
                                            disabled: isRecording
                                        }, 'æµ‹è¯•è¯­éŸ³è¯†åˆ«'),
                                        React.createElement(Button, {
                                            key: 'download-btn',
                                            type: 'primary',
                                            ghost: true,
                                            icon: React.createElement(DownloadOutlined),
                                            onClick: downloadVideo,
                                            disabled: !recordedVideo
                                        }, 'ä¸‹è½½è§†é¢‘'),
                                        React.createElement(Button, {
                                            key: 'clear-btn',
                                            icon: React.createElement(DeleteOutlined),
                                            onClick: clearTranscript
                                        }, 'æ¸…ç©ºå­—å¹•')
                                    ]),
                                    isRecording && React.createElement('div', { key: 'recording-status', style: { marginTop: 20 } }, [
                                        React.createElement('p', { key: 'time' }, `å½•åˆ¶æ—¶é—´: ${recordingTime}`),
                                        React.createElement(Progress, {
                                            key: 'progress',
                                            percent: recordingProgress,
                                            format: formatProgress,
                                            strokeColor: '#ff4757'
                                        })
                                    ])
                                ]),
                                // è§†é¢‘é¢„è§ˆé¢æ¿
                                React.createElement('div', { className: 'panel', key: 'video-panel' }, [
                                    React.createElement('h2', { className: 'section-title', key: 'video-title' }, 'ğŸ“º è§†é¢‘é¢„è§ˆ'),
                                    React.createElement('div', { className: 'video-container', key: 'video-container' }, [
                                        React.createElement('video', {
                                            key: 'video',
                                            ref: videoRef,
                                            controls: true,
                                            style: { display: recordedVideo || isRecording ? 'block' : 'none' },
                                            src: recordedVideo ? videoUrl : undefined
                                        }),
                                        (!isRecording && !recordedVideo) && React.createElement('div', {
                                            key: 'placeholder',
                                            className: 'video-placeholder'
                                        }, 'ç‚¹å‡»"å¼€å§‹å½•åˆ¶"å¼€å§‹å½•å±')
                                    ]),
                                    React.createElement(Card, {
                                        key: 'recording-info',
                                        size: 'small',
                                        title: 'å½•åˆ¶ä¿¡æ¯'
                                    }, React.createElement('div', {}, recordingInfo))
                                ])
                            ]),
                            // å­—å¹•é¢æ¿
                            React.createElement('div', { className: 'transcript-panel', key: 'transcript-panel' }, [
                                React.createElement('h2', { className: 'section-title', key: 'transcript-title' }, 'ğŸ“ å®æ—¶å­—å¹•'),
                                React.createElement('div', {
                                    key: 'transcript-content',
                                    className: 'transcript-content'
                                }, transcriptText || 'ç­‰å¾…è¯­éŸ³è¾“å…¥...'),
                                React.createElement('div', { className: 'button-group', key: 'transcript-buttons' }, [
                                    React.createElement(Button, {
                                        key: 'export-btn',
                                        icon: React.createElement(FileTextOutlined),
                                        onClick: exportTranscript
                                    }, 'å¯¼å‡ºå­—å¹•'),
                                    React.createElement(Button, {
                                        key: 'copy-btn',
                                        icon: React.createElement(CopyOutlined),
                                        onClick: copyTranscript
                                    }, 'å¤åˆ¶æ–‡æœ¬'),
                                    React.createElement(Button, {
                                        key: 'save-btn',
                                        icon: React.createElement(FolderOutlined),
                                        onClick: saveTranscript
                                    }, 'ä¿å­˜å­—å¹•'),
                                    React.createElement(Button, {
                                        key: 'load-btn',
                                        icon: React.createElement('span', {}, 'ğŸ“‚'),
                                        onClick: loadSavedTranscript
                                    }, 'åŠ è½½å­—å¹•')
                                ])
                            ]),
                            // ç¿»è¯‘é¢æ¿
                            React.createElement('div', { className: 'translation-panel', key: 'translation-panel' }, [
                                React.createElement('h2', { className: 'section-title', key: 'translation-title' }, 'ğŸŒ ç¿»è¯‘åŠŸèƒ½'),
                                React.createElement('div', {
                                    key: 'translation-controls',
                                    style: { marginBottom: 20 }
                                }, [
                                    React.createElement(Select, {
                                        key: 'api-select',
                                        value: currentTranslateApi,
                                        onChange: (value) => {
                                            setCurrentTranslateApi(value);
                                            if (isLocalFile && value !== 'localTranslate') {
                                                message.warning('æ³¨æ„ï¼šåœ¨æœ¬åœ°æ–‡ä»¶è¿è¡Œæ—¶ï¼Œç½‘ç»œç¿»è¯‘APIå¯èƒ½é‡åˆ°CORSé—®é¢˜ã€‚å»ºè®®ä½¿ç”¨"æœ¬åœ°ç¿»è¯‘"é€‰é¡¹ã€‚');
                                            }
                                        },
                                        style: { width: 180, marginRight: 15 },
                                        placeholder: 'é€‰æ‹©ç¿»è¯‘API'
                                    }, [
                                        React.createElement(Select.Option, { key: 'localTranslate', value: 'localTranslate' }, 'æœ¬åœ°ç¿»è¯‘ (æ— CORSé—®é¢˜)'),
                                        React.createElement(Select.Option, { key: 'myMemory', value: 'myMemory' }, 'MyMemory (å…è´¹)'),
                                        React.createElement(Select.Option, { key: 'googleTranslate', value: 'googleTranslate' }, 'Google Translate (å…è´¹)'),
                                        React.createElement(Select.Option, { key: 'libreTranslate', value: 'libreTranslate' }, 'LibreTranslate (å…è´¹)')
                                    ]),
                                    React.createElement(Select, {
                                        key: 'language-select',
                                        value: translationSettings.targetLanguage,
                                        onChange: (value) => setTranslationSettings(prev => ({ ...prev, targetLanguage: value })),
                                        style: { width: 200, marginRight: 15 },
                                        placeholder: 'é€‰æ‹©ç›®æ ‡è¯­è¨€'
                                    }, [
                                        React.createElement(Select.Option, { key: 'en', value: 'en' }, 'è‹±è¯­ (English)'),
                                        React.createElement(Select.Option, { key: 'ja', value: 'ja' }, 'æ—¥è¯­ (æ—¥æœ¬èª)'),
                                        React.createElement(Select.Option, { key: 'ko', value: 'ko' }, 'éŸ©è¯­ (í•œêµ­ì–´)'),
                                        React.createElement(Select.Option, { key: 'fr', value: 'fr' }, 'æ³•è¯­ (FranÃ§ais)'),
                                        React.createElement(Select.Option, { key: 'de', value: 'de' }, 'å¾·è¯­ (Deutsch)'),
                                        React.createElement(Select.Option, { key: 'es', value: 'es' }, 'è¥¿ç­ç‰™è¯­ (EspaÃ±ol)'),
                                        React.createElement(Select.Option, { key: 'ru', value: 'ru' }, 'ä¿„è¯­ (Ğ ÑƒÑÑĞºĞ¸Ğ¹)'),
                                        React.createElement(Select.Option, { key: 'ar', value: 'ar' }, 'é˜¿æ‹‰ä¼¯è¯­ (Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©)'),
                                        React.createElement(Select.Option, { key: 'pt', value: 'pt' }, 'è‘¡è„ç‰™è¯­ (PortuguÃªs)'),
                                        React.createElement(Select.Option, { key: 'it', value: 'it' }, 'æ„å¤§åˆ©è¯­ (Italiano)')
                                    ]),
                                    React.createElement(Button, {
                                        key: 'translate-btn',
                                        type: 'primary',
                                        icon: React.createElement(ReloadOutlined),
                                        onClick: translateTranscript,
                                        loading: isTranslating,
                                        disabled: !transcriptText || transcriptText === 'ç­‰å¾…è¯­éŸ³è¾“å…¥...'
                                    }, 'ç¿»è¯‘å­—å¹•'),
                                    React.createElement(Button, {
                                        key: 'clear-translation-btn',
                                        icon: React.createElement(DeleteOutlined),
                                        onClick: clearTranslation
                                    }, 'æ¸…ç©ºç¿»è¯‘')
                                ]),
                                translationStatus.show && React.createElement('div', {
                                    key: 'translation-status',
                                    className: 'translation-status'
                                }, React.createElement(Alert, {
                                    key: 'status-alert',
                                    message: translationStatus.message,
                                    type: translationStatus.type,
                                    showIcon: true,
                                    closable: false
                                })),
                                React.createElement('div', {
                                    key: 'translation-content',
                                    className: 'translation-content'
                                }, translationText || 'ç­‰å¾…ç¿»è¯‘...'),
                                React.createElement('div', { className: 'button-group', key: 'translation-buttons' }, [
                                    React.createElement(Button, {
                                        key: 'export-translation-btn',
                                        icon: React.createElement(FileTextOutlined),
                                        onClick: exportTranslation,
                                        disabled: !translationText || translationText === 'ç­‰å¾…ç¿»è¯‘...'
                                    }, 'å¯¼å‡ºç¿»è¯‘'),
                                    React.createElement(Button, {
                                        key: 'copy-translation-btn',
                                        icon: React.createElement(CopyOutlined),
                                        onClick: copyTranslation,
                                        disabled: !translationText || translationText === 'ç­‰å¾…ç¿»è¯‘...'
                                    }, 'å¤åˆ¶ç¿»è¯‘'),
                                    React.createElement(Button, {
                                        key: 'save-translation-btn',
                                        icon: React.createElement(FolderOutlined),
                                        onClick: saveTranslation,
                                        disabled: !translationText || translationText === 'ç­‰å¾…ç¿»è¯‘...'
                                    }, 'ä¿å­˜ç¿»è¯‘'),
                                    React.createElement(Button, {
                                        key: 'load-translation-btn',
                                        icon: React.createElement('span', {}, 'ğŸ“‚'),
                                        onClick: loadSavedTranslation
                                    }, 'åŠ è½½ç¿»è¯‘')
                                ])
                            ]),
                            // è®¾ç½®é¢æ¿
                            React.createElement('div', { className: 'settings-panel', key: 'settings-panel' }, [
                                React.createElement('h2', { className: 'section-title', key: 'settings-title' }, 'âš™ï¸ å½•åˆ¶è®¾ç½®'),
                                React.createElement('div', { className: 'settings-grid', key: 'settings-grid' }, [
                                    React.createElement(Select, {
                                        key: 'quality-select',
                                        value: settings.videoQuality,
                                        onChange: (value) => setSettings(prev => ({ ...prev, videoQuality: value })),
                                        placeholder: 'é€‰æ‹©è§†é¢‘è´¨é‡'
                                    }, [
                                        React.createElement(Select.Option, { key: '720p', value: '720p' }, '720p (æ¨è)'),
                                        React.createElement(Select.Option, { key: '1080p', value: '1080p' }, '1080p (é«˜è´¨é‡)'),
                                        React.createElement(Select.Option, { key: '480p', value: '480p' }, '480p (æµç•…)')
                                    ]),
                                    React.createElement(Select, {
                                        key: 'audio-select',
                                        value: settings.audioSource,
                                        onChange: (value) => setSettings(prev => ({ ...prev, audioSource: value })),
                                        placeholder: 'é€‰æ‹©éŸ³é¢‘æ¥æº'
                                    }, [
                                        React.createElement(Select.Option, { key: 'system', value: 'system' }, 'ç³»ç»ŸéŸ³é¢‘'),
                                        React.createElement(Select.Option, { key: 'microphone', value: 'microphone' }, 'éº¦å…‹é£'),
                                        React.createElement(Select.Option, { key: 'both', value: 'both' }, 'ç³»ç»Ÿ+éº¦å…‹é£')
                                    ]),
                                    React.createElement(Select, {
                                        key: 'lang-select',
                                        value: settings.language,
                                        onChange: (value) => setSettings(prev => ({ ...prev, language: value })),
                                        placeholder: 'è¯†åˆ«è¯­è¨€'
                                    }, [
                                        React.createElement(Select.Option, { key: 'zh-CN', value: 'zh-CN' }, 'ä¸­æ–‡ (ç®€ä½“)'),
                                        React.createElement(Select.Option, { key: 'en-US', value: 'en-US' }, 'English (US)'),
                                        React.createElement(Select.Option, { key: 'ja-JP', value: 'ja-JP' }, 'æ—¥æœ¬èª'),
                                        React.createElement(Select.Option, { key: 'ko-KR', value: 'ko-KR' }, 'í•œêµ­ì–´')
                                    ]),
                                    React.createElement(Switch, {
                                        key: 'cont-switch',
                                        checked: settings.continuous,
                                        onChange: (checked) => setSettings(prev => ({ ...prev, continuous: checked })),
                                        checkedChildren: 'è¿ç»­è¯†åˆ«',
                                        unCheckedChildren: 'å•æ¬¡è¯†åˆ«'
                                    })
                                ])
                            ])
                        ])
                    ]);
                };

                // æ¸²æŸ“åº”ç”¨
                const root = ReactDOM.createRoot(document.getElementById('root'));
                root.render(React.createElement(ScreenRecordApp));
                
            } catch (error) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                document.getElementById('root').innerHTML = `
                    <div class="error-message">
                        <h2>âŒ ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥</h2>
                        <p>é”™è¯¯ä¿¡æ¯: ${error.message}</p>
                        <p>è¯·åˆ·æ–°é¡µé¢é‡è¯•ï¼Œæˆ–æ£€æŸ¥ç½‘ç»œè¿æ¥</p>
                    </div>
                `;
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }
    </script>
</body>
</html>