<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2 å¢å¼ºç‰ˆäººè„¸è¯†åˆ« - åŒ…å«äººè„¸åº“å¯¹æ¯”</title>
    
    <!-- Vue2 + Element UI -->
    <script src="https://unpkg.com/vue@2/dist/vue.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
    <script src="https://unpkg.com/element-ui/lib/index.js"></script>
    
    <!-- face-api.js -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    
    <!-- äººè„¸æ•°æ®åº“ç®¡ç†å™¨ -->
    <script src="face-db-manager.js"></script>
    
    <!-- è°ƒè¯•åŠ©æ‰‹ -->
    <script src="debug-helper.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 16px;
            font-family: system-ui, sans-serif;
            color: #333;
            line-height: 1.5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid #ddd;
        }
        
        .header h1 {
            margin: 0;
            font-size: 1.8em;
            font-weight: 600;
            color: #333;
        }
        
        .header p {
            margin: 8px 0 0 0;
            color: #666;
        }
        
        .content {
            padding: 20px;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }
        
        .video-section {
            text-align: center;
        }
        
        .video-container {
            position: relative;
            display: inline-block;
            border: 1px solid #ddd;
            margin: 15px 0;
        }
        
        #video {
            display: block;
            width: 640px;
            height: 480px;
            max-width: 100%;
        }
        
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .controls {
            margin: 15px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .face-library-panel {
            border: 1px solid #ddd;
            padding: 15px;
        }
        
        .upload-area {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #999;
        }
        
        .face-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .face-card {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
            position: relative;
        }
        
        .face-card.matched {
            border-color: #28a745;
        }
        
        .face-image {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 8px;
        }
        
        .face-name {
            font-size: 11px;
            color: #333;
            margin-bottom: 4px;
        }
        
        .confidence-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            border: 1px solid #28a745;
            color: #28a745;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
        }
        
        .delete-btn {
            position: absolute;
            top: -5px;
            left: -5px;
            border: 1px solid #dc3545;
            color: #dc3545;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }
        
        .recognition-results {
            border: 1px solid #ddd;
            padding: 15px;
            margin-top: 15px;
        }
        
        .match-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 8px;
        }
        
        .match-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .match-info {
            flex: 1;
        }
        
        .match-name {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 3px;
        }
        
        .match-confidence {
            font-size: 12px;
            color: #666;
        }
        
        .settings-panel {
            border: 1px solid #ddd;
            padding: 15px;
            margin-top: 15px;
        }
        
        .setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .setting-label {
            min-width: 100px;
            color: #666;
        }
        
        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .stat-card {
            border: 1px solid #ddd;
            padding: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
            display: block;
        }
        
        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-top: 4px;
        }
        
        .comparison-mode {
            border: 1px solid #ddd;
            padding: 12px;
            margin: 12px 0;
            text-align: center;
        }
        
        .tech-specs {
            border: 1px solid #ddd;
            padding: 12px;
            margin-top: 12px;
        }
        
        .spec-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #eee;
        }
        
        .spec-item:last-child {
            border-bottom: none;
        }
        
        .spec-label {
            color: #666;
        }
        
        .spec-value {
            color: #333;
        }
        
        @media (max-width: 1200px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
            
            .stats-section {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            #video {
                width: 100%;
                height: auto;
            }
            
            .face-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .stats-section {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <!-- è¿”å›æ–‡æ¡£é“¾æ¥ -->
    <div style="position: fixed; top: 10px; left: 10px; z-index: 2000; background: rgba(255, 255, 255, 0.95); padding: 8px 12px; border-radius: 5px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);">
        <a href="https://www.siqiongbiluo.love/article/17" style="text-decoration: none; color: #4fc08d; font-size: 14px; font-weight: 500;">â† è¿”å›æ–‡æ¡£</a>
    </div>
    <div id="app">
        <div class="container">
            <div class="header">
                <h1>Vue2 å¢å¼ºç‰ˆäººè„¸è¯†åˆ«ç³»ç»Ÿ</h1>
                <p>æ”¯æŒäººè„¸åº“ç®¡ç†å’Œå®æ—¶è¯†åˆ«å¯¹æ¯”åŠŸèƒ½ (Options API)</p>
            </div>
            
            <div class="content">
                <div class="main-layout">
                    <!-- å·¦ä¾§ï¼šè§†é¢‘æ£€æµ‹åŒºåŸŸ -->
                    <div class="video-section">
                        <div class="video-container">
                            <video
                                id="video"
                                ref="video"
                                autoplay
                                muted
                                playsinline
                            ></video>
                            <canvas
                                id="overlay"
                                ref="overlay"
                                width="640"
                                height="480"
                            ></canvas>
                        </div>
                        
                        <!-- æ§åˆ¶æŒ‰é’® -->
                        <div class="controls">
                            <el-button 
                                type="primary" 
                                @click="startCamera" 
                                :disabled="isRunning"
                                :loading="isLoading"
                                size="medium"
                            >
                                {{ isLoading ? 'åŠ è½½ä¸­...' : 'å¯åŠ¨æ‘„åƒå¤´' }}
                            </el-button>
                            
                            <el-button 
                                type="danger" 
                                @click="stopCamera" 
                                :disabled="!isRunning"
                                size="medium"
                            >
                                åœæ­¢æ‘„åƒå¤´
                            </el-button>
                            
                            <el-button 
                                type="success" 
                                @click="captureAndAdd" 
                                :disabled="!isRunning || faceData.length === 0"
                                size="medium"
                            >
                                æ·»åŠ åˆ°äººè„¸åº“
                            </el-button>
                            
                            <el-button 
                                type="info" 
                                @click="toggleComparison" 
                                :disabled="!isRunning"
                                size="medium"
                            >
                                {{ comparisonMode ? 'å…³é—­è¯†åˆ«' : 'å¼€å¯è¯†åˆ«' }}
                            </el-button>
                        </div>
                        
                        <!-- å¯¹æ¯”æ¨¡å¼æç¤º -->
                        <div v-if="comparisonMode" class="comparison-mode">
                            <h4 style="margin: 0 0 10px 0;">äººè„¸è¯†åˆ«æ¨¡å¼å·²å¼€å¯</h4>
                            <p style="margin: 0;">æ­£åœ¨ä¸äººè„¸åº“ä¸­çš„ {{ faceLibrary.length }} ä¸ªäººè„¸è¿›è¡Œå®æ—¶å¯¹æ¯”</p>
                        </div>
                        
                        <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                        <div class="stats-section">
                            <div class="stat-card">
                                <span class="stat-value">{{ faceData.length }}</span>
                                <div class="stat-label">æ£€æµ‹äººè„¸</div>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">{{ matchedFaces.length }}</span>
                                <div class="stat-label">è¯†åˆ«åŒ¹é…</div>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">{{ fps }}</span>
                                <div class="stat-label">FPS</div>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">{{ faceLibrary.length }}</span>
                                <div class="stat-label">äººè„¸åº“</div>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">{{ detectionCount }}</span>
                                <div class="stat-label">æ£€æµ‹æ¬¡æ•°</div>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">{{ averageConfidence }}%</span>
                                <div class="stat-label">å¹³å‡ç½®ä¿¡åº¦</div>
                            </div>
                        </div>
                        
                        <!-- è¯†åˆ«ç»“æœ -->
                        <div v-if="matchedFaces.length > 0" class="recognition-results">
                            <h3 style="margin: 0 0 15px 0; color: #333;">è¯†åˆ«ç»“æœ</h3>
                            <div 
                                v-for="(match, index) in matchedFaces" 
                                :key="index"
                                class="match-item"
                            >
                                <img :src="match.faceImage" class="match-avatar" alt="åŒ¹é…äººè„¸">
                                <div class="match-info">
                                    <div class="match-name">{{ match.name }}</div>
                                    <div class="match-confidence">
                                        ç›¸ä¼¼åº¦: {{ (match.confidence * 100).toFixed(1) }}%
                                        <span v-if="match.distance < 0.4" style="color: #67c23a; margin-left: 10px;">é«˜åº¦åŒ¹é…</span>
                                        <span v-else-if="match.distance < 0.6" style="color: #e6a23c; margin-left: 10px;">å¯èƒ½åŒ¹é…</span>
                                        <span v-else style="color: #f56c6c; margin-left: 10px;">ä½åŒ¹é…åº¦</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- è®¾ç½®é¢æ¿ -->
                        <div class="settings-panel">
                            <h3 style="margin: 0 0 15px 0; color: #333;">æ£€æµ‹è®¾ç½®</h3>
                            
                            <div class="setting-item">
                                <span class="setting-label">æ£€æµ‹é˜ˆå€¼:</span>
                                <el-slider
                                    v-model="detectionScore"
                                    :min="0.1"
                                    :max="1"
                                    :step="0.1"
                                    show-input
                                    style="flex: 1;"
                                />
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">è¯†åˆ«é˜ˆå€¼:</span>
                                <el-slider
                                    v-model="recognitionThreshold"
                                    :min="0.3"
                                    :max="0.8"
                                    :step="0.05"
                                    show-input
                                    style="flex: 1;"
                                />
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">æ£€æµ‹é—´éš”:</span>
                                <el-slider
                                    v-model="detectionInterval"
                                    :min="100"
                                    :max="1000"
                                    :step="100"
                                    show-input
                                    style="flex: 1;"
                                />
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">è¾“å…¥å°ºå¯¸:</span>
                                <el-select v-model="inputSize" size="small" style="width: 120px;">
                                    <el-option label="128" :value="128" />
                                    <el-option label="160" :value="160" />
                                    <el-option label="224" :value="224" />
                                    <el-option label="320" :value="320" />
                                    <el-option label="416" :value="416" />
                                    <el-option label="512" :value="512" />
                                </el-select>
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">ç›®æ ‡FPS:</span>
                                <el-select v-model="targetFPS" size="small" style="width: 120px;">
                                    <el-option label="15 FPS" :value="15" />
                                    <el-option label="30 FPS" :value="30" />
                                    <el-option label="60 FPS" :value="60" />
                                </el-select>
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">æ˜¾ç¤ºå…³é”®ç‚¹:</span>
                                <el-switch
                                    v-model="showLandmarks"
                                    active-text="å¼€å¯"
                                    inactive-text="å…³é—­"
                                />
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">æ˜¾ç¤ºè¡¨æƒ…:</span>
                                <el-switch
                                    v-model="showExpressions"
                                    active-text="å¼€å¯"
                                    inactive-text="å…³é—­"
                                />
                            </div>
                        </div>
                        
                        <!-- ç³»ç»Ÿä¿¡æ¯é¢æ¿ -->
                        <div class="settings-panel">
                            <h3 style="margin: 0 0 15px 0; color: #333;">ç³»ç»Ÿä¿¡æ¯</h3>
                            
                            <div class="tech-specs">
                                <div class="spec-item">
                                    <span class="spec-label">æ¡†æ¶ç‰ˆæœ¬:</span>
                                    <span class="spec-value">Vue 2.x</span>
                                </div>
                                
                                <div class="spec-item">
                                    <span class="spec-label">æ£€æµ‹å¼•æ“:</span>
                                    <span class="spec-value">TinyFaceDetector</span>
                                </div>
                                
                                <div class="spec-item">
                                    <span class="spec-label">è¾“å…¥å°ºå¯¸:</span>
                                    <span class="spec-value">{{ inputSize }}x{{ inputSize }}</span>
                                </div>
                                
                                <div class="spec-item">
                                    <span class="spec-label">å½“å‰é˜ˆå€¼:</span>
                                    <span class="spec-value">{{ detectionScore }}</span>
                                </div>
                                
                                <div class="spec-item">
                                    <span class="spec-label">æ£€æµ‹é—´éš”:</span>
                                    <span class="spec-value">{{ detectionInterval }}ms</span>
                                </div>
                                
                                <div class="spec-item">
                                    <span class="spec-label">æµè§ˆå™¨æ”¯æŒ:</span>
                                    <span class="spec-value">
                                        <el-tag :type="browserSupport ? 'success' : 'danger'" size="small">
                                            {{ browserSupport ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ' }}
                                        </el-tag>
                                    </span>
                                </div>
                            </div>
                            
                            <!-- åŠŸèƒ½ç‰¹æ€§ -->
                            <h4 style="margin: 20px 0 15px 0; color: #666;">åŠŸèƒ½ç‰¹æ€§</h4>
                            <div>
                                <el-tag v-for="feature in features" :key="feature" style="margin: 3px;">
                                    {{ feature }}
                                </el-tag>
                            </div>
                        </div>
                    </div>
                    
                    <!-- å³ä¾§ï¼šäººè„¸åº“ç®¡ç† -->
                    <div class="face-library-panel">
                        <h3 style="margin: 0 0 20px 0; color: #333;">äººè„¸åº“ç®¡ç†</h3>
                        
                        <!-- ä¸Šä¼ åŒºåŸŸ -->
                        <div 
                            class="upload-area"
                            @click="$refs.fileInput.click()"
                            @dragover.prevent="handleDragOver"
                            @dragleave.prevent="handleDragLeave"
                            @drop.prevent="handleDrop"
                            :class="{ dragover: isDragging }"
                        >
                            <i class="el-icon-upload" style="font-size: 48px; color: #909399; margin-bottom: 10px;"></i>
                            <div style="color: #606266; margin-bottom: 10px;">
                                ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ äººè„¸ç…§ç‰‡
                            </div>
                            <div style="color: #909399; font-size: 12px;">
                                æ”¯æŒ JPGã€PNG æ ¼å¼
                            </div>
                        </div>
                        
                        <input 
                            ref="fileInput" 
                            type="file" 
                            accept="image/*" 
                            multiple
                            style="display: none"
                            @change="handleFileSelect"
                        >
                        
                        <!-- æ‰¹é‡æ“ä½œ -->
                        <div style="margin: 15px 0; display: flex; gap: 10px; flex-wrap: wrap;">
                            <el-button 
                                size="small" 
                                type="primary"
                                @click="importLibrary"
                                icon="el-icon-upload"
                            >
                                å¯¼å…¥æ•°æ®
                            </el-button>
                            <el-button 
                                size="small" 
                                type="info"
                                @click="exportLibrary"
                                :disabled="faceLibrary.length === 0"
                                icon="el-icon-download"
                            >
                                å¯¼å‡ºJSON
                            </el-button>
                            <el-button 
                                size="small" 
                                type="success"
                                @click="exportImages"
                                :disabled="faceLibrary.length === 0"
                                icon="el-icon-picture"
                            >
                                å¯¼å‡ºå›¾ç‰‡
                            </el-button>
                            <el-button 
                                size="small" 
                                type="warning"
                                @click="clearLibrary"
                                :disabled="faceLibrary.length === 0"
                                icon="el-icon-delete"
                            >
                                æ¸…ç©ºäººè„¸åº“
                            </el-button>
                        </div>
                        
                        <!-- é«˜çº§æ“ä½œ -->
                        <div style="margin: 15px 0; border-top: 1px solid #e0e0e0; padding-top: 15px;">
                            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                <el-button 
                                    size="small" 
                                    type="success"
                                    @click="showStorageUsage"
                                    icon="el-icon-pie-chart"
                                >
                                    å­˜å‚¨ä½¿ç”¨æƒ…å†µ
                                </el-button>
                                <el-button 
                                    size="small" 
                                    type="danger"
                                    @click="clearAllCache"
                                    icon="el-icon-refresh"
                                >
                                    æ¸…é™¤æ‰€æœ‰ç¼“å­˜
                                </el-button>
                            </div>
                            <div style="margin-top: 8px; font-size: 11px; color: #999; line-height: 1.4;">
                                "æ¸…é™¤æ‰€æœ‰ç¼“å­˜"å°†å½»åº•åˆ é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®ï¼ŒåŒ…æ‹¬äººè„¸åº“ã€è®¾ç½®å’Œç¼“å­˜ï¼Œæ“ä½œä¸å¯æ’¤é”€
                            </div>
                        </div>
                        
                        <!-- æ•°æ®åº“çŠ¶æ€ä¿¡æ¯ -->
                        <div style="border: 1px solid #f8f9fa; border-radius: 8px; padding: 15px; margin: 15px 0; font-size: 12px; color: #666;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span>æœ¬åœ°æ•°æ®åº“å­˜å‚¨</span>
                                <el-button size="mini" type="text" @click="showDatabaseStats">
                                    æŸ¥çœ‹ç»Ÿè®¡
                                </el-button>
                            </div>
                            <div style="margin-top: 8px; font-size: 11px; opacity: 0.8;">
                                æ•°æ®è‡ªåŠ¨ä¿å­˜åˆ°æµè§ˆå™¨IndexedDBï¼Œæ°¸ä¹…å­˜å‚¨
                            </div>
                        </div>
                        
                        <!-- äººè„¸åº“å±•ç¤º -->
                        <div v-if="faceLibrary.length === 0" style="text-align: center; color: #909399; padding: 40px 0;">
                            æš‚æ— äººè„¸æ•°æ®<br>
                            <small>è¯·ä¸Šä¼ ç…§ç‰‡æˆ–ä»æ‘„åƒå¤´æ·»åŠ </small>
                        </div>
                        
                        <div v-else class="face-grid">
                            <div 
                                v-for="(face, index) in faceLibrary" 
                                :key="face.id"
                                class="face-card"
                                :class="{ matched: isMatched(face.id) }"
                            >
                                <button 
                                    class="delete-btn"
                                    @click="removeFace(index)"
                                    title="åˆ é™¤"
                                >
                                    Ã—
                                </button>
                                
                                <img :src="face.image" class="face-image" :alt="face.name">
                                <div class="face-name">{{ face.name }}</div>
                                <div style="font-size: 11px; color: #909399;">
                                    {{ new Date(face.timestamp).toLocaleDateString() }}
                                </div>
                                
                                <div 
                                    v-if="isMatched(face.id)" 
                                    class="confidence-badge"
                                    :title="`åŒ¹é…åº¦: ${getMatchConfidence(face.id)}%`"
                                >
                                    {{ getMatchConfidence(face.id) }}%
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- æ·»åŠ äººè„¸å¯¹è¯æ¡† -->
        <el-dialog 
            :visible.sync="showAddDialog" 
            title="æ·»åŠ åˆ°äººè„¸åº“"
            width="500px"
            center
        >
            <div style="text-align: center;">
                <canvas 
                    ref="captureCanvas" 
                    width="300" 
                    height="300" 
                    style="border: 2px solid #e0e0e0; border-radius: 10px; margin-bottom: 20px; max-width: 250px; max-height: 250px;"
                ></canvas>
                
                <el-form label-width="80px">
                    <el-form-item label="å§“å:">
                        <el-input 
                            v-model="newFaceName" 
                            placeholder="è¯·è¾“å…¥å§“å"
                            maxlength="20"
                            show-word-limit
                        />
                    </el-form-item>
                    <el-form-item label="å¤‡æ³¨:">
                        <el-input 
                            v-model="newFaceNote" 
                            placeholder="å¯é€‰å¤‡æ³¨ä¿¡æ¯"
                            maxlength="50"
                            show-word-limit
                        />
                    </el-form-item>
                </el-form>
            </div>
            
            <span slot="footer" class="dialog-footer">
                <el-button @click="showAddDialog = false">å–æ¶ˆ</el-button>
                <el-button type="primary" @click="confirmAddFace" :disabled="!newFaceName.trim()">
                    æ·»åŠ åˆ°äººè„¸åº“
                </el-button>
            </span>
        </el-dialog>
    </div>

    <script>
        new Vue({
            el: '#app',
            data() {
                return {
                    // åŸºç¡€çŠ¶æ€
                    isRunning: false,
                    isDetecting: true,
                    isLoading: false,
                    modelsLoaded: false,
                    comparisonMode: false,
                    
                    // æ£€æµ‹æ•°æ®
                    faceData: [],
                    matchedFaces: [],
                    stream: null,
                    detectionIntervalId: null,
                    
                    // äººè„¸åº“
                    faceLibrary: [],
                    faceMatcher: null,
                    faceDB: null,  // IndexedDB ç®¡ç†å™¨
                    
                    // è®¾ç½®
                    recognitionThreshold: 0.6,
                    detectionInterval: 200,
                    showLandmarks: true,
                    showExpressions: true,
                    
                    // æ£€æµ‹å‚æ•°
                    detectionScore: 0.5,
                    inputSize: 416,
                    targetFPS: 30,
                    
                    // ç»Ÿè®¡ä¿¡æ¯
                    detectionCount: 0,
                    
                    // æµè§ˆå™¨æ”¯æŒæ£€æµ‹
                    browserSupport: false,
                    
                    // UI çŠ¶æ€
                    showAddDialog: false,
                    newFaceName: '',
                    newFaceNote: '',
                    currentCapturedFace: null,
                    isDragging: false,
                    
                    // æ€§èƒ½ç»Ÿè®¡
                    fps: 0,
                    fpsCounter: 0,
                    lastFpsUpdate: Date.now()
                }
            },
            
            computed: {
                averageConfidence() {
                    if (this.faceData.length === 0) return 0
                    const total = this.faceData.reduce((sum, face) => 
                        sum + face.detection.score, 0
                    )
                    return ((total / this.faceData.length) * 100).toFixed(1)
                },
                
                features() {
                    return [
                        'å®æ—¶äººè„¸æ£€æµ‹',
                        '68ä¸ªå…³é”®ç‚¹',
                        '7ç§è¡¨æƒ…è¯†åˆ«', 
                        'å¹´é¾„æ€§åˆ«é¢„æµ‹',
                        'å¤šäººè„¸æ£€æµ‹',
                        'äººè„¸åº“ç®¡ç†',
                        'å®æ—¶è¯†åˆ«å¯¹æ¯”',
                        'æ•°æ®æŒä¹…åŒ–'
                    ]
                }
            },
            
                            watch: {
                detectionInterval(newInterval) {
                    if (this.isDetecting) {
                        this.stopDetection()
                        this.startDetection()
                    }
                },
                
                recognitionThreshold() {
                    this.updateFaceMatcher()
                },
                
                faceLibrary: {
                    handler() {
                        this.updateFaceMatcher()
                    },
                    deep: true
                }
            },
            
            async mounted() {
                console.log('ç»„ä»¶åˆå§‹åŒ–å¼€å§‹...')
                
                // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
                this.checkBrowserSupport()
                
                try {
                    // åˆå§‹åŒ–æ•°æ®åº“
                    console.log('åˆå§‹åŒ–æ•°æ®åº“...')
                    this.faceDB = window.faceDB || new FaceDBManager()
                    console.log('æ•°æ®åº“ç®¡ç†å™¨åˆ›å»º:', !!this.faceDB)
                    
                    await this.faceDB.init()
                    console.log('æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ')
                    
                    // åŠ è½½æ¨¡å‹å’Œäººè„¸åº“
                    console.log('ğŸ§  å¼€å§‹åŠ è½½AIæ¨¡å‹...')
                    await this.loadModels()
                    
                    console.log('å¼€å§‹åŠ è½½äººè„¸åº“...')
                    await this.loadFaceLibrary()
                    
                    console.log('ç»„ä»¶åˆå§‹åŒ–å®Œæˆ')
                } catch (error) {
                    console.error('ç»„ä»¶åˆå§‹åŒ–å¤±è´¥:', error)
                    this.$message.error('åˆå§‹åŒ–å¤±è´¥: ' + error.message)
                }
            },
            

            
            methods: {
                // æµè§ˆå™¨æ”¯æŒæ£€æµ‹
                checkBrowserSupport() {
                    this.browserSupport = !!(
                        navigator.mediaDevices && 
                        navigator.mediaDevices.getUserMedia &&
                        document.createElement('canvas').getContext('webgl')
                    )
                },
                
                // è¡¨æƒ…æ ‡ç­¾æ˜ å°„
                getExpressionLabel(expression) {
                    const labels = {
                        neutral: 'ä¸­æ€§',
                        happy: 'å¼€å¿ƒ',
                        sad: 'æ‚²ä¼¤',
                        angry: 'æ„¤æ€’',
                        fearful: 'ææƒ§',
                        disgusted: 'åŒæ¶',
                        surprised: 'æƒŠè®¶'
                    }
                    return labels[expression] || expression
                },
                
                // æ¨¡å‹åŠ è½½
                async loadModels() {
                    this.isLoading = true
                    
                    try {
                        console.log('å¼€å§‹åŠ è½½å¢å¼ºç‰ˆæ¨¡å‹...')
                        const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.12/model'
                        
                        await Promise.all([
                            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                            faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                            faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
                            faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
                            faceapi.nets.ageGenderNet.loadFromUri(MODEL_URL)
                        ])
                        
                        this.modelsLoaded = true
                        console.log('å¢å¼ºç‰ˆæ¨¡å‹åŠ è½½å®Œæˆ')
                        this.$message.success('äººè„¸è¯†åˆ«æ¨¡å‹åŠ è½½å®Œæˆ')
                    } catch (error) {
                        console.error('æ¨¡å‹åŠ è½½å¤±è´¥:', error)
                        this.$message.error('æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥')
                    } finally {
                        this.isLoading = false
                    }
                },
                
                // æ‘„åƒå¤´æ§åˆ¶
                async startCamera() {
                    if (!this.modelsLoaded) {
                        this.$message.warning('æ¨¡å‹å°šæœªåŠ è½½å®Œæˆ')
                        return
                    }
                    
                    try {
                        this.stream = await navigator.mediaDevices.getUserMedia({
                            video: { width: 640, height: 480, facingMode: 'user' },
                            audio: false
                        })
                        
                        this.$refs.video.srcObject = this.stream
                        
                        this.$refs.video.addEventListener('loadedmetadata', () => {
                            this.isRunning = true
                            this.isDetecting = true  // ç¡®ä¿æ£€æµ‹çŠ¶æ€ä¸ºå¼€å¯
                            this.startDetection()
                        })
                        
                        this.$message.success('æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ')
                    } catch (error) {
                        this.$message.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥: ' + error.message)
                    }
                },
                
                stopCamera() {
                    this.cleanup()
                    this.isRunning = false
                    this.isDetecting = false
                    this.comparisonMode = false
                    this.faceData = []
                    this.matchedFaces = []
                    this.fps = 0
                    this.$message.info('æ‘„åƒå¤´å·²åœæ­¢')
                },
                
                // æ£€æµ‹æ§åˆ¶
                startDetection() {
                    if (!this.isDetecting) return
                    
                    this.detectionIntervalId = setInterval(async () => {
                        await this.detectFaces()
                        this.updateFPS()
                    }, this.detectionInterval)
                },
                
                stopDetection() {
                    if (this.detectionIntervalId) {
                        clearInterval(this.detectionIntervalId)
                        this.detectionIntervalId = null
                    }
                },
                
                // äººè„¸æ£€æµ‹
                async detectFaces() {
                    const video = this.$refs.video
                    const canvas = this.$refs.overlay
                    
                    if (!video || !canvas || !this.modelsLoaded) return
                    
                    try {
                        const options = new faceapi.TinyFaceDetectorOptions({
                            inputSize: this.inputSize,
                            scoreThreshold: this.detectionScore
                        })
                        
                        // åŸºç¡€æ£€æµ‹ï¼ˆå§‹ç»ˆå¯ç”¨ï¼‰
                        let detections = await faceapi
                            .detectAllFaces(video, options)
                            .withFaceLandmarks()
                            .withFaceExpressions()
                            .withAgeAndGender()
                        
                        // å¦‚æœéœ€è¦äººè„¸è¯†åˆ«åŠŸèƒ½ï¼Œæ·»åŠ æè¿°ç¬¦
                        if (this.comparisonMode && detections.length > 0) {
                            try {
                                detections = await faceapi
                                    .detectAllFaces(video, options)
                                    .withFaceLandmarks()
                                    .withFaceDescriptors()
                                    .withFaceExpressions()
                                    .withAgeAndGender()
                            } catch (descriptorError) {
                                console.warn('æè¿°ç¬¦æå–å¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€æ£€æµ‹:', descriptorError)
                                // ç»§ç»­ä½¿ç”¨åŸºç¡€æ£€æµ‹ç»“æœ
                            }
                        }
                        
                        // æ¸…é™¤ç”»å¸ƒ
                        const ctx = canvas.getContext('2d')
                        ctx.clearRect(0, 0, canvas.width, canvas.height)
                        
                        // æ›´æ–°æ£€æµ‹æ•°æ®
                        this.faceData = detections.map(detection => ({
                            detection: detection.detection,
                            landmarks: detection.landmarks,
                            descriptor: detection.descriptor || null,
                            expressions: detection.expressions,
                            age: detection.age,
                            gender: detection.gender
                        }))
                        
                        // è°ƒè¯•æ—¥å¿—ï¼šæ˜¾ç¤ºæ£€æµ‹åˆ°çš„äººè„¸æ•°é‡
                        if (this.faceData.length > 0) {
                            console.log('æ£€æµ‹åˆ°äººè„¸:', this.faceData.length, 'ä¸ªï¼Œæœ€é«˜ç½®ä¿¡åº¦:', 
                                Math.max(...this.faceData.map(f => f.detection.score)).toFixed(3))
                        }
                        
                        // äººè„¸è¯†åˆ«å¯¹æ¯”
                        if (this.comparisonMode && this.faceMatcher && detections.some(d => d.descriptor)) {
                            this.performFaceRecognition(detections)
                        } else {
                            this.matchedFaces = []
                        }
                        
                        // ç»˜åˆ¶ç»“æœ
                        this.drawDetections(detections, canvas)
                        
                        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                        this.detectionCount++
                        
                    } catch (error) {
                        console.error('æ£€æµ‹å¤±è´¥:', error)
                    }
                },
                
                // äººè„¸è¯†åˆ«å¯¹æ¯”
                performFaceRecognition(detections) {
                    const matches = []
                    
                    detections.forEach((detection, index) => {
                        if (detection.descriptor && this.faceMatcher) {
                            try {
                                const bestMatch = this.faceMatcher.findBestMatch(detection.descriptor)
                                
                                if (bestMatch.distance < this.recognitionThreshold) {
                                    const faceInLibrary = this.faceLibrary.find(f => f.name === bestMatch.label)
                                    if (faceInLibrary) {
                                        matches.push({
                                            faceId: faceInLibrary.id,
                                            name: bestMatch.label,
                                            distance: bestMatch.distance,
                                            confidence: 1 - bestMatch.distance,
                                            faceImage: faceInLibrary.image,
                                            detectionIndex: index
                                        })
                                    }
                                }
                            } catch (error) {
                                console.warn('äººè„¸åŒ¹é…å¤±è´¥:', error)
                            }
                        }
                    })
                    
                    this.matchedFaces = matches
                },
                
                // ç»˜åˆ¶æ£€æµ‹ç»“æœ
                drawDetections(detections, canvas) {
                    const ctx = canvas.getContext('2d')
                    
                    detections.forEach((detection, index) => {
                        const { x, y, width, height } = detection.detection.box
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰åŒ¹é…
                        const match = this.matchedFaces.find(m => m.detectionIndex === index)
                        const isMatched = !!match
                        
                        // ç»˜åˆ¶äººè„¸æ¡†
                        ctx.strokeStyle = isMatched ? '#67c23a' : '#00ff00'
                        ctx.lineWidth = isMatched ? 4 : 3
                        ctx.strokeRect(x, y, width, height)
                        
                        // ç»˜åˆ¶æ ‡ç­¾
                        const score = (detection.detection.score * 100).toFixed(1)
                        let label = `äººè„¸ ${index + 1} (${score}%)`
                        
                        if (isMatched) {
                            label = `${match.name} (${(match.confidence * 100).toFixed(1)}%)`
                        }
                        
                        ctx.font = 'bold 16px Arial'
                        const textWidth = ctx.measureText(label).width
                        
                        ctx.fillStyle = isMatched ? 'rgba(103, 194, 58, 0.9)' : 'rgba(0, 255, 0, 0.8)'
                        ctx.fillRect(x, y - 30, textWidth + 10, 25)
                        
                        ctx.fillStyle = 'white'
                        ctx.fillText(label, x + 5, y - 10)
                        
                        // ç»˜åˆ¶å¹´é¾„æ€§åˆ«ä¿¡æ¯
                        if (detection.age && detection.gender) {
                            const ageText = `å¹´é¾„: ${Math.round(detection.age)}å²`
                            const genderText = `æ€§åˆ«: ${detection.gender === 'male' ? 'ç”·' : 'å¥³'}`
                            const genderConfidence = Math.round(detection.genderProbability * 100)
                            
                            ctx.font = '12px Arial'
                            const ageWidth = ctx.measureText(ageText).width
                            const genderWidth = ctx.measureText(genderText).width
                            const maxWidth = Math.max(ageWidth, genderWidth)
                            
                            // å¹´é¾„ä¿¡æ¯
                            ctx.fillStyle = 'rgba(255, 165, 0, 0.8)'
                            ctx.fillRect(x, y + height + 5, ageWidth + 8, 18)
                            ctx.fillStyle = 'white'
                            ctx.fillText(ageText, x + 4, y + height + 18)
                            
                            // æ€§åˆ«ä¿¡æ¯
                            ctx.fillStyle = 'rgba(255, 20, 147, 0.8)'
                            ctx.fillRect(x, y + height + 25, genderWidth + 8, 18)
                            ctx.fillStyle = 'white'
                            ctx.fillText(genderText, x + 4, y + height + 38)
                            
                            // æ€§åˆ«ç½®ä¿¡åº¦
                            if (genderConfidence < 80) {
                                const confidenceText = `ç½®ä¿¡åº¦: ${genderConfidence}%`
                                ctx.font = '10px Arial'
                                const confWidth = ctx.measureText(confidenceText).width
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'
                                ctx.fillRect(x, y + height + 45, confWidth + 6, 14)
                                ctx.fillStyle = 'white'
                                ctx.fillText(confidenceText, x + 3, y + height + 55)
                            }
                        }
                        
                        // ç»˜åˆ¶å…³é”®ç‚¹
                        if (this.showLandmarks && detection.landmarks) {
                            ctx.fillStyle = isMatched ? '#67c23a' : '#ff0000'
                            detection.landmarks.positions.forEach(point => {
                                ctx.beginPath()
                                ctx.arc(point.x, point.y, 2, 0, 2 * Math.PI)
                                ctx.fill()
                            })
                        }
                        
                        // ç»˜åˆ¶è¡¨æƒ…ä¿¡æ¯
                        if (this.showExpressions && detection.expressions) {
                            const expressions = Object.entries(detection.expressions)
                                .sort(([,a], [,b]) => b - a)
                                .slice(0, 2) // æ˜¾ç¤ºå‰2ä¸ªè¡¨æƒ…
                            
                            expressions.forEach(([expression, confidence], i) => {
                                if (confidence > 0.3) { // åªæ˜¾ç¤ºç½®ä¿¡åº¦è¾ƒé«˜çš„è¡¨æƒ…
                                    const expressionText = `${this.getExpressionLabel(expression)}: ${Math.round(confidence * 100)}%`
                                    
                                    ctx.font = '12px Arial'
                                    const textWidth = ctx.measureText(expressionText).width
                                    const yPos = y + height + (detection.age && detection.gender ? 65 : 20) + i * 20
                                    
                                    ctx.fillStyle = 'rgba(0, 0, 255, 0.8)'
                                    ctx.fillRect(x, yPos - 15, textWidth + 8, 18)
                                    
                                    ctx.fillStyle = 'white'
                                    ctx.fillText(expressionText, x + 4, yPos)
                                }
                            })
                        }
                    })
                },
                
                // äººè„¸åº“ç®¡ç†
                updateFaceMatcher() {
                    if (this.faceLibrary.length === 0) {
                        this.faceMatcher = null
                        console.log('äººè„¸åº“ä¸ºç©ºï¼Œæ¸…é™¤äººè„¸åŒ¹é…å™¨')
                        return
                    }
                    
                    // å®½æ¾éªŒè¯æè¿°ç¬¦ï¼ˆä¸Vue3ä¿æŒä¸€è‡´ï¼‰
                    const facesWithValidDescriptors = this.faceLibrary.filter(face => {
                        if (!face.descriptor) {
                            console.warn(`äººè„¸ "${face.name}" ç¼ºå°‘æè¿°ç¬¦`)
                            return false
                        }
                        
                        // åŸºæœ¬ç±»å‹å’Œç»´åº¦æ£€æŸ¥
                        if ((Array.isArray(face.descriptor) || face.descriptor instanceof Float32Array) && 
                            face.descriptor.length === 128) {
                            
                            // ç®€å•çš„æ•°å€¼æœ‰æ•ˆæ€§æ£€æŸ¥
                            const hasValidNumbers = Array.from(face.descriptor).some(val => 
                                typeof val === 'number' && !isNaN(val) && isFinite(val)
                            )
                            
                            if (hasValidNumbers) {
                                console.log(`âœ… äººè„¸ "${face.name}" æè¿°ç¬¦éªŒè¯é€šè¿‡`)
                                return true
                            } else {
                                console.warn(`âš ï¸ äººè„¸ "${face.name}" æè¿°ç¬¦æ•°å€¼å¼‚å¸¸ï¼Œä½†ä»å°è¯•ä½¿ç”¨`)
                                return true // å®½æ¾å¤„ç†ï¼Œä»ç„¶ä½¿ç”¨
                            }
                        } else {
                            console.warn(`âŒ äººè„¸ "${face.name}" æè¿°ç¬¦æ ¼å¼æˆ–ç»´åº¦æ— æ•ˆ:`, {
                                type: typeof face.descriptor,
                                isArray: Array.isArray(face.descriptor),
                                isFloat32Array: face.descriptor instanceof Float32Array,
                                length: face.descriptor ? face.descriptor.length : 'undefined'
                            })
                            return false
                        }
                    })
                    
                    if (facesWithValidDescriptors.length === 0) {
                        this.faceMatcher = null
                        console.warn('äººè„¸åº“ä¸­æ²¡æœ‰å¯ç”¨äºè¯†åˆ«çš„äººè„¸ï¼ˆæ‰€æœ‰æè¿°ç¬¦éƒ½æ— æ•ˆï¼‰')
                        console.log('æç¤ºï¼šè¯·ç¡®ä¿æ·»åŠ äººè„¸æ—¶æˆåŠŸæå–äº†128ç»´æè¿°ç¬¦')
                        return
                    }
                    
                    try {
                        const labeledDescriptors = facesWithValidDescriptors.map(face => {
                            // ç¡®ä¿æè¿°ç¬¦æ˜¯Float32Arrayæ ¼å¼
                            const descriptor = face.descriptor instanceof Float32Array 
                                ? face.descriptor 
                                : new Float32Array(face.descriptor)
                            
                            return new faceapi.LabeledFaceDescriptors(
                                face.name,
                                [descriptor]
                            )
                        })
                        
                        this.faceMatcher = new faceapi.FaceMatcher(labeledDescriptors, this.recognitionThreshold)
                        console.log(`âœ… äººè„¸åŒ¹é…å™¨å·²æ›´æ–°ï¼ŒåŒ…å« ${labeledDescriptors.length} ä¸ªå¯è¯†åˆ«çš„äººè„¸`)
                        console.log(`ğŸ“Š äººè„¸åº“ç»Ÿè®¡ï¼šæ€»è®¡ ${this.faceLibrary.length} ä¸ªï¼Œå¯è¯†åˆ« ${facesWithValidDescriptors.length} ä¸ª`)
                    } catch (error) {
                        console.error('âŒ æ›´æ–°äººè„¸åŒ¹é…å™¨å¤±è´¥:', error)
                        console.error('é”™è¯¯è¯¦æƒ…:', error.message)
                        this.faceMatcher = null
                    }
                },
                
                async captureAndAdd() {
                    console.log('å¼€å§‹æ•è·äººè„¸ï¼Œå½“å‰æ£€æµ‹åˆ°çš„äººè„¸æ•°é‡:', this.faceData.length)
                    
                    if (this.faceData.length === 0) {
                        this.$message.warning('æœªæ£€æµ‹åˆ°äººè„¸')
                        return
                    }
                    
                    // é€‰æ‹©ç½®ä¿¡åº¦æœ€é«˜çš„äººè„¸
                    const bestFace = this.faceData.reduce((best, current) => 
                        current.detection.score > best.detection.score ? current : best
                    )
                    
                    console.log('é€‰æ‹©çš„æœ€ä½³äººè„¸:', {
                        score: bestFace.detection.score,
                        hasDescriptor: !!bestFace.descriptor,
                        box: bestFace.detection.box
                    })
                    
                    // æ£€æŸ¥è§†é¢‘å…ƒç´ 
                    const video = this.$refs.video
                    
                    console.log('è§†é¢‘å…ƒç´ çŠ¶æ€:', {
                        video: !!video,
                        videoReady: video && video.readyState >= 2
                    })
                    
                    if (!video) {
                        this.$message.error('è§†é¢‘å…ƒç´ æœªæ‰¾åˆ°')
                        return
                    }
                    
                    if (video.readyState < 2) {
                        this.$message.warning('è§†é¢‘å°šæœªå‡†å¤‡å°±ç»ªï¼Œè¯·ç¨åå†è¯•')
                        return
                    }
                    
                    // å…ˆåˆ›å»ºä¸´æ—¶canvasæ¥æ•è·äººè„¸å›¾åƒ
                    const tempCanvas = document.createElement('canvas')
                    tempCanvas.width = 300  // å¢å¤§å°ºå¯¸
                    tempCanvas.height = 300
                    const ctx = tempCanvas.getContext('2d')
                    
                    const { x, y, width, height } = bestFace.detection.box
                    
                    // æ·»åŠ paddingï¼Œæ‰©å±•æ•è·åŒºåŸŸ
                    const padding = Math.max(width, height) * 0.3  // 30%çš„padding
                    const expandedX = Math.max(0, x - padding)
                    const expandedY = Math.max(0, y - padding)
                    const expandedWidth = Math.min(video.videoWidth - expandedX, width + padding * 2)
                    const expandedHeight = Math.min(video.videoHeight - expandedY, height + padding * 2)
                    
                    console.log('å›¾åƒæ•è·å‚æ•°:', {
                        original: { x, y, width, height },
                        expanded: { x: expandedX, y: expandedY, width: expandedWidth, height: expandedHeight },
                        padding: padding,
                        videoSize: { width: video.videoWidth, height: video.videoHeight }
                    })
                    
                    const scale = Math.min(300 / expandedWidth, 300 / expandedHeight)
                    const scaledWidth = expandedWidth * scale
                    const scaledHeight = expandedHeight * scale
                    
                    try {
                        ctx.clearRect(0, 0, 300, 300)
                        ctx.drawImage(
                            video,
                            expandedX, expandedY, expandedWidth, expandedHeight,
                            (300 - scaledWidth) / 2, (300 - scaledHeight) / 2, scaledWidth, scaledHeight
                        )
                        
                                                 // ä¸¥æ ¼çš„æè¿°ç¬¦æå–å’ŒéªŒè¯é€»è¾‘
                         let descriptor = bestFace.descriptor
                         
                         // å®½æ¾çš„æè¿°ç¬¦éªŒè¯é€»è¾‘ï¼ˆä¸Vue3ä¿æŒä¸€è‡´ï¼‰
                         if (descriptor) {
                             // åŸºæœ¬æ ¼å¼æ£€æŸ¥
                             if (Array.isArray(descriptor) || descriptor instanceof Float32Array) {
                                 if (descriptor.length === 128) {
                                     // ç®€å•çš„æ•°å€¼æœ‰æ•ˆæ€§æ£€æŸ¥
                                     const hasValidNumbers = Array.from(descriptor).some(val => 
                                         typeof val === 'number' && !isNaN(val) && isFinite(val)
                                     )
                                     if (hasValidNumbers) {
                                         console.log('âœ… ç°æœ‰æè¿°ç¬¦éªŒè¯é€šè¿‡ï¼Œ128ç»´æœ‰æ•ˆæè¿°ç¬¦')
                                     } else {
                                         console.warn('ç°æœ‰æè¿°ç¬¦æ•°å€¼å¼‚å¸¸ï¼Œä½†ä»å°è¯•ä½¿ç”¨')
                                     }
                                 } else {
                                     console.warn(`ç°æœ‰æè¿°ç¬¦ç»´åº¦ï¼š${descriptor.length}ï¼ŒæœŸæœ›128ç»´ï¼Œé‡æ–°æå–`)
                                     descriptor = null
                                 }
                             } else {
                                 console.warn('ç°æœ‰æè¿°ç¬¦æ ¼å¼æ— æ•ˆï¼Œé‡æ–°æå–')
                                 descriptor = null
                             }
                         }
                         
                         // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæè¿°ç¬¦ï¼Œå°è¯•é‡æ–°æå–
                         if (!descriptor) {
                             console.log('ğŸ”„ å¼€å§‹é‡æ–°æå–æè¿°ç¬¦...')
                             
                             // æ£€æŸ¥ Face Recognition æ¨¡å‹æ˜¯å¦å·²åŠ è½½
                             if (!this.modelsLoaded) {
                                 console.error('âŒ æ¨¡å‹æœªåŠ è½½ï¼Œæ— æ³•æå–æè¿°ç¬¦')
                                 this.$message.error('äººè„¸è¯†åˆ«æ¨¡å‹æœªåŠ è½½å®Œæˆï¼Œè¯·ç­‰å¾…æ¨¡å‹åŠ è½½åå†è¯•')
                             } else {
                                 console.log('âœ… æ¨¡å‹å·²åŠ è½½ï¼Œå¼€å§‹é‡æ–°æå–æè¿°ç¬¦')
                                 
                                 // ä¼˜åŒ–çš„å‚æ•°ç»„åˆï¼ŒæŒ‰æˆåŠŸç‡æ’åº
                                 const detectionOptions = [
                                     new faceapi.TinyFaceDetectorOptions({ inputSize: 416, scoreThreshold: 0.4 }),
                                     new faceapi.TinyFaceDetectorOptions({ inputSize: 512, scoreThreshold: 0.3 }),
                                     new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.5 }),
                                     new faceapi.TinyFaceDetectorOptions({ inputSize: 608, scoreThreshold: 0.2 })
                                 ]
                                 
                                 for (let i = 0; i < detectionOptions.length && !descriptor; i++) {
                                     try {
                                         console.log(`ğŸ” å°è¯•å‚æ•°ç»„åˆ ${i + 1}/${detectionOptions.length}:`, {
                                             inputSize: detectionOptions[i].inputSize,
                                             scoreThreshold: detectionOptions[i].scoreThreshold
                                         })
                                         
                                         const faceDetection = await faceapi
                                             .detectSingleFace(tempCanvas, detectionOptions[i])
                                             .withFaceLandmarks()
                                             .withFaceDescriptor()
                                         
                                         if (faceDetection && faceDetection.descriptor) {
                                             const extractedDescriptor = Array.from(faceDetection.descriptor)
                                             
                                             // å®½æ¾éªŒè¯æå–çš„æè¿°ç¬¦ï¼ˆä¸Vue3ä¿æŒä¸€è‡´ï¼‰
                                             if (extractedDescriptor.length === 128) {
                                                 const hasValidNumbers = extractedDescriptor.some(val => 
                                                     typeof val === 'number' && !isNaN(val) && isFinite(val)
                                                 )
                                                 
                                                 if (hasValidNumbers) {
                                                     descriptor = extractedDescriptor
                                                     console.log(`âœ… å‚æ•°ç»„åˆ ${i + 1} æˆåŠŸæå–128ç»´æè¿°ç¬¦`)
                                                     console.log(`ğŸ“Š æè¿°ç¬¦ç»Ÿè®¡: æœ€å°å€¼=${Math.min(...descriptor).toFixed(4)}, æœ€å¤§å€¼=${Math.max(...descriptor).toFixed(4)}`)
                                                     break
                                                 } else {
                                                     console.warn(`âš ï¸ å‚æ•°ç»„åˆ ${i + 1} æå–çš„æè¿°ç¬¦æ•°å€¼å¼‚å¸¸ï¼Œä½†ç»§ç»­å°è¯•`)
                                                     descriptor = extractedDescriptor
                                                     console.log(`âœ… å‚æ•°ç»„åˆ ${i + 1} å¼ºåˆ¶ä½¿ç”¨128ç»´æè¿°ç¬¦`)
                                                     break
                                                 }
                                             } else {
                                                 console.warn(`âš ï¸ å‚æ•°ç»„åˆ ${i + 1} æå–çš„æè¿°ç¬¦ç»´åº¦é”™è¯¯ï¼š${extractedDescriptor.length}`)
                                             }
                                         } else {
                                             console.warn(`âš ï¸ å‚æ•°ç»„åˆ ${i + 1} æœªæ£€æµ‹åˆ°äººè„¸æˆ–æ— æ³•æå–æè¿°ç¬¦`)
                                         }
                                     } catch (error) {
                                         console.error(`âŒ å‚æ•°ç»„åˆ ${i + 1} å‡ºé”™:`, error.message)
                                     }
                                 }
                                 
                                 if (!descriptor) {
                                     console.error('âŒ æ‰€æœ‰å‚æ•°ç»„åˆéƒ½æ— æ³•æå–æœ‰æ•ˆçš„128ç»´æè¿°ç¬¦')
                                     console.log('ğŸ’¡ å»ºè®®ï¼š')
                                     console.log('  1. ç¡®ä¿äººè„¸æ¸…æ™°ã€å…‰çº¿å……è¶³')
                                     console.log('  2. ä¿æŒäººè„¸æ­£é¢æœå‘æ‘„åƒå¤´')
                                     console.log('  3. é¿å…é®æŒ¡ï¼ˆçœ¼é•œã€å¸½å­ã€å£ç½©ç­‰ï¼‰')
                                     console.log('  4. ç¡®ä¿æ‘„åƒå¤´åˆ†è¾¨ç‡è¶³å¤Ÿ')
                                     this.$message.warning('æ— æ³•æå–äººè„¸ç‰¹å¾ï¼Œè¯¥äººè„¸å°†ä»…ä½œä¸ºå›¾ç‰‡å­˜å‚¨ï¼Œæ— æ³•ç”¨äºè¯†åˆ«')
                                 }
                             }
                         }
                        
                        this.currentCapturedFace = {
                            detection: bestFace.detection,
                            descriptor: descriptor,
                            image: tempCanvas.toDataURL('image/jpeg', 0.9)
                        }
                        
                        console.log('äººè„¸æ•è·æˆåŠŸ:', {
                            hasImage: !!this.currentCapturedFace.image,
                            hasDescriptor: !!this.currentCapturedFace.descriptor,
                            descriptorLength: descriptor ? descriptor.length : 'N/A',
                            imageSize: this.currentCapturedFace.image.length
                        })
                        
                        this.newFaceName = ''
                        this.newFaceNote = ''
                        this.showAddDialog = true
                        
                        console.log('å¯¹è¯æ¡†å·²æ˜¾ç¤º:', {
                            showAddDialog: this.showAddDialog,
                            faceDB: !!this.faceDB
                        })
                        
                        // ç­‰å¾…å¯¹è¯æ¡†æ¸²æŸ“å®Œæˆåï¼Œå°†å›¾åƒç»˜åˆ¶åˆ°å¯¹è¯æ¡†ä¸­çš„canvas
                        this.$nextTick(() => {
                            this.drawCapturedFaceToDialog()
                        })
                        
                    } catch (error) {
                        console.error('å›¾åƒæ•è·å¤±è´¥:', error)
                        this.$message.error('å›¾åƒæ•è·å¤±è´¥: ' + error.message)
                    }
                },
                
                // å°†æ•è·çš„äººè„¸å›¾åƒç»˜åˆ¶åˆ°å¯¹è¯æ¡†ä¸­çš„canvas
                drawCapturedFaceToDialog() {
                    if (!this.currentCapturedFace || !this.currentCapturedFace.image) {
                        console.warn('æ²¡æœ‰æ•è·çš„äººè„¸å›¾åƒ')
                        return
                    }
                    
                    const canvas = this.$refs.captureCanvas
                    if (!canvas) {
                        console.warn('å¯¹è¯æ¡†canvaså…ƒç´ æœªæ‰¾åˆ°ï¼Œå¯èƒ½å¯¹è¯æ¡†è¿˜æœªå®Œå…¨æ¸²æŸ“')
                        // é‡è¯•ä¸€æ¬¡
                        setTimeout(() => {
                            this.drawCapturedFaceToDialog()
                        }, 100)
                        return
                    }
                    
                    const ctx = canvas.getContext('2d')
                    if (!ctx) {
                        console.error('æ— æ³•è·å–å¯¹è¯æ¡†canvasä¸Šä¸‹æ–‡')
                        return
                    }
                    
                    const img = new Image()
                    img.onload = () => {
                        ctx.clearRect(0, 0, 300, 300)
                        ctx.drawImage(img, 0, 0, 300, 300)
                        console.log('äººè„¸å›¾åƒå·²ç»˜åˆ¶åˆ°å¯¹è¯æ¡†')
                    }
                    img.onerror = (error) => {
                        console.error('å›¾åƒåŠ è½½å¤±è´¥:', error)
                    }
                    img.src = this.currentCapturedFace.image
                },
                
                async confirmAddFace() {
                    console.log('å¼€å§‹ç¡®è®¤æ·»åŠ äººè„¸:', {
                        hasCapturedFace: !!this.currentCapturedFace,
                        faceName: this.newFaceName,
                        faceNote: this.newFaceNote,
                        faceDB: !!this.faceDB
                    })
                    
                    if (!this.currentCapturedFace || !this.newFaceName.trim()) {
                        this.$message.warning('è¯·è¾“å…¥å§“å')
                        return
                    }
                    
                    if (!this.faceDB) {
                        console.error('âŒ æ•°æ®åº“æœªåˆå§‹åŒ–')
                        this.$message.error('æ•°æ®åº“æœªåˆå§‹åŒ–ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•')
                        return
                    }
                    
                    const newFace = {
                        id: Date.now().toString(),
                        name: this.newFaceName.trim(),
                        note: this.newFaceNote.trim(),
                        image: this.currentCapturedFace.image,
                        descriptor: this.currentCapturedFace.descriptor ? Array.from(this.currentCapturedFace.descriptor) : null,
                        timestamp: new Date().toISOString(),
                        source: 'camera'  // æ ‡è®°æ•°æ®æ¥æº
                    }
                    
                    console.log('ğŸ“‹ å‡†å¤‡æ·»åŠ çš„äººè„¸æ•°æ®:', {
                        id: newFace.id,
                        name: newFace.name,
                        hasImage: !!newFace.image,
                        hasDescriptor: !!newFace.descriptor,
                        descriptorLength: newFace.descriptor ? newFace.descriptor.length : 0,
                        imageSize: newFace.image ? newFace.image.length : 0
                    })
                    
                    try {
                        console.log('ğŸ—„ï¸ å¼€å§‹ä¿å­˜åˆ°IndexedDB...')
                        
                        // ä¿å­˜åˆ°IndexedDB
                        const savedFace = await this.faceDB.addFace(newFace)
                        console.log('âœ… ä¿å­˜åˆ°æ•°æ®åº“æˆåŠŸ:', savedFace.id)
                        
                        // æ›´æ–°æœ¬åœ°æ•°ç»„
                        this.faceLibrary.push(newFace)
                        console.log('ğŸ“š æ›´æ–°æœ¬åœ°äººè„¸åº“ï¼Œå½“å‰æ•°é‡:', this.faceLibrary.length)
                        
                        this.showAddDialog = false
                        this.currentCapturedFace = null
                        
                        if (newFace.descriptor && newFace.descriptor.length === 128) {
                            this.$message.success(`å·²æ·»åŠ  "${newFace.name}" åˆ°äººè„¸åº“ï¼ˆæ”¯æŒè¯†åˆ«ï¼‰`)
                            console.log('ğŸ¯ æ·»åŠ æˆåŠŸ - æ”¯æŒè¯†åˆ«')
                        } else {
                            this.$message.warning(`å·²æ·»åŠ  "${newFace.name}" åˆ°äººè„¸åº“ï¼ˆä»…å­˜å‚¨ï¼Œæ— æ³•è¯†åˆ«ï¼‰\nè¯·ç¡®ä¿æ‘„åƒå¤´æ¸…æ™°å¹¶é‡æ–°å°è¯•`)
                            console.log('ğŸ“¸ æ·»åŠ æˆåŠŸ - ä»…å­˜å‚¨')
                        }
                        
                        // éªŒè¯ä¿å­˜ç»“æœ
                        setTimeout(async () => {
                            try {
                                const allFaces = await this.faceDB.getAllFaces()
                                console.log('ğŸ” éªŒè¯ï¼šæ•°æ®åº“ä¸­çš„äººè„¸æ€»æ•°:', allFaces.length)
                            } catch (verifyError) {
                                console.error('âŒ éªŒè¯å¤±è´¥:', verifyError)
                            }
                        }, 500)
                        
                    } catch (error) {
                        console.error('âŒ ä¿å­˜äººè„¸å¤±è´¥:', error)
                        console.error('âŒ é”™è¯¯è¯¦æƒ…:', {
                            message: error.message,
                            stack: error.stack,
                            faceDB: !!this.faceDB
                        })
                        this.$message.error('ä¿å­˜åˆ°æ•°æ®åº“å¤±è´¥: ' + error.message)
                    }
                },
                
                // æ–‡ä»¶å¤„ç†
                handleFileSelect(event) {
                    const files = Array.from(event.target.files)
                    this.processImageFiles(files)
                },
                
                handleDrop(event) {
                    this.isDragging = false
                    const files = Array.from(event.dataTransfer.files)
                    this.processImageFiles(files.filter(file => file.type.startsWith('image/')))
                },
                
                handleDragOver() {
                    this.isDragging = true
                },
                
                handleDragLeave() {
                    this.isDragging = false
                },
                
                async processImageFiles(files) {
                    if (files.length === 0) return
                    
                    if (!this.modelsLoaded) {
                        this.$message.warning('æ¨¡å‹å°šæœªåŠ è½½å®Œæˆï¼Œè¯·ç¨åå†è¯•')
                        return
                    }
                    
                    const loading = this.$message({
                        message: 'æ­£åœ¨å¤„ç†å›¾ç‰‡...',
                        type: 'info',
                        duration: 0
                    })
                    
                    let successCount = 0
                    let errorMessages = []
                    
                    try {
                        for (const file of files) {
                            try {
                                await this.processImageFile(file)
                                successCount++
                            } catch (error) {
                                errorMessages.push(`${file.name}: ${error.message}`)
                            }
                        }
                        
                        loading.close()
                        
                        if (successCount > 0) {
                            this.$message.success(`æˆåŠŸå¤„ç† ${successCount} å¼ å›¾ç‰‡`)
                        }
                        
                        if (errorMessages.length > 0) {
                            this.$message.warning(`éƒ¨åˆ†å›¾ç‰‡å¤„ç†å¤±è´¥:\n${errorMessages.slice(0, 3).join('\n')}${errorMessages.length > 3 ? '\n...' : ''}`)
                        }
                    } catch (error) {
                        loading.close()
                        this.$message.error('å›¾ç‰‡å¤„ç†å¤±è´¥: ' + error.message)
                    }
                },
                
                processImageFile(file) {
                    return new Promise((resolve, reject) => {
                        const img = new Image()
                        const canvas = document.createElement('canvas')
                        const ctx = canvas.getContext('2d')
                        
                        img.onload = async () => {
                            // è°ƒæ•´å›¾ç‰‡å°ºå¯¸
                            const maxSize = 640
                            let { width, height } = img
                            
                            if (width > maxSize || height > maxSize) {
                                const ratio = Math.min(maxSize / width, maxSize / height)
                                width *= ratio
                                height *= ratio
                            }
                            
                            canvas.width = width
                            canvas.height = height
                            ctx.drawImage(img, 0, 0, width, height)
                            
                            try {
                                // å¤šç§æ£€æµ‹ç­–ç•¥ï¼Œä»å®½æ¾åˆ°ä¸¥æ ¼
                                const detectionOptions = [
                                    new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.3 }),
                                    new faceapi.TinyFaceDetectorOptions({ inputSize: 416, scoreThreshold: 0.4 }),
                                    new faceapi.TinyFaceDetectorOptions({ inputSize: 512, scoreThreshold: 0.5 }),
                                    new faceapi.TinyFaceDetectorOptions({ inputSize: 608, scoreThreshold: 0.6 })
                                ]
                                
                                let detection = null
                                
                                // å°è¯•ä¸åŒçš„æ£€æµ‹å‚æ•°
                                for (let i = 0; i < detectionOptions.length && !detection; i++) {
                                    try {
                                        console.log(`ğŸ” å°è¯•æ£€æµ‹å‚æ•° ${i + 1}/${detectionOptions.length}:`, {
                                            inputSize: detectionOptions[i].inputSize,
                                            scoreThreshold: detectionOptions[i].scoreThreshold,
                                            fileName: file.name
                                        })
                                        
                                        detection = await faceapi
                                            .detectSingleFace(canvas, detectionOptions[i])
                                            .withFaceLandmarks()
                                            .withFaceDescriptor()
                                        
                                        if (detection) {
                                            console.log(`âœ… å‚æ•°ç»„åˆ ${i + 1} æˆåŠŸæ£€æµ‹åˆ°äººè„¸:`, {
                                                score: detection.detection.score,
                                                box: detection.detection.box
                                            })
                                            break
                                        } else {
                                            console.log(`âš ï¸ å‚æ•°ç»„åˆ ${i + 1} æœªæ£€æµ‹åˆ°äººè„¸`)
                                        }
                                    } catch (error) {
                                        console.warn(`âŒ å‚æ•°ç»„åˆ ${i + 1} æ£€æµ‹å¤±è´¥:`, error.message)
                                    }
                                }
                                
                                if (detection) {
                                    // æå–äººè„¸åŒºåŸŸï¼ˆæ·»åŠ paddingï¼‰
                                    const { x, y, width: faceWidth, height: faceHeight } = detection.detection.box
                                    const faceCanvas = document.createElement('canvas')
                                    const faceCtx = faceCanvas.getContext('2d')
                                    
                                    faceCanvas.width = 300  // å¢å¤§è¾“å‡ºå°ºå¯¸
                                    faceCanvas.height = 300
                                    
                                    // æ·»åŠ paddingï¼Œæ‰©å±•äººè„¸åŒºåŸŸ
                                    const padding = Math.max(faceWidth, faceHeight) * 0.4  // 40%çš„padding
                                    const expandedX = Math.max(0, x - padding)
                                    const expandedY = Math.max(0, y - padding)
                                    const expandedWidth = Math.min(canvas.width - expandedX, faceWidth + padding * 2)
                                    const expandedHeight = Math.min(canvas.height - expandedY, faceHeight + padding * 2)
                                    
                                    console.log(`ğŸ“ äººè„¸åŒºåŸŸæ‰©å±• ${file.name}:`, {
                                        original: { x, y, width: faceWidth, height: faceHeight },
                                        expanded: { x: expandedX, y: expandedY, width: expandedWidth, height: expandedHeight },
                                        padding: padding
                                    })
                                    
                                    const scale = Math.min(300 / expandedWidth, 300 / expandedHeight)
                                    const scaledWidth = expandedWidth * scale
                                    const scaledHeight = expandedHeight * scale
                                    
                                    faceCtx.clearRect(0, 0, 300, 300)
                                    faceCtx.drawImage(
                                        canvas,
                                        expandedX, expandedY, expandedWidth, expandedHeight,
                                        (300 - scaledWidth) / 2, (300 - scaledHeight) / 2, scaledWidth, scaledHeight
                                    )
                                    
                                    const fileName = file.name.replace(/\.[^/.]+$/, "")
                                    const newFace = {
                                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                                        name: fileName,
                                        note: '',
                                        image: faceCanvas.toDataURL('image/jpeg', 0.9),
                                        descriptor: detection.descriptor ? Array.from(detection.descriptor) : null,
                                        timestamp: new Date().toISOString(),
                                        source: 'upload'  // æ ‡è®°æ•°æ®æ¥æº
                                    }
                                    
                                    // ä¿å­˜åˆ°IndexedDB
                                    await this.faceDB.addFace(newFace)
                                    this.faceLibrary.push(newFace)
                                    resolve()
                                } else {
                                    reject(new Error(`æœªåœ¨å›¾ç‰‡ ${file.name} ä¸­æ£€æµ‹åˆ°äººè„¸ã€‚å»ºè®®ï¼šç¡®ä¿å›¾ç‰‡æ¸…æ™°ã€äººè„¸æ­£é¢ä¸”å æ¯”è¾ƒå¤§`))
                                }
                            } catch (error) {
                                reject(error)
                            }
                        }
                        
                        img.onerror = () => reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'))
                        img.src = URL.createObjectURL(file)
                    })
                },
                
                // å…¶ä»–åŠŸèƒ½
                toggleComparison() {
                    this.comparisonMode = !this.comparisonMode
                    
                    if (this.comparisonMode && this.faceLibrary.length === 0) {
                        this.$message.warning('äººè„¸åº“ä¸ºç©ºï¼Œè¯·å…ˆæ·»åŠ äººè„¸æ•°æ®')
                        this.comparisonMode = false
                        return
                    }
                    
                    this.$message.info(this.comparisonMode ? 'äººè„¸è¯†åˆ«å·²å¼€å¯' : 'äººè„¸è¯†åˆ«å·²å…³é—­')
                },
                
                async removeFace(index) {
                    try {
                        const face = this.faceLibrary[index]
                        await this.$confirm(
                            `ç¡®å®šè¦åˆ é™¤ "${face.name}" å—ï¼Ÿ`,
                            'ç¡®è®¤åˆ é™¤',
                            { type: 'warning' }
                        )
                        
                        // ä»IndexedDBåˆ é™¤
                        await this.faceDB.deleteFace(face.id)
                        
                        // ä»æœ¬åœ°æ•°ç»„åˆ é™¤
                        this.faceLibrary.splice(index, 1)
                        this.$message.success('åˆ é™¤æˆåŠŸ')
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('åˆ é™¤äººè„¸å¤±è´¥:', error)
                            this.$message.error('åˆ é™¤å¤±è´¥: ' + error.message)
                        }
                    }
                },
                
                async clearLibrary() {
                    try {
                        await this.$confirm(
                            'ç¡®å®šè¦æ¸…ç©ºæ•´ä¸ªäººè„¸åº“å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼',
                            'ç¡®è®¤æ¸…ç©º',
                            { type: 'warning' }
                        )
                        
                        // æ¸…ç©ºIndexedDB
                        await this.faceDB.clearAllFaces()
                        
                        // æ¸…ç©ºæœ¬åœ°æ•°ç»„
                        this.faceLibrary = []
                        this.matchedFaces = []
                        this.$message.success('äººè„¸åº“å·²æ¸…ç©º')
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('æ¸…ç©ºäººè„¸åº“å¤±è´¥:', error)
                            this.$message.error('æ¸…ç©ºå¤±è´¥: ' + error.message)
                        }
                    }
                },
                
                async exportLibrary() {
                    try {
                        // ä»IndexedDBå¯¼å‡ºå®Œæ•´æ•°æ®
                        const data = await this.faceDB.exportData()
                        
                        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
                        const url = URL.createObjectURL(blob)
                        const link = document.createElement('a')
                        link.href = url
                        link.download = `face-library-vue2-${new Date().toISOString().split('T')[0]}.json`
                        document.body.appendChild(link)
                        link.click()
                        document.body.removeChild(link)
                        URL.revokeObjectURL(url)
                        
                        this.$message.success(`äººè„¸åº“æ•°æ®å·²å¯¼å‡º (${data.totalFaces} ä¸ªäººè„¸)`)
                    } catch (error) {
                        console.error('å¯¼å‡ºå¤±è´¥:', error)
                        this.$message.error('å¯¼å‡ºå¤±è´¥: ' + error.message)
                    }
                },
                
                // å¯¼å‡ºå›¾ç‰‡
                async exportImages() {
                    try {
                        if (this.faceLibrary.length === 0) {
                            this.$message.warning('äººè„¸åº“ä¸ºç©ºï¼Œæ— æ³•å¯¼å‡ºå›¾ç‰‡')
                            return
                        }
                        
                        const loading = this.$message({
                            message: 'æ­£åœ¨å¯¼å‡ºå›¾ç‰‡...',
                            type: 'info',
                            duration: 0
                        })
                        
                        // ç®€åŒ–ç‰ˆï¼šé€ä¸ªä¸‹è½½å›¾ç‰‡
                        for (let i = 0; i < this.faceLibrary.length; i++) {
                            const face = this.faceLibrary[i]
                            if (face.image) {
                                const safeName = face.name.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_')
                                const fileName = safeName + '_' + face.id + '.jpg'
                                
                                setTimeout(() => {
                                    this.downloadBlob(this.dataURLToBlob(face.image), fileName)
                                }, i * 200) // å»¶è¿Ÿä¸‹è½½é¿å…æµè§ˆå™¨é˜»æ­¢
                            }
                        }
                        
                        // ä¸‹è½½ä¿¡æ¯æ–‡ä»¶
                        setTimeout(() => {
                            const infoText = this.createInfoFile()
                            const infoBlob = new Blob([infoText], { type: 'text/plain;charset=utf-8' })
                            const timestamp = new Date().toISOString().split('T')[0]
                            this.downloadBlob(infoBlob, 'äººè„¸åº“ä¿¡æ¯_' + timestamp + '.txt')
                        }, this.faceLibrary.length * 200 + 500)
                        
                        loading.close()
                        this.$message.success('å·²å¼€å§‹å¯¼å‡º ' + this.faceLibrary.length + ' å¼ äººè„¸å›¾ç‰‡ï¼Œè¯·ç­‰å¾…æµè§ˆå™¨ä¸‹è½½å®Œæˆ')
                        
                    } catch (error) {
                        console.error('å¯¼å‡ºå›¾ç‰‡å¤±è´¥:', error)
                        this.$message.error('å¯¼å‡ºå›¾ç‰‡å¤±è´¥: ' + error.message)
                    }
                },
                
                // åˆ›å»ºä¿¡æ¯æ–‡ä»¶
                createInfoFile() {
                    let info = `äººè„¸åº“å¯¼å‡ºä¿¡æ¯\n`
                    info += `å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}\n`
                    info += `æ€»äººè„¸æ•°: ${this.faceLibrary.length}\n`
                    info += `å¯è¯†åˆ«æ•°: ${this.faceLibrary.filter(f => f.descriptor).length}\n`
                    info += `ä»…å­˜å‚¨æ•°: ${this.faceLibrary.filter(f => !f.descriptor).length}\n\n`
                    
                    info += `è¯¦ç»†ä¿¡æ¯:\n`
                    info += `${'='.repeat(50)}\n`
                    
                    this.faceLibrary.forEach((face, index) => {
                        info += `${index + 1}. ${face.name}\n`
                        info += `   ID: ${face.id}\n`
                        info += `   å¤‡æ³¨: ${face.note || 'æ— '}\n`
                        info += `   æ·»åŠ æ—¶é—´: ${new Date(face.timestamp).toLocaleString()}\n`
                        info += `   å¯è¯†åˆ«: ${face.descriptor ? 'æ˜¯' : 'å¦'}\n`
                        if (face.descriptor) {
                            info += `   æè¿°ç¬¦é•¿åº¦: ${face.descriptor.length}\n`
                        }
                        info += `\n`
                    })
                    
                    return info
                },
                
                // æ•°æ®URLè½¬Blob
                dataURLToBlob(dataURL) {
                    const parts = dataURL.split(',')
                    const mime = parts[0].match(/:(.*?);/)[1]
                    const binary = atob(parts[1])
                    const array = new Uint8Array(binary.length)
                    for (let i = 0; i < binary.length; i++) {
                        array[i] = binary.charCodeAt(i)
                    }
                    return new Blob([array], { type: mime })
                },
                
                // ä¸‹è½½Blobæ–‡ä»¶
                downloadBlob(blob, filename) {
                    const url = URL.createObjectURL(blob)
                    const link = document.createElement('a')
                    link.href = url
                    link.download = filename
                    document.body.appendChild(link)
                    link.click()
                    document.body.removeChild(link)
                    URL.revokeObjectURL(url)
                },
                
                // è®¡ç®—å±æ€§è¾…åŠ©æ–¹æ³•
                isMatched(faceId) {
                    return this.matchedFaces.some(match => match.faceId === faceId)
                },
                
                getMatchConfidence(faceId) {
                    const match = this.matchedFaces.find(m => m.faceId === faceId)
                    return match ? Math.round(match.confidence * 100) : 0
                },
                
                // æ•°æ®æŒä¹…åŒ–
                async loadFaceLibrary() {
                    try {
                        console.log('ğŸ“š å¼€å§‹ä»æ•°æ®åº“åŠ è½½äººè„¸åº“...')
                        
                        if (!this.faceDB) {
                            console.error('âŒ æ•°æ®åº“æœªåˆå§‹åŒ–ï¼Œæ— æ³•åŠ è½½äººè„¸åº“')
                            this.faceLibrary = []
                            return
                        }
                        
                        // ä»IndexedDBåŠ è½½äººè„¸åº“
                        this.faceLibrary = await this.faceDB.getAllFaces()
                        console.log('âœ… äººè„¸åº“åŠ è½½å®Œæˆï¼Œæ•°é‡:', this.faceLibrary.length)
                        
                        // æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
                        const stats = await this.faceDB.getStats()
                        console.log('ğŸ“Š äººè„¸åº“ç»Ÿè®¡:', stats)
                        
                        if (this.faceLibrary.length > 0) {
                            this.$message.success(`å·²åŠ è½½ ${stats.totalFaces} ä¸ªäººè„¸ (${stats.facesWithDescriptors} ä¸ªå¯è¯†åˆ«)`)
                        } else {
                            console.log('ğŸ“ äººè„¸åº“ä¸ºç©ºï¼Œè¿™æ˜¯é¦–æ¬¡ä½¿ç”¨')
                        }
                    } catch (error) {
                        console.error('âŒ åŠ è½½äººè„¸åº“å¤±è´¥:', error)
                        this.$message.error('åŠ è½½äººè„¸åº“å¤±è´¥: ' + error.message)
                        this.faceLibrary = []
                    }
                },
                
                // æ·»åŠ å¯¼å…¥åŠŸèƒ½
                async importLibrary() {
                    const input = document.createElement('input')
                    input.type = 'file'
                    input.accept = '.json'
                    
                    input.onchange = async (event) => {
                        const file = event.target.files[0]
                        if (!file) return
                        
                        const loading = this.$message({
                            message: 'æ­£åœ¨å¯¼å…¥äººè„¸åº“...',
                            type: 'info',
                            duration: 0
                        })
                        
                        try {
                            const text = await file.text()
                            const data = JSON.parse(text)
                            
                            const results = await this.faceDB.importData(data)
                            
                            // é‡æ–°åŠ è½½äººè„¸åº“
                            await this.loadFaceLibrary()
                            
                            loading.close()
                            
                            if (results.success > 0) {
                                this.$message.success(`å¯¼å…¥æˆåŠŸ: ${results.success} ä¸ªäººè„¸`)
                            }
                            
                            if (results.failed > 0) {
                                this.$message.warning(`å¯¼å…¥å¤±è´¥: ${results.failed} ä¸ªäººè„¸`)
                            }
                        } catch (error) {
                            loading.close()
                            console.error('å¯¼å…¥å¤±è´¥:', error)
                            this.$message.error('å¯¼å…¥å¤±è´¥: ' + error.message)
                        }
                    }
                    
                    input.click()
                },
                
                // æ˜¾ç¤ºæ•°æ®åº“ç»Ÿè®¡
                async showDatabaseStats() {
                    try {
                        const stats = await this.faceDB.getStats()
                        
                        let message = `ğŸ“Š æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯\n\n`
                        message += `æ€»äººè„¸æ•°: ${stats.totalFaces}\n`
                        message += `å¯è¯†åˆ«äººè„¸: ${stats.facesWithDescriptors}\n`
                        message += `ä»…å­˜å‚¨äººè„¸: ${stats.facesWithoutDescriptors}\n\n`
                        
                        if (stats.databaseSize.estimated) {
                            message += `å­˜å‚¨ç©ºé—´ä½¿ç”¨: ${stats.databaseSize.usageInMB} MB\n`
                            message += `å¯ç”¨ç©ºé—´: ${stats.databaseSize.quotaInMB} MB\n\n`
                        }
                        
                        if (stats.totalFaces > 0) {
                            message += `æœ€æ—©æ·»åŠ : ${new Date(stats.oldestFace).toLocaleDateString()}\n`
                            message += `æœ€æ–°æ·»åŠ : ${new Date(stats.newestFace).toLocaleDateString()}`
                        }
                        
                        this.$alert(message, 'æ•°æ®åº“ç»Ÿè®¡', {
                            type: 'info',
                            dangerouslyUseHTMLString: false
                        })
                    } catch (error) {
                        console.error('è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥:', error)
                        this.$message.error('è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥')
                    }
                },
                
                // æ˜¾ç¤ºå­˜å‚¨ä½¿ç”¨æƒ…å†µ
                async showStorageUsage() {
                    try {
                        const usage = await this.faceDB.getStorageUsage()
                        
                        let message = `ğŸ’¾ æµè§ˆå™¨å­˜å‚¨ä½¿ç”¨æƒ…å†µ\n\n`
                        
                        if (usage.total > 0) {
                            message += `æ€»ä½¿ç”¨é‡: ${this.faceDB.formatBytes(usage.total)}\n`
                            message += `æ€»é…é¢: ${this.faceDB.formatBytes(usage.quota)}\n`
                            message += `ä½¿ç”¨ç‡: ${usage.percentage.toFixed(1)}%\n\n`
                        }
                        
                        message += `ğŸ“š IndexedDB: ${this.faceDB.formatBytes(usage.indexedDB.size)}\n`
                        message += `ğŸ—‚ï¸ LocalStorage: ${this.faceDB.formatBytes(usage.localStorage.size)}\n`
                        message += `ğŸ“‹ SessionStorage: ${this.faceDB.formatBytes(usage.sessionStorage.size)}\n\n`
                        
                        message += `ğŸ’¡ æç¤ºï¼š\n`
                        message += `â€¢ IndexedDB å­˜å‚¨äººè„¸æ•°æ®å’Œå›¾ç‰‡\n`
                        message += `â€¢ LocalStorage å­˜å‚¨åº”ç”¨è®¾ç½®\n`
                        message += `â€¢ SessionStorage å­˜å‚¨ä¸´æ—¶æ•°æ®`
                        
                        this.$alert(message, 'å­˜å‚¨ä½¿ç”¨æƒ…å†µ', {
                            type: 'info',
                            dangerouslyUseHTMLString: false
                        })
                    } catch (error) {
                        console.error('è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µå¤±è´¥:', error)
                        this.$message.error('è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µå¤±è´¥')
                    }
                },
                
                // æ¸…é™¤æ‰€æœ‰ç¼“å­˜
                async clearAllCache() {
                    try {
                        const result = await this.$confirm(
                            'âš ï¸ è­¦å‘Šï¼šæ­¤æ“ä½œå°†å½»åº•æ¸…é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®ï¼\n\n' +
                            'å°†ä¼šåˆ é™¤ä»¥ä¸‹å†…å®¹ï¼š\n' +
                            'â€¢ æ‰€æœ‰äººè„¸åº“æ•°æ® (IndexedDB)\n' +
                            'â€¢ åº”ç”¨è®¾ç½®å’Œç¼“å­˜ (LocalStorage)\n' +
                            'â€¢ ä¸´æ—¶æ•°æ® (SessionStorage)\n' +
                            'â€¢ ç½‘é¡µç¼“å­˜ (Cache API)\n' +
                            'â€¢ Service Worker\n' +
                            'â€¢ ç›¸å…³ Cookies\n\n' +
                            'æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
                            'æ¸…é™¤æ‰€æœ‰ç¼“å­˜',
                            {
                                confirmButtonText: 'ç¡®å®šæ¸…é™¤',
                                cancelButtonText: 'å–æ¶ˆ',
                                type: 'warning',
                                dangerouslyUseHTMLString: false
                            }
                        )
                        
                        // äºŒæ¬¡ç¡®è®¤
                        await this.$confirm(
                            'ğŸ”¥ æœ€åç¡®è®¤ï¼šæ‚¨çœŸçš„è¦åˆ é™¤æ‰€æœ‰æ•°æ®å—ï¼Ÿ\n\n' +
                            'è¿™åŒ…æ‹¬æ‚¨è¾›è‹¦å»ºç«‹çš„äººè„¸åº“ï¼\n' +
                            'è¯·ç¡®ä¿æ‚¨å·²ç»å¯¼å‡ºäº†é‡è¦æ•°æ®çš„å¤‡ä»½ã€‚',
                            'æœ€åç¡®è®¤',
                            {
                                confirmButtonText: 'æ˜¯çš„ï¼Œå…¨éƒ¨åˆ é™¤',
                                cancelButtonText: 'ç­‰ç­‰ï¼Œæˆ‘å†æƒ³æƒ³',
                                type: 'error',
                                dangerouslyUseHTMLString: false
                            }
                        )
                        
                        const loading = this.$loading({
                            lock: true,
                            text: 'æ­£åœ¨æ¸…é™¤æ‰€æœ‰ç¼“å­˜...',
                            spinner: 'el-icon-loading'
                        })
                        
                        try {
                            // æ‰§è¡Œæ¸…é™¤æ“ä½œ
                            const results = await this.faceDB.clearAllCache()
                            
                            loading.close()
                            
                            // é‡ç½®æœ¬åœ°çŠ¶æ€
                            this.faceLibrary = []
                            this.matchedFaces = []
                            this.faceMatcher = null
                            
                            // ç”Ÿæˆæ¸…é™¤ç»“æœæŠ¥å‘Š
                            let report = 'ğŸ§¹ ç¼“å­˜æ¸…é™¤å®Œæˆï¼\n\n'
                            report += `âœ… IndexedDB: ${results.indexedDB ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            report += `âœ… LocalStorage: ${results.localStorage ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            report += `âœ… SessionStorage: ${results.sessionStorage ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            report += `âœ… Cache API: ${results.cacheAPI ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            report += `âœ… Service Worker: ${results.serviceWorker ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            report += `âœ… Cookies: ${results.cookies ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            
                            if (results.errors.length > 0) {
                                report += `\nâš ï¸ éƒ¨åˆ†æ¸…é™¤å¤±è´¥ï¼š\n${results.errors.slice(0, 3).join('\n')}`
                            }
                            
                            report += '\n\nğŸ’¡ å»ºè®®åˆ·æ–°é¡µé¢ä»¥ç¡®ä¿å®Œå…¨ç”Ÿæ•ˆã€‚'
                            
                            await this.$alert(report, 'æ¸…é™¤ç»“æœ', {
                                type: results.errors.length === 0 ? 'success' : 'warning',
                                dangerouslyUseHTMLString: false
                            })
                            
                            // è¯¢é—®æ˜¯å¦åˆ·æ–°é¡µé¢
                            try {
                                await this.$confirm(
                                    'æ¸…é™¤å®Œæˆï¼æ˜¯å¦ç«‹å³åˆ·æ–°é¡µé¢ï¼Ÿ',
                                    'åˆ·æ–°é¡µé¢',
                                    { type: 'info' }
                                )
                                window.location.reload()
                            } catch {
                                // ç”¨æˆ·é€‰æ‹©ä¸åˆ·æ–°
                            }
                            
                        } catch (error) {
                            loading.close()
                            console.error('æ¸…é™¤ç¼“å­˜å¤±è´¥:', error)
                            this.$message.error('æ¸…é™¤ç¼“å­˜å¤±è´¥: ' + error.message)
                        }
                        
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('æ¸…é™¤æ“ä½œå¤±è´¥:', error)
                            this.$message.error('æ“ä½œå¤±è´¥')
                        }
                    }
                },
                
                updateFPS() {
                    this.fpsCounter++
                    const now = Date.now()
                    
                    if (now - this.lastFpsUpdate >= 1000) {
                        this.fps = this.fpsCounter
                        this.fpsCounter = 0
                        this.lastFpsUpdate = now
                    }
                },
                
                cleanup() {
                    if (this.stream) {
                        this.stream.getTracks().forEach(track => track.stop())
                        this.stream = null
                    }
                    
                    this.stopDetection()
                    
                    if (this.$refs.video) {
                        this.$refs.video.srcObject = null
                    }
                },
                
                // åœ¨é¡µé¢å¸è½½æ—¶å…³é—­æ•°æ®åº“è¿æ¥
                beforeDestroy() {
                    this.cleanup()
                    if (this.faceDB) {
                        this.faceDB.close()
                    }
                }
            }
        })
    </script>
</body>
</html>