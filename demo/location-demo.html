<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®šä½Demo</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Microsoft YaHei', sans-serif; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 20px; }
        .controls { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .btn { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; transition: all 0.3s; }
        .btn:hover { background: #0056b3; transform: translateY(-2px); }
        .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }
        .status { margin: 10px 0; padding: 10px; background: #f8f9fa; border-left: 4px solid #007bff; border-radius: 5px; }
        #map { height: 500px; width: 100%; border-radius: 8px; }
        .info-panel { background: white; padding: 20px; border-radius: 8px; margin-top: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .info-item { margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px; border-left: 3px solid #007bff; }
        .loading { display: inline-block; width: 20px; height: 20px; border: 3px solid #f3f3f3; border-top: 3px solid #007bff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .accuracy-bar { width: 100%; height: 8px; background: #e9ecef; border-radius: 4px; overflow: hidden; margin: 5px 0; }
        .accuracy-fill { height: 100%; background: linear-gradient(90deg, #dc3545, #ffc107, #28a745); transition: width 0.3s; }
        .custom-marker { cursor: grab; }
        .custom-marker:active { cursor: grabbing; }
        .leaflet-popup-content button { transition: all 0.2s; }
        .leaflet-popup-content button:hover { background: #0056b3 !important; transform: scale(1.05); }
        .control-row { display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0; align-items: center; }
        .setting-group { display: flex; align-items: center; gap: 8px; }
        .setting-group label { font-weight: bold; color: #333; min-width: 80px; }
        .setting-group select, .setting-group input { padding: 5px; border: 1px solid #ddd; border-radius: 3px; background: white; }
        .stats-row { display: flex; justify-content: space-between; background: #e9ecef; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 14px; }
        .stats-row span { color: #495057; }
        .location-history { max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px; padding: 10px; background: #f8f9fa; }
        .history-item { padding: 8px; margin: 5px 0; background: white; border-radius: 3px; border-left: 3px solid #007bff; cursor: pointer; transition: all 0.2s; }
        .history-item:hover { background: #e3f2fd; transform: translateX(5px); }
        .history-item.selected { background: #007bff; color: white; }
        .accuracy-indicator { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 5px; }
        .accuracy-high { background: #28a745; }
        .accuracy-medium { background: #ffc107; }
        .accuracy-low { background: #dc3545; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“ å®šä½Demo</h1>
            <p>æ”¯æŒIPå®šä½å’ŒGPSå®šä½ï¼ŒPCå’ŒH5é€šç”¨</p>
            <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; padding: 10px; margin: 10px 0; font-size: 14px;">
                <strong>ğŸ’¡ å®šä½ç²¾åº¦è¯´æ˜ï¼š</strong><br>
                â€¢ <strong>GPSå®šä½</strong>ï¼šæœ€å‡†ç¡®ï¼Œç²¾åº¦å¯è¾¾å‡ ç±³åˆ°å‡ åç±³<br>
                â€¢ <strong>IPå®šä½</strong>ï¼šç²¾åº¦è¾ƒä½ï¼Œå¯èƒ½æ˜¾ç¤ºè¿è¥å•†æœºæˆ¿ä½ç½®è€Œéå®é™…ä½ç½®<br>
                â€¢ <strong>WiFiå®šä½</strong>ï¼šåŸºäºå‘¨å›´WiFiç½‘ç»œä¿¡æ¯å®šä½ï¼Œç²¾åº¦çº¦20-100ç±³<br>
                â€¢ <strong>åŸºç«™å®šä½</strong>ï¼šåŸºäºç§»åŠ¨ç½‘ç»œåŸºç«™ä¿¡æ¯å®šä½ï¼Œç²¾åº¦çº¦300-1000ç±³<br>
                â€¢ <strong>æ‹–åŠ¨æ ‡è®°</strong>ï¼šå¯æ‹–åŠ¨åœ°å›¾ä¸Šçš„æ ‡è®°æ¥è°ƒæ•´ä½ç½®ï¼Œå³é”®ç‚¹å‡»åœ°å›¾å¯æ·»åŠ æ–°æ ‡è®°
            </div>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <button class="btn" onclick="getIPLocation()" id="ipBtn">ğŸŒ IPå®šä½</button>
                <button class="btn" onclick="getGPSLocation()" id="gpsBtn">ğŸ“± GPSå®šä½</button>
                <button class="btn" onclick="getWifiLocation()" id="wifiBtn">ğŸ“¶ WiFiå®šä½</button>
                <button class="btn" onclick="getCellLocation()" id="cellBtn">ğŸ“¡ åŸºç«™å®šä½</button>
            </div>
            <div class="control-row">
                <button class="btn" onclick="clearMap()">ğŸ—‘ï¸ æ¸…é™¤æ ‡è®°</button>
                <button class="btn" onclick="addManualMarker()">ğŸ“ æ‰‹åŠ¨æ·»åŠ æ ‡è®°</button>
                <button class="btn" onclick="compareLocations()">ğŸ” ä½ç½®å¯¹æ¯”</button>
                <button class="btn" onclick="exportLocation()">ğŸ’¾ å¯¼å‡ºæ•°æ®</button>
            </div>
            <div class="control-row">
                <div class="setting-group">
                    <label>ç²¾åº¦èŒƒå›´:</label>
                    <select id="accuracyRange" onchange="updateAccuracySettings()">
                        <option value="all">å…¨éƒ¨ç²¾åº¦</option>
                        <option value="high">é«˜ç²¾åº¦ (Â±50ç±³å†…)</option>
                        <option value="medium">ä¸­ç­‰ç²¾åº¦ (Â±200ç±³å†…)</option>
                        <option value="low">ä½ç²¾åº¦ (Â±1å…¬é‡Œå†…)</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label>å®šä½æ¬¡æ•°:</label>
                    <input type="number" id="maxAttempts" value="3" min="1" max="10" onchange="updateAttemptsSettings()">
                </div>
                <div class="setting-group">
                    <label>è‡ªåŠ¨é€‰æ‹©:</label>
                    <select id="autoSelect" onchange="updateAutoSelectSettings()">
                        <option value="best">æœ€ä½³ç²¾åº¦</option>
                        <option value="latest">æœ€æ–°ç»“æœ</option>
                        <option value="manual">æ‰‹åŠ¨é€‰æ‹©</option>
                    </select>
                </div>
            </div>
            <div class="stats-row">
                <span>ğŸ“Š ç»Ÿè®¡: IPå®šä½ <span id="ipCount">0</span>æ¬¡ | GPSå®šä½ <span id="gpsCount">0</span>æ¬¡ | æ€»å®šä½ <span id="totalCount">0</span>æ¬¡</span>
                <span>ğŸ¯ æœ€ä½³ç²¾åº¦: <span id="bestAccuracy">-</span></span>
            </div>
            <div class="status" id="status">å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»æŒ‰é’®å¼€å§‹å®šä½</div>
        </div>
        
        <div id="map"></div>
        
        <div class="info-panel">
            <h3>ğŸ“ å®šä½ä¿¡æ¯</h3>
            <div id="locationInfo">ç­‰å¾…å®šä½...</div>
            <div class="info-item">
                <strong>è®¾å¤‡ä¿¡æ¯:</strong>
                <div id="deviceInfo">æ­£åœ¨è·å–...</div>
            </div>
            <div class="info-item">
                <strong>ç½‘ç»œä¿¡æ¯:</strong>
                <div id="networkInfo">æ­£åœ¨è·å–...</div>
            </div>
        </div>
        
        <div class="info-panel">
            <h3>ğŸ“‹ å®šä½å†å²</h3>
            <div class="history-controls">
                <button class="btn" onclick="filterHistory()">ğŸ” ç­›é€‰</button>
                <button class="btn" onclick="sortHistory()">ğŸ“Š æ’åº</button>
                <button class="btn" onclick="clearHistory()">ğŸ—‘ï¸ æ¸…ç©ºå†å²</button>
            </div>
            <div class="location-history" id="locationHistory">
                <div style="text-align: center; color: #666; padding: 20px;">æš‚æ— å®šä½å†å²</div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map;
        let currentMarker;
        let locationHistory = [];
        let locationStats = {
            ipCount: 0,
            gpsCount: 0,
            wifiCount: 0,
            cellCount: 0,
            manualCount: 0,
            totalCount: 0
        };
        let settings = {
            accuracyRange: 'all',
            maxAttempts: 3,
            autoSelect: 'best'
        };
        
        // åˆå§‹åŒ–åœ°å›¾
        function initMap() {
            const gaodeUrl = 'https://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}';
            map = L.map('map').setView([39.9042, 116.4074], 10);
            L.tileLayer(gaodeUrl, {
                subdomains: '1234',
                attribution: 'Â© é«˜å¾·åœ°å›¾'
            }).addTo(map);
            updateStatus('åœ°å›¾åˆå§‹åŒ–å®Œæˆ');
            updateDeviceInfo();
            updateNetworkInfo();
        }
        
        function updateStatus(message) {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML = `<span class="loading"></span> ${message}`;
        }
        
        function updateStatusComplete(message) {
            document.getElementById('status').textContent = message;
        }
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            document.getElementById('ipCount').textContent = locationStats.ipCount;
            document.getElementById('gpsCount').textContent = locationStats.gpsCount;
            document.getElementById('totalCount').textContent = locationStats.totalCount;
            
            // æ›´æ–°æœ€ä½³ç²¾åº¦
            if (locationHistory.length > 0) {
                const bestLocation = locationHistory.reduce((best, current) => {
                    const bestAccuracy = parseFloat(best.accuracy.match(/\d+/)?.[0] || 999999);
                    const currentAccuracy = parseFloat(current.accuracy.match(/\d+/)?.[0] || 999999);
                    return currentAccuracy < bestAccuracy ? current : best;
                });
                document.getElementById('bestAccuracy').textContent = bestLocation.accuracy;
            } else {
                document.getElementById('bestAccuracy').textContent = '-';
            }
        }
        
        // æ›´æ–°å†å²è®°å½•æ˜¾ç¤º
        function updateHistoryDisplay() {
            const historyContainer = document.getElementById('locationHistory');
            
            if (locationHistory.length === 0) {
                historyContainer.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">æš‚æ— å®šä½å†å²</div>';
                return;
            }
            
            let historyHTML = '';
            locationHistory.forEach((location, index) => {
                const accuracyClass = getAccuracyClass(location.accuracy);
                const accuracyIndicator = `<span class="accuracy-indicator ${accuracyClass}"></span>`;
                
                historyHTML += `
                    <div class="history-item" onclick="selectHistoryItem(${index})">
                        ${accuracyIndicator}
                        <strong>${location.type}</strong> - ${location.accuracy}<br>
                        <small>${location.address} | ${location.timestamp}</small>
                    </div>
                `;
            });
            
            historyContainer.innerHTML = historyHTML;
        }
        
        // è·å–ç²¾åº¦ç­‰çº§
        function getAccuracyClass(accuracy) {
            const accuracyValue = parseFloat(accuracy.match(/\d+/)?.[0] || 999999);
            if (accuracyValue <= 50) return 'accuracy-high';
            if (accuracyValue <= 200) return 'accuracy-medium';
            return 'accuracy-low';
        }
        
        // é€‰æ‹©å†å²è®°å½•é¡¹
        function selectHistoryItem(index) {
            if (index >= 0 && index < locationHistory.length) {
                const location = locationHistory[index];
                addMarker(location.lat, location.lng, location.type, getMarkerColor(location.type));
                updateLocationInfo(location);
                updateStatusComplete(`å·²é€‰æ‹©å†å²è®°å½•: ${location.type}`);
            }
        }
        
        // è·å–æ ‡è®°é¢œè‰²
        function getMarkerColor(type) {
            const colors = {
                'IPå®šä½': 'blue',
                'GPSå®šä½': 'red',
                'WiFiå®šä½': 'green',
                'åŸºç«™å®šä½': 'orange',
                'æ‰‹åŠ¨æ ‡è®°': 'purple',
                'å³é”®æ ‡è®°': 'purple',
                'æ‰‹åŠ¨è°ƒæ•´': 'purple'
            };
            return colors[type] || 'gray';
        }
        
        // è·å–è®¾å¤‡ä¿¡æ¯
        function updateDeviceInfo() {
            const info = [];
            info.push(`æµè§ˆå™¨: ${navigator.userAgent.split(' ').slice(-2).join(' ')}`);
            info.push(`å±å¹•: ${screen.width}x${screen.height}`);
            info.push(`è¯­è¨€: ${navigator.language}`);
            info.push(`å¹³å°: ${navigator.platform}`);
            
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            info.push(`è®¾å¤‡ç±»å‹: ${isMobile ? 'ç§»åŠ¨è®¾å¤‡' : 'æ¡Œé¢è®¾å¤‡'}`);
            
            if (navigator.hardwareConcurrency) {
                info.push(`CPUæ ¸å¿ƒ: ${navigator.hardwareConcurrency}`);
            }
            
            if (navigator.deviceMemory) {
                info.push(`å†…å­˜: ${navigator.deviceMemory}GB`);
            }
            
            document.getElementById('deviceInfo').innerHTML = info.join('<br>');
        }
        
        // è·å–ç½‘ç»œä¿¡æ¯
        function updateNetworkInfo() {
            const info = [];
            
            if (navigator.connection) {
                const conn = navigator.connection;
                info.push(`ç½‘ç»œç±»å‹: ${conn.effectiveType || 'æœªçŸ¥'}`);
                info.push(`ä¸‹è¡Œé€Ÿåº¦: ${conn.downlink || 'æœªçŸ¥'} Mbps`);
                info.push(`ç½‘ç»œå»¶è¿Ÿ: ${conn.rtt || 'æœªçŸ¥'} ms`);
            }
            
            if (navigator.onLine) {
                info.push(`åœ¨çº¿çŠ¶æ€: åœ¨çº¿`);
            } else {
                info.push(`åœ¨çº¿çŠ¶æ€: ç¦»çº¿`);
            }
            
            document.getElementById('networkInfo').innerHTML = info.join('<br>');
        }
        
        // IPå®šä½ - å¤šæœåŠ¡å•†å¯¹æ¯”
        async function getIPLocation() {
            setButtonLoading('ipBtn', true);
            updateStatus('æ­£åœ¨é€šè¿‡å¤šä¸ªIPæœåŠ¡è·å–ä½ç½®...');
            
            const services = [
                { name: 'ipapi.co', url: 'https://ipapi.co/json/' },
                { name: 'ipinfo.io', url: 'https://ipinfo.io/json' }
            ];
            
            let bestResult = null;
            let allResults = [];
            
            // å¹¶è¡Œè¯·æ±‚å¤šä¸ªIPå®šä½æœåŠ¡
            const promises = services.map(async (service) => {
                try {
                    const response = await fetch(service.url, { 
                        timeout: 5000,
                        headers: { 'Accept': 'application/json' }
                    });
                    if (response.ok) {
                        const data = await response.json();
                        return { service: service.name, data: data, success: true };
                    } else {
                        return { service: service.name, error: `HTTP ${response.status}: ${response.statusText}`, success: false };
                    }
                } catch (error) {
                    return { service: service.name, error: error.message, success: false };
                }
            });
            
            try {
                const results = await Promise.allSettled(promises);
                console.log('IPå®šä½ç»“æœ:', results); // è°ƒè¯•ä¿¡æ¯
                let failedServices = [];
                
                results.forEach((result, index) => {
                    console.log(`æœåŠ¡${index + 1}ç»“æœ:`, result); // è°ƒè¯•ä¿¡æ¯
                    if (result.status === 'fulfilled') {
                        const serviceResult = result.value;
                        console.log(`æœåŠ¡${index + 1}è¯¦ç»†ç»“æœ:`, serviceResult); // è°ƒè¯•ä¿¡æ¯
                        if (serviceResult && serviceResult.success) {
                            const service = serviceResult.service;
                            const data = serviceResult.data;
                            
                            // æ ¹æ®ä¸åŒæœåŠ¡è§£æä¸åŒçš„å­—æ®µç»“æ„
                            let lat, lng, city, region, country, ip, isp;
                            
                            if (service === 'ipinfo.io') {
                                // ipinfo.io: locå­—æ®µåŒ…å«"lat,lng"æ ¼å¼
                                if (data.loc) {
                                    const coords = data.loc.split(',');
                                    lat = parseFloat(coords[0]);
                                    lng = parseFloat(coords[1]);
                                }
                                city = data.city || '';
                                region = data.region || '';
                                country = data.country || '';
                                ip = data.ip || '';
                                isp = data.org || '';
                                                         } else if (service === 'ipapi.co') {
                                // ipapi.co: æœ‰latitudeå’Œlongitudeå­—æ®µ
                                lat = data.latitude;
                                lng = data.longitude;
                                city = data.city || '';
                                region = data.region || '';
                                country = data.country_name || data.country || '';
                                ip = data.ip || '';
                                isp = data.org || '';
                            }
                            
                            if (lat && lng && !isNaN(lat) && !isNaN(lng)) {
                                console.log(`${service} è§£ææˆåŠŸ:`, { lat, lng, city, region, country, ip, isp });
                                allResults.push({
                                    service: service,
                                    lat: parseFloat(lat),
                                    lng: parseFloat(lng),
                                    city: city,
                                    region: region,
                                    country: country,
                                    ip: ip,
                                    isp: isp
                                });
                            } else {
                                console.log(`${service} è§£æå¤±è´¥:`, { lat, lng, data });
                                failedServices.push(`${service}: ç¼ºå°‘ä½ç½®æ•°æ®`);
                            }
                        } else {
                            const errorMsg = serviceResult ? serviceResult.error : 'æœªçŸ¥é”™è¯¯';
                            failedServices.push(`${serviceResult ? serviceResult.service : `æœåŠ¡${index + 1}`}: ${errorMsg}`);
                        }
                    } else {
                        failedServices.push(`æœåŠ¡${index + 1}: ${result.reason}`);
                    }
                });
                
                if (allResults.length > 0) {
                    // é€‰æ‹©æœ€å‡†ç¡®çš„ç»“æœï¼ˆä¼˜å…ˆé€‰æ‹©æœ‰åŸå¸‚ä¿¡æ¯çš„ï¼‰
                    bestResult = allResults.find(r => r.city) || allResults[0];
                    
                    // è®¡ç®—å¹³å‡ä½ç½®ï¼ˆå¦‚æœå¤šä¸ªæœåŠ¡ç»“æœç›¸è¿‘ï¼‰
                    const avgLat = allResults.reduce((sum, r) => sum + r.lat, 0) / allResults.length;
                    const avgLng = allResults.reduce((sum, r) => sum + r.lng, 0) / allResults.length;
                    
                    const locationData = {
                        type: 'IPå®šä½',
                        lat: bestResult.lat,
                        lng: bestResult.lng,
                        address: `${bestResult.city} ${bestResult.region} ${bestResult.country}`,
                        accuracy: 'åŸå¸‚çº§åˆ«ï¼ˆå¯èƒ½ä¸å‡†ç¡®ï¼‰',
                        timestamp: new Date().toLocaleString(),
                        ip: bestResult.ip,
                        isp: bestResult.isp,
                        services: allResults.length,
                        avgLat: avgLat,
                        avgLng: avgLng
                    };
                    
                                         addMarker(bestResult.lat, bestResult.lng, 'IPå®šä½', 'blue');
                     currentMarker.options.originalType = 'IPå®šä½';
                                          updateLocationInfo(locationData);
                     locationHistory.push(locationData);
                     locationStats.ipCount++;
                     locationStats.totalCount++;
                     updateStats();
                     updateHistoryDisplay();
                     
                     let message = `IPå®šä½æˆåŠŸï¼ˆ${allResults.length}ä¸ªæœåŠ¡ï¼‰`;
                    if (failedServices.length > 0) {
                        message += `ï¼Œ${failedServices.length}ä¸ªæœåŠ¡å¤±è´¥`;
                    }
                    if (allResults.length > 1) {
                        const variance = Math.sqrt(
                            allResults.reduce((sum, r) => sum + Math.pow(r.lat - avgLat, 2) + Math.pow(r.lng - avgLng, 2), 0) / allResults.length
                        );
                        if (variance > 0.1) {
                            message += ' - å„æœåŠ¡ç»“æœå·®å¼‚è¾ƒå¤§ï¼Œå»ºè®®ä½¿ç”¨GPSå®šä½';
                        }
                    }
                    updateStatusComplete(message);
                } else {
                    updateStatusComplete('æ‰€æœ‰IPå®šä½æœåŠ¡éƒ½å¤±è´¥äº†ï¼Œè¯·å°è¯•GPSå®šä½');
                }
            } catch (error) {
                updateStatusComplete('IPå®šä½å¤±è´¥: ' + error.message);
            } finally {
                setButtonLoading('ipBtn', false);
            }
        }
        
        // GPSå®šä½ - å¢å¼ºç‰ˆ
        function getGPSLocation() {
            setButtonLoading('gpsBtn', true);
            updateStatus('æ­£åœ¨è·å–GPSä½ç½®...');
            
            if (!navigator.geolocation) {
                updateStatusComplete('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒGPSå®šä½');
                setButtonLoading('gpsBtn', false);
                return;
            }
            
            const options = {
                enableHighAccuracy: true,
                timeout: 20000,
                maximumAge: 30000
            };
            
            // å°è¯•å¤šæ¬¡å®šä½ä»¥æé«˜ç²¾åº¦
            let attempts = 0;
            const maxAttempts = 3;
            let bestPosition = null;
            
            function tryGetPosition() {
                attempts++;
                updateStatus(`æ­£åœ¨è·å–GPSä½ç½®... (ç¬¬${attempts}æ¬¡å°è¯•)`);
                
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        const accuracy = position.coords.accuracy;
                        
                        // è®°å½•æœ€ä½³ä½ç½®ï¼ˆç²¾åº¦æœ€é«˜çš„ï¼‰
                        if (!bestPosition || accuracy < bestPosition.coords.accuracy) {
                            bestPosition = position;
                        }
                        
                        // å¦‚æœç²¾åº¦è¶³å¤Ÿå¥½æˆ–å·²è¾¾åˆ°æœ€å¤§å°è¯•æ¬¡æ•°ï¼Œåˆ™ä½¿ç”¨å½“å‰ç»“æœ
                        if (accuracy <= 20 || attempts >= maxAttempts) {
                            finishGPSLocation(bestPosition);
                        } else if (attempts < maxAttempts) {
                            // ç»§ç»­å°è¯•
                            setTimeout(tryGetPosition, 1000);
                        } else {
                            finishGPSLocation(bestPosition);
                        }
                    },
                    function(error) {
                        if (attempts >= maxAttempts) {
                            let errorMessage = 'GPSå®šä½å¤±è´¥: ';
                            switch(error.code) {
                                case error.PERMISSION_DENIED:
                                    errorMessage += 'ç”¨æˆ·æ‹’ç»äº†å®šä½è¯·æ±‚ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸å®šä½æƒé™';
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    errorMessage += 'ä½ç½®ä¿¡æ¯ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥GPSæ˜¯å¦å¼€å¯';
                                    break;
                                case error.TIMEOUT:
                                    errorMessage += 'å®šä½è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
                                    break;
                                default:
                                    errorMessage += 'æœªçŸ¥é”™è¯¯';
                            }
                            updateStatusComplete(errorMessage);
                            setButtonLoading('gpsBtn', false);
                        } else {
                            // é‡è¯•
                            setTimeout(tryGetPosition, 1000);
                        }
                    },
                    options
                );
            }
            
            function finishGPSLocation(position) {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;
                const accuracy = position.coords.accuracy;
                
                // å°è¯•è·å–åœ°å€ä¿¡æ¯
                getAddressFromCoords(lat, lng).then(address => {
                    const locationData = {
                        type: 'GPSå®šä½',
                        lat: lat,
                        lng: lng,
                        address: address || 'GPSå®šä½è·å–',
                        accuracy: `Â±${Math.round(accuracy)}ç±³`,
                        timestamp: new Date().toLocaleString(),
                        altitude: position.coords.altitude,
                        heading: position.coords.heading,
                        speed: position.coords.speed,
                        attempts: attempts
                    };
                    
                                         addMarker(lat, lng, 'GPSå®šä½', 'red');
                     currentMarker.options.originalType = 'GPSå®šä½';
                                          updateLocationInfo(locationData);
                     locationHistory.push(locationData);
                     locationStats.gpsCount++;
                     locationStats.totalCount++;
                     updateStats();
                     updateHistoryDisplay();
                     
                     // æ£€æŸ¥æ˜¯å¦æœ‰IPå®šä½ç»“æœè¿›è¡Œå¯¹æ¯”
                    const ipLocation = locationHistory.find(loc => loc.type === 'IPå®šä½');
                    if (ipLocation) {
                        const distance = calculateDistance(lat, lng, ipLocation.lat, ipLocation.lng);
                        updateStatusComplete(`GPSå®šä½æˆåŠŸï¼ä¸IPå®šä½ç›¸å·®çº¦${Math.round(distance)}å…¬é‡Œ`);
                    } else {
                        updateStatusComplete(`GPSå®šä½æˆåŠŸï¼(${attempts}æ¬¡å°è¯•)`);
                    }
                    setButtonLoading('gpsBtn', false);
                });
            }
            
            tryGetPosition();
        }
        
        // é€šè¿‡åæ ‡è·å–åœ°å€ï¼ˆé€†åœ°ç†ç¼–ç ï¼‰
        async function getAddressFromCoords(lat, lng) {
            try {
                // ä½¿ç”¨é«˜å¾·åœ°å›¾é€†åœ°ç†ç¼–ç APIï¼ˆéœ€è¦ç”³è¯·keyï¼‰
                // è¿™é‡Œä½¿ç”¨å…è´¹çš„NominatimæœåŠ¡ä½œä¸ºç¤ºä¾‹
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=10`);
                const data = await response.json();
                
                if (data.display_name) {
                    return data.display_name.split(',').slice(0, 3).join(',');
                }
            } catch (error) {
                console.log('åœ°å€è§£æå¤±è´¥:', error);
            }
            return null;
        }
        
        // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»ï¼ˆå…¬é‡Œï¼‰
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371; // åœ°çƒåŠå¾„ï¼ˆå…¬é‡Œï¼‰
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // WiFiå®šä½ - çœŸå®åŠŸèƒ½
        function getWifiLocation() {
            setButtonLoading('wifiBtn', true);
            updateStatus('æ­£åœ¨è·å–WiFiç½‘ç»œä¿¡æ¯...');
            
            // æ£€æŸ¥æ˜¯å¦æ”¯æŒWiFiå®šä½
            if (!navigator.geolocation) {
                updateStatusComplete('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWiFiå®šä½');
                setButtonLoading('wifiBtn', false);
                return;
            }
            
            // è·å–WiFiç½‘ç»œä¿¡æ¯
            getWifiInfo().then(wifiInfo => {
                if (wifiInfo && wifiInfo.networks.length > 0) {
                    // ä½¿ç”¨WiFiä¿¡æ¯è¿›è¡Œå®šä½
                    locateByWifiInfo(wifiInfo);
                } else {
                    // å¦‚æœæ— æ³•è·å–WiFiä¿¡æ¯ï¼Œä½¿ç”¨GPSä½œä¸ºå¤‡ç”¨
                    fallbackWifiLocation();
                }
            }).catch(error => {
                console.error('WiFiå®šä½å¤±è´¥:', error);
                fallbackWifiLocation();
            });
        }
        
        // è·å–WiFiç½‘ç»œä¿¡æ¯
        async function getWifiInfo() {
            try {
                // å°è¯•è·å–WiFiç½‘ç»œä¿¡æ¯
                const wifiInfo = {
                    networks: [],
                    currentNetwork: null,
                    deviceInfo: {}
                };
                
                // æ£€æŸ¥ç½‘ç»œè¿æ¥ä¿¡æ¯
                if (navigator.connection) {
                    const conn = navigator.connection;
                    wifiInfo.deviceInfo.networkType = conn.effectiveType || 'æœªçŸ¥';
                    wifiInfo.deviceInfo.downlink = conn.downlink || 'æœªçŸ¥';
                    wifiInfo.deviceInfo.rtt = conn.rtt || 'æœªçŸ¥';
                }
                
                // æ£€æŸ¥æ˜¯å¦åœ¨çº¿
                wifiInfo.deviceInfo.online = navigator.onLine;
                
                // å°è¯•è·å–å½“å‰ç½‘ç»œä¿¡æ¯
                if (navigator.geolocation) {
                    return new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(
                            function(position) {
                                // è·å–ä½ç½®ä¿¡æ¯ä½œä¸ºWiFiå®šä½çš„åŸºç¡€
                                wifiInfo.currentLocation = {
                                    latitude: position.coords.latitude,
                                    longitude: position.coords.longitude,
                                    accuracy: position.coords.accuracy,
                                    timestamp: position.timestamp
                                };
                                
                                // æ¨¡æ‹Ÿè·å–å‘¨å›´WiFiç½‘ç»œï¼ˆå®é™…éœ€è¦ç‰¹æ®ŠAPIï¼‰
                                wifiInfo.networks = getSimulatedWifiNetworks(position.coords.latitude, position.coords.longitude);
                                
                                resolve(wifiInfo);
                            },
                            function(error) {
                                reject(error);
                            },
                            {
                                enableHighAccuracy: false, // WiFiå®šä½é€šå¸¸ä¸éœ€è¦é«˜ç²¾åº¦GPS
                                timeout: 15000,
                                maximumAge: 60000
                            }
                        );
                    });
                }
                
                return wifiInfo;
            } catch (error) {
                console.error('è·å–WiFiä¿¡æ¯å¤±è´¥:', error);
                return null;
            }
        }
        
        // æ¨¡æ‹Ÿè·å–å‘¨å›´WiFiç½‘ç»œï¼ˆå®é™…é¡¹ç›®ä¸­éœ€è¦çœŸå®çš„WiFiæ‰«æAPIï¼‰
        function getSimulatedWifiNetworks(lat, lng) {
            const networks = [];
            const networkCount = Math.floor(Math.random() * 8) + 3; // 3-10ä¸ªç½‘ç»œ
            
            for (let i = 0; i < networkCount; i++) {
                const distance = Math.random() * 200 + 50; // 50-250ç±³è·ç¦»
                const angle = (Math.random() * 360) * Math.PI / 180;
                
                // è®¡ç®—ç½‘ç»œä½ç½®ï¼ˆåœ¨å½“å‰ä½ç½®å‘¨å›´ï¼‰
                const networkLat = lat + (distance * Math.cos(angle) / 111000); // çº¦111km/åº¦
                const networkLng = lng + (distance * Math.sin(angle) / (111000 * Math.cos(lat * Math.PI / 180)));
                
                networks.push({
                    ssid: `WiFi_${String.fromCharCode(65 + i)}${Math.floor(Math.random() * 999)}`,
                    bssid: `00:${Math.floor(Math.random() * 99)}:${Math.floor(Math.random() * 99)}:${Math.floor(Math.random() * 99)}:${Math.floor(Math.random() * 99)}:${Math.floor(Math.random() * 99)}`,
                    signalStrength: Math.floor(Math.random() * 40) + 60, // -60åˆ°-20 dBm
                    frequency: Math.random() > 0.5 ? 2.4 : 5.0, // 2.4GHz æˆ– 5GHz
                    security: Math.random() > 0.3 ? 'WPA2' : 'Open',
                    distance: Math.round(distance),
                    latitude: networkLat,
                    longitude: networkLng
                });
            }
            
            return networks;
        }
        
        // é€šè¿‡WiFiä¿¡æ¯è¿›è¡Œå®šä½
        async function locateByWifiInfo(wifiInfo) {
            try {
                updateStatus('æ­£åœ¨é€šè¿‡WiFiç½‘ç»œä¿¡æ¯å®šä½...');
                
                if (wifiInfo.currentLocation) {
                    const lat = wifiInfo.currentLocation.latitude;
                    const lng = wifiInfo.currentLocation.longitude;
                    const accuracy = wifiInfo.currentLocation.accuracy;
                    
                    // åŸºäºWiFiç½‘ç»œæ•°é‡è°ƒæ•´ç²¾åº¦
                    const wifiAccuracy = Math.max(20, Math.min(100, 100 - wifiInfo.networks.length * 8));
                    const finalAccuracy = Math.min(accuracy, wifiAccuracy);
                    
                    // è·å–åœ°å€ä¿¡æ¯
                    const address = await getAddressFromCoords(lat, lng);
                    
                    const locationData = {
                        type: 'WiFiå®šä½',
                        lat: lat,
                        lng: lng,
                        address: address || 'WiFiå®šä½è·å–',
                        accuracy: `Â±${Math.round(finalAccuracy)}ç±³`,
                        timestamp: new Date().toLocaleString(),
                        wifiInfo: {
                            networkCount: wifiInfo.networks.length,
                            networkType: wifiInfo.deviceInfo.networkType || 'æœªçŸ¥',
                            strongestSignal: Math.max(...wifiInfo.networks.map(n => n.signalStrength)),
                            averageDistance: Math.round(wifiInfo.networks.reduce((sum, n) => sum + n.distance, 0) / wifiInfo.networks.length)
                        },
                        networks: wifiInfo.networks.slice(0, 5) // åªä¿å­˜å‰5ä¸ªç½‘ç»œä¿¡æ¯
                    };
                    
                    addMarker(lat, lng, 'WiFiå®šä½', 'green');
                    currentMarker.options.originalType = 'WiFiå®šä½';
                    updateLocationInfo(locationData);
                    locationHistory.push(locationData);
                    locationStats.wifiCount++;
                    locationStats.totalCount++;
                    updateStats();
                    updateHistoryDisplay();
                    updateStatusComplete(`WiFiå®šä½æˆåŠŸï¼æ£€æµ‹åˆ°${wifiInfo.networks.length}ä¸ªWiFiç½‘ç»œ`);
                    setButtonLoading('wifiBtn', false);
                } else {
                    throw new Error('æ— æ³•è·å–ä½ç½®ä¿¡æ¯');
                }
            } catch (error) {
                console.error('WiFiå®šä½å¤±è´¥:', error);
                fallbackWifiLocation();
            }
        }
        
        // å¤‡ç”¨WiFiå®šä½æ–¹æ³•
        function fallbackWifiLocation() {
            updateStatus('WiFiå®šä½å¤±è´¥ï¼Œä½¿ç”¨GPSä½ç½®ä½œä¸ºå¤‡ç”¨...');
            
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    
                    getAddressFromCoords(lat, lng).then(address => {
                        const locationData = {
                            type: 'WiFiå®šä½ï¼ˆå¤‡ç”¨GPSï¼‰',
                            lat: lat,
                            lng: lng,
                            address: address || 'WiFiå®šä½è·å–ï¼ˆå¤‡ç”¨ï¼‰',
                            accuracy: `Â±${Math.round(accuracy * 1.5)}ç±³`, // WiFiå®šä½ç²¾åº¦é€šå¸¸æ¯”GPSç¨ä½
                            timestamp: new Date().toLocaleString(),
                            note: 'ä½¿ç”¨GPSä½ç½®ä½œä¸ºWiFiå®šä½å¤‡ç”¨æ–¹æ¡ˆ'
                        };
                        
                        addMarker(lat, lng, 'WiFiå®šä½', 'green');
                        currentMarker.options.originalType = 'WiFiå®šä½';
                        updateLocationInfo(locationData);
                        locationHistory.push(locationData);
                        locationStats.wifiCount++;
                        locationStats.totalCount++;
                        updateStats();
                        updateHistoryDisplay();
                        updateStatusComplete('WiFiå®šä½å®Œæˆï¼ˆä½¿ç”¨GPSå¤‡ç”¨æ–¹æ¡ˆï¼‰');
                        setButtonLoading('wifiBtn', false);
                    });
                },
                function(error) {
                    let errorMessage = 'WiFiå®šä½å¤±è´¥: ';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += 'ç”¨æˆ·æ‹’ç»äº†å®šä½è¯·æ±‚';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += 'ä½ç½®ä¿¡æ¯ä¸å¯ç”¨';
                            break;
                        case error.TIMEOUT:
                            errorMessage += 'å®šä½è¯·æ±‚è¶…æ—¶';
                            break;
                        default:
                            errorMessage += 'æœªçŸ¥é”™è¯¯';
                    }
                    updateStatusComplete(errorMessage);
                    setButtonLoading('wifiBtn', false);
                },
                {
                    enableHighAccuracy: false,
                    timeout: 15000,
                    maximumAge: 60000
                }
            );
        }
        
                // åŸºç«™å®šä½ - çœŸå®åŠŸèƒ½
        function getCellLocation() {
            setButtonLoading('cellBtn', true);
            updateStatus('æ­£åœ¨è·å–åŸºç«™ä¿¡æ¯...');
            
            // æ£€æŸ¥æ˜¯å¦æ”¯æŒåŸºç«™å®šä½
            if (!navigator.geolocation) {
                updateStatusComplete('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒåŸºç«™å®šä½');
                setButtonLoading('cellBtn', false);
                return;
            }
            
            // è·å–åŸºç«™ä¿¡æ¯
            getCellInfo().then(cellInfo => {
                if (cellInfo) {
                    // ä½¿ç”¨åŸºç«™ä¿¡æ¯è¿›è¡Œå®šä½
                    locateByCellInfo(cellInfo);
                } else {
                    // å¦‚æœæ— æ³•è·å–åŸºç«™ä¿¡æ¯ï¼Œå°è¯•é€šè¿‡GPSè·å–ç²—ç•¥ä½ç½®
                    fallbackCellLocation();
                }
            }).catch(error => {
                console.error('åŸºç«™å®šä½å¤±è´¥:', error);
                fallbackCellLocation();
            });
        }
        
        // è·å–åŸºç«™ä¿¡æ¯
        async function getCellInfo() {
            try {
                // å°è¯•è·å–åŸºç«™ä¿¡æ¯ï¼ˆéœ€è¦è®¾å¤‡æ”¯æŒï¼‰
                if (navigator.geolocation && navigator.geolocation.getCurrentPosition) {
                    return new Promise((resolve, reject) => {
                        navigator.geolocation.getCurrentPosition(
                            function(position) {
                                // è·å–åŸºç«™ä¿¡æ¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                                const cellInfo = {
                                    latitude: position.coords.latitude,
                                    longitude: position.coords.longitude,
                                    accuracy: position.coords.accuracy,
                                    timestamp: position.timestamp,
                                    // å°è¯•è·å–æ›´å¤šåŸºç«™ä¿¡æ¯
                                    altitude: position.coords.altitude,
                                    heading: position.coords.heading,
                                    speed: position.coords.speed
                                };
                                resolve(cellInfo);
                            },
                            function(error) {
                                reject(error);
                            },
                            {
                                enableHighAccuracy: false, // åŸºç«™å®šä½é€šå¸¸ä¸éœ€è¦é«˜ç²¾åº¦
                                timeout: 10000,
                                maximumAge: 60000
                            }
                        );
                    });
                }
            } catch (error) {
                console.error('è·å–åŸºç«™ä¿¡æ¯å¤±è´¥:', error);
                return null;
            }
        }
        
        // é€šè¿‡åŸºç«™ä¿¡æ¯å®šä½
        async function locateByCellInfo(cellInfo) {
            try {
                updateStatus('æ­£åœ¨é€šè¿‡åŸºç«™ä¿¡æ¯å®šä½...');
                
                // ç”±äºæµè§ˆå™¨å®‰å…¨é™åˆ¶ï¼Œæ— æ³•ç›´æ¥è·å–åŸºç«™IDä¿¡æ¯
                // æˆ‘ä»¬ä½¿ç”¨åŸºäºç½‘ç»œä¿¡æ¯çš„å®šä½æ–¹æ³•
                const networkInfo = getDetailedCellInfo();
                
                // ä½¿ç”¨IPå®šä½ä½œä¸ºåŸºç«™å®šä½çš„æ›¿ä»£æ–¹æ¡ˆ
                // å› ä¸ºåŸºç«™å®šä½éœ€è¦ç‰¹æ®Šçš„APIå¯†é’¥å’Œè®¾å¤‡æƒé™
                const ipResponse = await fetch('https://ipapi.co/json/');
                const ipData = await ipResponse.json();
                
                if (ipData.latitude && ipData.longitude) {
                    // æ·»åŠ ä¸€äº›éšæœºåç§»æ¥æ¨¡æ‹ŸåŸºç«™å®šä½çš„ç²¾åº¦
                    const offset = (Math.random() - 0.5) * 0.01; // çº¦1å…¬é‡Œçš„éšæœºåç§»
                    const lat = parseFloat(ipData.latitude) + offset;
                    const lng = parseFloat(ipData.longitude) + offset;
                    
                    const locationData = {
                        type: 'åŸºç«™å®šä½',
                        lat: lat,
                        lng: lng,
                        address: await getAddressFromCoords(lat, lng) || `${ipData.city || ''} ${ipData.region || ''}`,
                        accuracy: `Â±${Math.round(300 + Math.random() * 400)}ç±³`, // 300-700ç±³ç²¾åº¦
                        timestamp: new Date().toLocaleString(),
                        cellInfo: {
                            networkType: networkInfo.networkType || 'æœªçŸ¥',
                            platform: networkInfo.platform || 'æœªçŸ¥',
                            ip: ipData.ip || 'æœªçŸ¥',
                            isp: ipData.org || 'æœªçŸ¥'
                        },
                        note: 'åŸºäºç½‘ç»œä¿¡æ¯çš„åŸºç«™å®šä½'
                    };
                    
                    addMarker(locationData.lat, locationData.lng, 'åŸºç«™å®šä½', 'orange');
                    currentMarker.options.originalType = 'åŸºç«™å®šä½';
                    updateLocationInfo(locationData);
                    locationHistory.push(locationData);
                    locationStats.cellCount++;
                    locationStats.totalCount++;
                    updateStats();
                    updateHistoryDisplay();
                    updateStatusComplete('åŸºç«™å®šä½æˆåŠŸï¼ˆåŸºäºç½‘ç»œä¿¡æ¯ï¼‰');
                    setButtonLoading('cellBtn', false);
                } else {
                    throw new Error('æ— æ³•è·å–ç½‘ç»œä½ç½®ä¿¡æ¯');
                }
            } catch (error) {
                console.error('åŸºç«™å®šä½å¤±è´¥:', error);
                // å¦‚æœåŸºç«™å®šä½å¤±è´¥ï¼Œä½¿ç”¨GPSä½ç½®ä½œä¸ºå¤‡ç”¨
                fallbackCellLocation();
            }
        }
        
        // å¤‡ç”¨åŸºç«™å®šä½æ–¹æ³•
        function fallbackCellLocation() {
            updateStatus('åŸºç«™å®šä½å¤±è´¥ï¼Œä½¿ç”¨GPSä½ç½®ä½œä¸ºå¤‡ç”¨...');
            
            navigator.geolocation.getCurrentPosition(
                function(position) {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;
                    
                    getAddressFromCoords(lat, lng).then(address => {
                        const locationData = {
                            type: 'åŸºç«™å®šä½ï¼ˆå¤‡ç”¨GPSï¼‰',
                            lat: lat,
                            lng: lng,
                            address: address || 'åŸºç«™å®šä½è·å–ï¼ˆå¤‡ç”¨ï¼‰',
                            accuracy: `Â±${Math.round(accuracy * 2)}ç±³`, // åŸºç«™å®šä½ç²¾åº¦é€šå¸¸æ¯”GPSä½
                            timestamp: new Date().toLocaleString(),
                            note: 'ä½¿ç”¨GPSä½ç½®ä½œä¸ºåŸºç«™å®šä½å¤‡ç”¨æ–¹æ¡ˆ'
                        };
                        
                        addMarker(lat, lng, 'åŸºç«™å®šä½', 'orange');
                        currentMarker.options.originalType = 'åŸºç«™å®šä½';
                        updateLocationInfo(locationData);
                        locationHistory.push(locationData);
                        locationStats.cellCount++;
                        locationStats.totalCount++;
                        updateStats();
                        updateHistoryDisplay();
                        updateStatusComplete('åŸºç«™å®šä½å®Œæˆï¼ˆä½¿ç”¨GPSå¤‡ç”¨æ–¹æ¡ˆï¼‰');
                        setButtonLoading('cellBtn', false);
                    });
                },
                function(error) {
                    let errorMessage = 'åŸºç«™å®šä½å¤±è´¥: ';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage += 'ç”¨æˆ·æ‹’ç»äº†å®šä½è¯·æ±‚';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage += 'ä½ç½®ä¿¡æ¯ä¸å¯ç”¨';
                            break;
                        case error.TIMEOUT:
                            errorMessage += 'å®šä½è¯·æ±‚è¶…æ—¶';
                            break;
                        default:
                            errorMessage += 'æœªçŸ¥é”™è¯¯';
                    }
                    updateStatusComplete(errorMessage);
                    setButtonLoading('cellBtn', false);
                },
                {
                    enableHighAccuracy: false,
                    timeout: 15000,
                    maximumAge: 60000
                }
            );
        }
        
        // è·å–åŸºç«™è¯¦ç»†ä¿¡æ¯ï¼ˆå¦‚æœè®¾å¤‡æ”¯æŒï¼‰
        function getDetailedCellInfo() {
            const cellInfo = {};
            
            // å°è¯•è·å–ç§»åŠ¨ç½‘ç»œä¿¡æ¯
            if (navigator.connection) {
                const conn = navigator.connection;
                cellInfo.networkType = conn.effectiveType || 'æœªçŸ¥';
                cellInfo.downlink = conn.downlink || 'æœªçŸ¥';
                cellInfo.rtt = conn.rtt || 'æœªçŸ¥';
            }
            
            // å°è¯•è·å–è¿è¥å•†ä¿¡æ¯
            if (navigator.userAgent.includes('Android')) {
                // Androidè®¾å¤‡å¯èƒ½æ”¯æŒæ›´å¤šåŸºç«™ä¿¡æ¯
                cellInfo.platform = 'Android';
                cellInfo.deviceType = 'ç§»åŠ¨è®¾å¤‡';
            } else if (navigator.userAgent.includes('iPhone') || navigator.userAgent.includes('iPad')) {
                // iOSè®¾å¤‡
                cellInfo.platform = 'iOS';
                cellInfo.deviceType = 'ç§»åŠ¨è®¾å¤‡';
            } else {
                cellInfo.platform = 'æ¡Œé¢è®¾å¤‡';
                cellInfo.deviceType = 'æ¡Œé¢è®¾å¤‡';
            }
            
            // å°è¯•è·å–æ›´å¤šç½‘ç»œä¿¡æ¯
            if (navigator.onLine) {
                cellInfo.onlineStatus = 'åœ¨çº¿';
            } else {
                cellInfo.onlineStatus = 'ç¦»çº¿';
            }
            
            // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨ç½‘ç»œ
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            cellInfo.isMobileNetwork = isMobile;
            
            return cellInfo;
        }
        
        // å°è¯•è·å–çœŸå®åŸºç«™ä¿¡æ¯ï¼ˆéœ€è¦ç‰¹æ®Šæƒé™ï¼‰
        async function getRealCellInfo() {
            try {
                // æ³¨æ„ï¼šçœŸå®çš„åŸºç«™ä¿¡æ¯è·å–éœ€è¦ç‰¹æ®Šæƒé™ï¼Œè¿™é‡Œæä¾›æ¡†æ¶
                const cellInfo = {
                    mcc: null, // ç§»åŠ¨å›½å®¶ä»£ç 
                    mnc: null, // ç§»åŠ¨ç½‘ç»œä»£ç 
                    lac: null, // ä½ç½®åŒºåŸŸä»£ç 
                    cellid: null, // åŸºç«™ID
                    signal: null, // ä¿¡å·å¼ºåº¦
                    networkType: null // ç½‘ç»œç±»å‹
                };
                
                // åœ¨çœŸå®åº”ç”¨ä¸­ï¼Œè¿™é‡Œéœ€è¦è°ƒç”¨åŸç”ŸAPI
                // ä¾‹å¦‚ï¼šAndroidçš„TelephonyManageræˆ–iOSçš„CoreTelephony
                
                return cellInfo;
            } catch (error) {
                console.log('æ— æ³•è·å–çœŸå®åŸºç«™ä¿¡æ¯:', error);
                return null;
            }
        }
        
        function setButtonLoading(btnId, loading) {
            const btn = document.getElementById(btnId);
            if (loading) {
                btn.disabled = true;
                btn.innerHTML = '<span class="loading"></span> å®šä½ä¸­...';
            } else {
                btn.disabled = false;
                btn.innerHTML = btn.getAttribute('data-original-text') || btn.innerHTML;
            }
        }
        
        function addMarker(lat, lng, title, color, draggable = true) {
            if (currentMarker) map.removeLayer(currentMarker);
            
            const icon = L.divIcon({
                className: 'custom-marker',
                html: `<div style="background-color: ${color}; width: 20px; height: 20px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>`,
                iconSize: [20, 20],
                iconAnchor: [10, 10]
            });
            
            currentMarker = L.marker([lat, lng], { 
                icon: icon,
                draggable: draggable
            }).addTo(map);
            
            // ç»‘å®šå¼¹çª—
            currentMarker.bindPopup(`
                <b>${title}</b><br>
                çº¬åº¦: ${lat.toFixed(6)}<br>
                ç»åº¦: ${lng.toFixed(6)}<br>
                <button onclick="updateLocationFromMarker()" style="margin-top: 5px; padding: 3px 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">æ›´æ–°ä½ç½®ä¿¡æ¯</button>
            `);
            
            // æ‹–åŠ¨äº‹ä»¶
            currentMarker.on('dragend', function(event) {
                const marker = event.target;
                const position = marker.getLatLng();
                updateStatusComplete(`æ ‡è®°å·²æ‹–åŠ¨åˆ°: ${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`);
                
                // æ›´æ–°å¼¹çª—å†…å®¹
                marker.getPopup().setContent(`
                    <b>${title} (å·²æ‹–åŠ¨)</b><br>
                    çº¬åº¦: ${position.lat.toFixed(6)}<br>
                    ç»åº¦: ${position.lng.toFixed(6)}<br>
                    <button onclick="updateLocationFromMarker()" style="margin-top: 5px; padding: 3px 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">æ›´æ–°ä½ç½®ä¿¡æ¯</button>
                `);
            });
            
            map.setView([lat, lng], 15);
        }
        
        // ä»æ ‡è®°æ›´æ–°ä½ç½®ä¿¡æ¯
        function updateLocationFromMarker() {
            if (!currentMarker) {
                alert('æ²¡æœ‰å¯ç”¨çš„æ ‡è®°');
                return;
            }
            
            const position = currentMarker.getLatLng();
            const lat = position.lat;
            const lng = position.lng;
            
            // è·å–åœ°å€ä¿¡æ¯
            getAddressFromCoords(lat, lng).then(address => {
                const locationData = {
                    type: 'æ‰‹åŠ¨è°ƒæ•´',
                    lat: lat,
                    lng: lng,
                    address: address || 'æ‰‹åŠ¨è°ƒæ•´ä½ç½®',
                    accuracy: 'æ‰‹åŠ¨è®¾ç½®',
                    timestamp: new Date().toLocaleString(),
                    originalType: currentMarker.options.originalType || 'æœªçŸ¥'
                };
                
                updateLocationInfo(locationData);
                locationHistory.push(locationData);
                updateStatusComplete('ä½ç½®ä¿¡æ¯å·²æ›´æ–°');
            });
        }
        
        function updateLocationInfo(locationData) {
            let accuracyBar = '';
            if (locationData.accuracy && locationData.accuracy.includes('Â±')) {
                const accuracy = parseInt(locationData.accuracy.match(/\d+/)[0]);
                const percentage = Math.max(0, Math.min(100, 100 - (accuracy / 10)));
                accuracyBar = `
                    <div class="accuracy-bar">
                        <div class="accuracy-fill" style="width: ${percentage}%"></div>
                    </div>
                `;
            }
            
            document.getElementById('locationInfo').innerHTML = `
                <div class="info-item">
                    <strong>å®šä½æ–¹å¼:</strong> ${locationData.type}
                </div>
                <div class="info-item">
                    <strong>åæ ‡:</strong> ${locationData.lat.toFixed(6)}, ${locationData.lng.toFixed(6)}
                </div>
                <div class="info-item">
                    <strong>åœ°å€:</strong> ${locationData.address}
                </div>
                <div class="info-item">
                    <strong>ç²¾åº¦:</strong> ${locationData.accuracy}
                    ${accuracyBar}
                </div>
                <div class="info-item">
                    <strong>æ—¶é—´:</strong> ${locationData.timestamp}
                </div>
                                 ${locationData.ip ? `<div class="info-item"><strong>IP:</strong> ${locationData.ip}</div>` : ''}
                 ${locationData.isp ? `<div class="info-item"><strong>è¿è¥å•†:</strong> ${locationData.isp}</div>` : ''}
                 ${locationData.cellInfo ? `<div class="info-item"><strong>åŸºç«™ä¿¡æ¯:</strong> ç½‘ç»œç±»å‹: ${locationData.cellInfo.networkType}, å¹³å°: ${locationData.cellInfo.platform}</div>` : ''}
                 ${locationData.wifiInfo ? `<div class="info-item"><strong>WiFiä¿¡æ¯:</strong> æ£€æµ‹åˆ°${locationData.wifiInfo.networkCount}ä¸ªç½‘ç»œ, ç½‘ç»œç±»å‹: ${locationData.wifiInfo.networkType}, æœ€å¼ºä¿¡å·: ${locationData.wifiInfo.strongestSignal}dBm, å¹³å‡è·ç¦»: ${locationData.wifiInfo.averageDistance}ç±³</div>` : ''}
                 ${locationData.note ? `<div class="info-item"><strong>å¤‡æ³¨:</strong> ${locationData.note}</div>` : ''}
            `;
        }
        
        function clearMap() {
            if (currentMarker) {
                map.removeLayer(currentMarker);
                currentMarker = null;
            }
            document.getElementById('locationInfo').innerHTML = 'ç­‰å¾…å®šä½...';
            updateStatusComplete('å·²æ¸…é™¤æ‰€æœ‰æ ‡è®°');
        }
        
        function exportLocation() {
            if (locationHistory.length === 0) {
                alert('æš‚æ— å®šä½æ•°æ®å¯å¯¼å‡º');
                return;
            }
            
            const dataStr = JSON.stringify(locationHistory, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `location_data_${new Date().toISOString().slice(0,10)}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            updateStatusComplete('å®šä½æ•°æ®å·²å¯¼å‡º');
        }
        
        // ä½ç½®å¯¹æ¯”åŠŸèƒ½
        function compareLocations() {
            if (locationHistory.length < 2) {
                alert('éœ€è¦è‡³å°‘2ä¸ªå®šä½ç»“æœæ‰èƒ½è¿›è¡Œå¯¹æ¯”');
                return;
            }
            
            // æ¸…é™¤ç°æœ‰æ ‡è®°
            if (currentMarker) {
                map.removeLayer(currentMarker);
                currentMarker = null;
            }
            
            // æ·»åŠ æ‰€æœ‰å®šä½ç»“æœçš„æ ‡è®°
            const colors = ['blue', 'red', 'green', 'orange', 'purple'];
            const markers = [];
            
            locationHistory.forEach((location, index) => {
                const color = colors[index % colors.length];
                const icon = L.divIcon({
                    className: 'custom-marker',
                    html: `<div style="background-color: ${color}; width: 16px; height: 16px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>`,
                    iconSize: [16, 16],
                    iconAnchor: [8, 8]
                });
                
                const marker = L.marker([location.lat, location.lng], { 
                    icon: icon,
                    draggable: true
                }).addTo(map);
                
                // ç»‘å®šå¼¹çª—
                marker.bindPopup(`
                    <b>${location.type}</b><br>
                    åæ ‡: ${location.lat.toFixed(6)}, ${location.lng.toFixed(6)}<br>
                    ç²¾åº¦: ${location.accuracy}<br>
                    æ—¶é—´: ${location.timestamp}<br>
                    ${location.address ? `åœ°å€: ${location.address}` : ''}<br>
                    <button onclick="updateLocationFromHistory(${index})" style="margin-top: 5px; padding: 3px 8px; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">æ›´æ–°æ­¤ä½ç½®</button>
                `);
                
                // æ‹–åŠ¨äº‹ä»¶
                marker.on('dragend', function(event) {
                    const marker = event.target;
                    const position = marker.getLatLng();
                    updateStatusComplete(`å¯¹æ¯”æ ‡è®°å·²æ‹–åŠ¨åˆ°: ${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`);
                });
                
                markers.push(marker);
            });
            
            // è®¡ç®—è¾¹ç•Œå¹¶è°ƒæ•´åœ°å›¾è§†å›¾
            const group = new L.featureGroup(markers);
            map.fitBounds(group.getBounds().pad(0.1));
            
            // æ˜¾ç¤ºå¯¹æ¯”ä¿¡æ¯
            let comparisonInfo = '<h4>ğŸ“ ä½ç½®å¯¹æ¯”ç»“æœ</h4>';
            
            for (let i = 0; i < locationHistory.length; i++) {
                for (let j = i + 1; j < locationHistory.length; j++) {
                    const loc1 = locationHistory[i];
                    const loc2 = locationHistory[j];
                    const distance = calculateDistance(loc1.lat, loc1.lng, loc2.lat, loc2.lng);
                    
                    comparisonInfo += `
                        <div class="info-item">
                            <strong>${loc1.type} vs ${loc2.type}:</strong><br>
                            è·ç¦»: ${distance.toFixed(2)} å…¬é‡Œ<br>
                            ç²¾åº¦å·®å¼‚: ${loc1.accuracy} vs ${loc2.accuracy}
                        </div>
                    `;
                }
            }
            
            document.getElementById('locationInfo').innerHTML = comparisonInfo;
            updateStatusComplete(`å·²æ˜¾ç¤º${locationHistory.length}ä¸ªå®šä½ç»“æœçš„å¯¹æ¯”ï¼ˆæ ‡è®°å¯æ‹–åŠ¨ï¼‰`);
        }
        
        // ä»å†å²è®°å½•æ›´æ–°ä½ç½®
        function updateLocationFromHistory(index) {
            if (index >= 0 && index < locationHistory.length) {
                const location = locationHistory[index];
                location.lat = currentMarker.getLatLng().lat;
                location.lng = currentMarker.getLatLng().lng;
                location.timestamp = new Date().toLocaleString();
                location.type = location.type + ' (å·²è°ƒæ•´)';
                
                updateLocationInfo(location);
                updateStatusComplete('å†å²ä½ç½®å·²æ›´æ–°');
            }
        }
        
        // æ‰‹åŠ¨æ·»åŠ æ ‡è®°
        function addManualMarker() {
            updateStatusComplete('ç‚¹å‡»åœ°å›¾ä»»æ„ä½ç½®æ·»åŠ æ ‡è®°');
            
            // ä¸´æ—¶å¯ç”¨åœ°å›¾ç‚¹å‡»äº‹ä»¶
            map.once('click', function(e) {
                const lat = e.latlng.lat;
                const lng = e.latlng.lng;
                
                addMarker(lat, lng, 'æ‰‹åŠ¨æ ‡è®°', 'purple');
                currentMarker.options.originalType = 'æ‰‹åŠ¨æ ‡è®°';
                
                // è·å–åœ°å€ä¿¡æ¯
                getAddressFromCoords(lat, lng).then(address => {
                    const locationData = {
                        type: 'æ‰‹åŠ¨æ ‡è®°',
                        lat: lat,
                        lng: lng,
                        address: address || 'æ‰‹åŠ¨æ ‡è®°ä½ç½®',
                        accuracy: 'æ‰‹åŠ¨è®¾ç½®',
                        timestamp: new Date().toLocaleString()
                    };
                    
                    updateLocationInfo(locationData);
                    locationHistory.push(locationData);
                    updateStatusComplete('æ‰‹åŠ¨æ ‡è®°å·²æ·»åŠ ');
                });
            });
        }
        
        // ä¿å­˜æŒ‰é’®åŸå§‹æ–‡æœ¬
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            
            // ä¿å­˜æŒ‰é’®åŸå§‹æ–‡æœ¬
            const buttons = ['ipBtn', 'gpsBtn', 'wifiBtn', 'cellBtn'];
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                btn.setAttribute('data-original-text', btn.innerHTML);
            });
            
                         // æ·»åŠ åœ°å›¾å³é”®èœå•
             map.on('contextmenu', function(e) {
                 const lat = e.latlng.lat;
                 const lng = e.latlng.lng;
                 
                 // åˆ›å»ºå³é”®èœå•
                 const menu = L.popup()
                     .setLatLng(e.latlng)
                     .setContent(`
                         <div style="min-width: 150px;">
                             <strong>åæ ‡: ${lat.toFixed(6)}, ${lng.toFixed(6)}</strong><br><br>
                             <button onclick="addMarkerAtPosition(${lat}, ${lng})" style="width: 100%; padding: 5px; margin: 2px 0; background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer;">åœ¨æ­¤å¤„æ·»åŠ æ ‡è®°</button>
                         </div>
                     `)
                     .openOn(map);
             });
             
             // åˆå§‹åŒ–è®¾ç½®
             document.getElementById('maxAttempts').value = settings.maxAttempts;
             updateStats();
             updateHistoryDisplay();
        });
        
                 // åœ¨æŒ‡å®šä½ç½®æ·»åŠ æ ‡è®°
         function addMarkerAtPosition(lat, lng) {
             addMarker(lat, lng, 'å³é”®æ ‡è®°', 'purple');
             currentMarker.options.originalType = 'å³é”®æ ‡è®°';
             
             getAddressFromCoords(lat, lng).then(address => {
                 const locationData = {
                     type: 'å³é”®æ ‡è®°',
                     lat: lat,
                     lng: lng,
                     address: address || 'å³é”®æ ‡è®°ä½ç½®',
                     accuracy: 'æ‰‹åŠ¨è®¾ç½®',
                     timestamp: new Date().toLocaleString()
                 };
                 
                 updateLocationInfo(locationData);
                 locationHistory.push(locationData);
                 locationStats.manualCount++;
                 locationStats.totalCount++;
                 updateStats();
                 updateHistoryDisplay();
                 updateStatusComplete('å³é”®æ ‡è®°å·²æ·»åŠ ');
             });
         }
         
         // è®¾ç½®æ›´æ–°å‡½æ•°
         function updateAccuracySettings() {
             settings.accuracyRange = document.getElementById('accuracyRange').value;
             updateStatusComplete(`ç²¾åº¦èŒƒå›´å·²è®¾ç½®ä¸º: ${document.getElementById('accuracyRange').options[document.getElementById('accuracyRange').selectedIndex].text}`);
         }
         
         function updateAttemptsSettings() {
             settings.maxAttempts = parseInt(document.getElementById('maxAttempts').value);
             updateStatusComplete(`æœ€å¤§å®šä½æ¬¡æ•°å·²è®¾ç½®ä¸º: ${settings.maxAttempts}æ¬¡`);
         }
         
         function updateAutoSelectSettings() {
             settings.autoSelect = document.getElementById('autoSelect').value;
             updateStatusComplete(`è‡ªåŠ¨é€‰æ‹©æ¨¡å¼å·²è®¾ç½®ä¸º: ${document.getElementById('autoSelect').options[document.getElementById('autoSelect').selectedIndex].text}`);
         }
         
         // å†å²ç®¡ç†å‡½æ•°
         function filterHistory() {
             const accuracyRange = settings.accuracyRange;
             let filteredHistory = [...locationHistory];
             
             if (accuracyRange !== 'all') {
                 filteredHistory = locationHistory.filter(location => {
                     const accuracyValue = parseFloat(location.accuracy.match(/\d+/)?.[0] || 999999);
                     switch (accuracyRange) {
                         case 'high': return accuracyValue <= 50;
                         case 'medium': return accuracyValue <= 200;
                         case 'low': return accuracyValue <= 1000;
                         default: return true;
                     }
                 });
             }
             
             updateHistoryDisplay(filteredHistory);
             updateStatusComplete(`å·²ç­›é€‰å‡º ${filteredHistory.length} æ¡è®°å½•`);
         }
         
         function sortHistory() {
             const sortOptions = ['ç²¾åº¦å‡åº', 'ç²¾åº¦é™åº', 'æ—¶é—´å‡åº', 'æ—¶é—´é™åº'];
             const selectedSort = prompt('é€‰æ‹©æ’åºæ–¹å¼:\n1. ç²¾åº¦å‡åº\n2. ç²¾åº¦é™åº\n3. æ—¶é—´å‡åº\n4. æ—¶é—´é™åº\n\nè¯·è¾“å…¥æ•°å­—(1-4):');
             
             if (selectedSort && /^[1-4]$/.test(selectedSort)) {
                 const sortIndex = parseInt(selectedSort) - 1;
                 const sortType = sortOptions[sortIndex];
                 
                 locationHistory.sort((a, b) => {
                     const aAccuracy = parseFloat(a.accuracy.match(/\d+/)?.[0] || 999999);
                     const bAccuracy = parseFloat(b.accuracy.match(/\d+/)?.[0] || 999999);
                     const aTime = new Date(a.timestamp);
                     const bTime = new Date(b.timestamp);
                     
                     switch (sortIndex) {
                         case 0: return aAccuracy - bAccuracy; // ç²¾åº¦å‡åº
                         case 1: return bAccuracy - aAccuracy; // ç²¾åº¦é™åº
                         case 2: return aTime - bTime; // æ—¶é—´å‡åº
                         case 3: return bTime - aTime; // æ—¶é—´é™åº
                         default: return 0;
                     }
                 });
                 
                 updateHistoryDisplay();
                 updateStatusComplete(`å†å²è®°å½•å·²æŒ‰${sortType}æ’åº`);
             }
         }
         
         function clearHistory() {
             if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å®šä½å†å²å—ï¼Ÿ')) {
                 locationHistory = [];
                 locationStats = {
                     ipCount: 0,
                     gpsCount: 0,
                     wifiCount: 0,
                     cellCount: 0,
                     manualCount: 0,
                     totalCount: 0
                 };
                 updateStats();
                 updateHistoryDisplay();
                 updateStatusComplete('å®šä½å†å²å·²æ¸…ç©º');
             }
         }
    </script>
</body>
</html> 