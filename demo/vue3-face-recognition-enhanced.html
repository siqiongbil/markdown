<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue3 å¢å¼ºç‰ˆäººè„¸è¯†åˆ« - åŒ…å«äººè„¸åº“å¯¹æ¯”</title>
    
    <!-- Vue3 + Element Plus -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    <script src="https://unpkg.com/element-plus/dist/index.full.js"></script>
    
    <!-- face-api.js -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    
    <!-- äººè„¸æ•°æ®åº“ç®¡ç†å™¨ -->
    <script src="face-db-manager.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 16px;
            font-family: system-ui, sans-serif;
            color: #333;
            line-height: 1.5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            padding: 20px;
            text-align: center;
            border-bottom: 1px solid #ddd;
        }
        
        .header h1 {
            margin: 0;
            font-size: 1.8em;
            font-weight: 600;
        }
        
        .header p {
            margin: 8px 0 0 0;
            color: #666;
        }
        
        .content {
            padding: 20px;
        }
        
        .main-layout {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
        }
        
        .video-section {
            text-align: center;
        }
        
        .video-container {
            position: relative;
            display: inline-block;
            border: 1px solid #ddd;
            margin: 15px 0;
        }
        
        #video {
            display: block;
            width: 640px;
            height: 480px;
            max-width: 100%;
        }
        
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .controls {
            margin: 15px 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .face-library-panel {
            border: 1px solid #ddd;
            padding: 15px;
        }
        
        .upload-area {
            border: 2px dashed #ccc;
            padding: 20px;
            text-align: center;
            margin: 15px 0;
            cursor: pointer;
        }
        
        .upload-area:hover {
            border-color: #999;
        }
        
        .face-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .face-card {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: center;
            position: relative;
        }
        
        .face-card.matched {
            border-color: #28a745;
        }
        
        .face-image {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 8px;
        }
        
        .face-name {
            font-size: 11px;
            color: #333;
            margin-bottom: 4px;
        }
        
        .confidence-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            border: 1px solid #28a745;
            color: #28a745;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
        }
        
        .delete-btn {
            position: absolute;
            top: -5px;
            left: -5px;
            border: 1px solid #dc3545;
            color: #dc3545;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }
        
        .recognition-results {
            border: 1px solid #ddd;
            padding: 15px;
            margin-top: 15px;
        }
        
        .match-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 8px;
        }
        
        .match-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
        }
        
        .match-info {
            flex: 1;
        }
        
        .match-name {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 3px;
        }
        
        .match-confidence {
            font-size: 12px;
            color: #666;
        }
        
        .settings-panel {
            border: 1px solid #ddd;
            padding: 15px;
            margin-top: 15px;
        }
        
        .setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .setting-label {
            min-width: 100px;
            color: #666;
        }
        
        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .stat-card {
            border: 1px solid #ddd;
            padding: 15px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #333;
            display: block;
        }
        
        .stat-label {
            font-size: 0.85em;
            color: #666;
            margin-top: 4px;
        }
        
        .comparison-mode {
            padding: 12px;
            margin: 12px 0;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        .tech-specs {
            border: 1px solid #ddd;
            padding: 12px;
            margin-top: 12px;
        }
        
        .spec-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #eee;
        }
        
        .spec-item:last-child {
            border-bottom: none;
        }
        
        .spec-label {
            color: #666;
        }
        
        .spec-value {
            color: #333;
        }
        
        @media (max-width: 1000px) {
            .main-layout {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            #video {
                width: 100%;
                height: auto;
            }
            
            .face-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }
    </style>
</head>
<body>
    <!-- è¿”å›æ–‡æ¡£é“¾æ¥ -->
    <div style="position: fixed; top: 10px; left: 10px; z-index: 2000; background: rgba(255, 255, 255, 0.95); padding: 8px 12px; border-radius: 5px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);">
        <a href="https://www.siqiongbiluo.love/article/17" style="text-decoration: none; color: #4fc08d; font-size: 14px; font-weight: 500;">â† è¿”å›æ–‡æ¡£</a>
    </div>
    <div id="app">
        <div class="container">
            <div class="header">
                <h1>Vue3 å¢å¼ºç‰ˆäººè„¸è¯†åˆ«ç³»ç»Ÿ</h1>
                <p>æ”¯æŒäººè„¸åº“ç®¡ç†å’Œå®æ—¶è¯†åˆ«å¯¹æ¯”åŠŸèƒ½</p>
            </div>
            
            <div class="content">
                <div class="main-layout">
                    <!-- å·¦ä¾§ï¼šè§†é¢‘æ£€æµ‹åŒºåŸŸ -->
                    <div class="video-section">
                        <div class="video-container">
                            <video
                                id="video"
                                ref="videoRef"
                                autoplay
                                muted
                                playsinline
                            ></video>
                            <canvas
                                id="overlay"
                                ref="canvasRef"
                                width="640"
                                height="480"
                            ></canvas>
                        </div>
                        
                        <!-- æ§åˆ¶æŒ‰é’® -->
                        <div class="controls">
                            <el-button 
                                type="primary" 
                                @click="startCamera" 
                                :disabled="isRunning"
                                :loading="isLoading"
                                size="large"
                            >
                                {{ isLoading ? 'åŠ è½½ä¸­...' : 'å¯åŠ¨æ‘„åƒå¤´' }}
                            </el-button>
                            
                            <el-button 
                                type="danger" 
                                @click="stopCamera" 
                                :disabled="!isRunning"
                                size="large"
                            >
                                åœæ­¢æ‘„åƒå¤´
                            </el-button>
                            
                            <el-button 
                                type="success" 
                                @click="captureAndAdd" 
                                :disabled="!isRunning || faceData.length === 0"
                                size="large"
                            >
                                æ·»åŠ åˆ°äººè„¸åº“
                            </el-button>
                            
                            <el-button 
                                type="info" 
                                @click="toggleComparison" 
                                :disabled="!isRunning"
                                size="large"
                            >
                                {{ comparisonMode ? 'å…³é—­è¯†åˆ«' : 'å¼€å¯è¯†åˆ«' }}
                            </el-button>
                        </div>
                        
                        <!-- å¯¹æ¯”æ¨¡å¼æç¤º -->
                        <div v-if="comparisonMode" class="comparison-mode">
                            <h4 style="margin: 0 0 10px 0;">äººè„¸è¯†åˆ«æ¨¡å¼å·²å¼€å¯</h4>
                            <p style="margin: 0;">æ­£åœ¨ä¸äººè„¸åº“ä¸­çš„ {{ faceLibrary.length }} ä¸ªäººè„¸è¿›è¡Œå®æ—¶å¯¹æ¯”</p>
                        </div>
                        
                        <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                        <div class="stats-section">
                            <div class="stat-card">
                                <span class="stat-value">{{ faceData.length }}</span>
                                <div class="stat-label">æ£€æµ‹äººè„¸</div>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">{{ matchedFaces.length }}</span>
                                <div class="stat-label">è¯†åˆ«åŒ¹é…</div>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">{{ fps }}</span>
                                <div class="stat-label">FPS</div>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">{{ faceLibrary.length }}</span>
                                <div class="stat-label">äººè„¸åº“</div>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">{{ detectionCount }}</span>
                                <div class="stat-label">æ£€æµ‹æ¬¡æ•°</div>
                            </div>
                            <div class="stat-card">
                                <span class="stat-value">{{ averageConfidence }}%</span>
                                <div class="stat-label">å¹³å‡ç½®ä¿¡åº¦</div>
                            </div>
                        </div>
                        
                        <!-- è¯†åˆ«ç»“æœ -->
                        <div v-if="matchedFaces.length > 0" class="recognition-results">
                            <h3 style="margin: 0 0 15px 0; color: #333;">è¯†åˆ«ç»“æœ</h3>
                            <div 
                                v-for="(match, index) in matchedFaces" 
                                :key="index"
                                class="match-item"
                            >
                                <img :src="match.faceImage" class="match-avatar" alt="åŒ¹é…äººè„¸">
                                <div class="match-info">
                                    <div class="match-name">{{ match.name }}</div>
                                    <div class="match-confidence">
                                        ç›¸ä¼¼åº¦: {{ (match.confidence * 100).toFixed(1) }}%
                                        <span v-if="match.distance < 0.4" style="color: #67c23a; margin-left: 10px;">é«˜åº¦åŒ¹é…</span>
                                        <span v-else-if="match.distance < 0.6" style="color: #e6a23c; margin-left: 10px;">å¯èƒ½åŒ¹é…</span>
                                        <span v-else style="color: #f56c6c; margin-left: 10px;">ä½åŒ¹é…åº¦</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- è®¾ç½®é¢æ¿ -->
                        <div class="settings-panel">
                            <h3 style="margin: 0 0 15px 0; color: #333;">æ£€æµ‹è®¾ç½®</h3>
                            
                            <div class="setting-item">
                                <span class="setting-label">æ£€æµ‹é˜ˆå€¼:</span>
                                <el-slider
                                    v-model="detectionScore"
                                    :min="0.1"
                                    :max="1"
                                    :step="0.1"
                                    show-input
                                    style="flex: 1;"
                                />
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">è¯†åˆ«é˜ˆå€¼:</span>
                                <el-slider
                                    v-model="recognitionThreshold"
                                    :min="0.3"
                                    :max="0.8"
                                    :step="0.05"
                                    show-input
                                    style="flex: 1;"
                                />
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">æ£€æµ‹é—´éš”:</span>
                                <el-slider
                                    v-model="detectionInterval"
                                    :min="100"
                                    :max="1000"
                                    :step="100"
                                    show-input
                                    style="flex: 1;"
                                />
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">è¾“å…¥å°ºå¯¸:</span>
                                <el-select v-model="inputSize" size="small" style="width: 120px;">
                                    <el-option label="128" :value="128" />
                                    <el-option label="160" :value="160" />
                                    <el-option label="224" :value="224" />
                                    <el-option label="320" :value="320" />
                                    <el-option label="416" :value="416" />
                                    <el-option label="512" :value="512" />
                                </el-select>
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">ç›®æ ‡FPS:</span>
                                <el-select v-model="targetFPS" size="small" style="width: 120px;">
                                    <el-option label="15 FPS" :value="15" />
                                    <el-option label="30 FPS" :value="30" />
                                    <el-option label="60 FPS" :value="60" />
                                </el-select>
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">æ˜¾ç¤ºå…³é”®ç‚¹:</span>
                                <el-switch
                                    v-model="showLandmarks"
                                    active-text="å¼€å¯"
                                    inactive-text="å…³é—­"
                                />
                            </div>
                            
                            <div class="setting-item">
                                <span class="setting-label">æ˜¾ç¤ºè¡¨æƒ…:</span>
                                <el-switch
                                    v-model="showExpressions"
                                    active-text="å¼€å¯"
                                    inactive-text="å…³é—­"
                                />
                            </div>
                        </div>
                        
                        <!-- ç³»ç»Ÿä¿¡æ¯é¢æ¿ -->
                        <div class="settings-panel">
                            <h3 style="margin: 0 0 15px 0; color: #333;">ç³»ç»Ÿä¿¡æ¯</h3>
                            
                            <div class="tech-specs">
                                <div class="spec-item">
                                    <span class="spec-label">æ¡†æ¶ç‰ˆæœ¬:</span>
                                    <span class="spec-value">Vue 3.x</span>
                                </div>
                                
                                <div class="spec-item">
                                    <span class="spec-label">æ£€æµ‹å¼•æ“:</span>
                                    <span class="spec-value">TinyFaceDetector</span>
                                </div>
                                
                                <div class="spec-item">
                                    <span class="spec-label">è¾“å…¥å°ºå¯¸:</span>
                                    <span class="spec-value">{{ inputSize }}x{{ inputSize }}</span>
                                </div>
                                
                                <div class="spec-item">
                                    <span class="spec-label">å½“å‰é˜ˆå€¼:</span>
                                    <span class="spec-value">{{ detectionScore }}</span>
                                </div>
                                
                                <div class="spec-item">
                                    <span class="spec-label">æ£€æµ‹é—´éš”:</span>
                                    <span class="spec-value">{{ detectionInterval }}ms</span>
                                </div>
                                
                                <div class="spec-item">
                                    <span class="spec-label">æµè§ˆå™¨æ”¯æŒ:</span>
                                    <span class="spec-value">
                                        <el-tag :type="browserSupport ? 'success' : 'danger'" size="small">
                                            {{ browserSupport ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ' }}
                                        </el-tag>
                                    </span>
                                </div>
                            </div>
                            
                            <!-- åŠŸèƒ½ç‰¹æ€§ -->
                            <h4 style="margin: 20px 0 15px 0; color: #666;">åŠŸèƒ½ç‰¹æ€§</h4>
                            <div>
                                <el-tag v-for="feature in features" :key="feature" style="margin: 3px;">
                                    {{ feature }}
                                </el-tag>
                            </div>
                        </div>
                    </div>
                    
                    <!-- å³ä¾§ï¼šäººè„¸åº“ç®¡ç† -->
                    <div class="face-library-panel">
                        <h3 style="margin: 0 0 20px 0; color: #333;">äººè„¸åº“ç®¡ç†</h3>
                        
                        <!-- ä¸Šä¼ åŒºåŸŸ -->
                        <div 
                            class="upload-area"
                            @click="$refs.fileInput.click()"
                            @dragover.prevent="handleDragOver"
                            @dragleave.prevent="handleDragLeave"
                            @drop.prevent="handleDrop"
                            :class="{ dragover: isDragging }"
                        >
                            <div style="font-size: 48px; color: #909399; margin-bottom: 10px;">
                                æ–‡ä»¶å¤¹
                            </div>
                            <div style="color: #606266; margin-bottom: 10px;">
                                ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ äººè„¸ç…§ç‰‡
                            </div>
                            <div style="color: #909399; font-size: 12px;">
                                æ”¯æŒ JPGã€PNG æ ¼å¼
                            </div>
                        </div>
                        
                        <input 
                            ref="fileInput" 
                            type="file" 
                            accept="image/*" 
                            multiple
                            style="display: none"
                            @change="handleFileSelect"
                        >
                        
                        <!-- æ‰¹é‡æ“ä½œ -->
                                                    <div style="margin: 15px 0; display: flex; gap: 10px; flex-wrap: wrap;">
                                <el-button 
                                    size="small" 
                                    type="primary"
                                    @click="importLibrary"
                                >
                                    å¯¼å…¥æ•°æ®
                                </el-button>
                                <el-button 
                                    size="small" 
                                    type="info"
                                    @click="exportLibrary"
                                    :disabled="faceLibrary.length === 0"
                                >
                                    å¯¼å‡ºJSON
                                </el-button>
                                <el-button 
                                    size="small" 
                                    type="success"
                                    @click="exportImages"
                                    :disabled="faceLibrary.length === 0"
                                >
                                    å¯¼å‡ºå›¾ç‰‡
                                </el-button>
                                <el-button 
                                    size="small" 
                                    type="warning"
                                    @click="clearLibrary"
                                    :disabled="faceLibrary.length === 0"
                                >
                                    æ¸…ç©ºäººè„¸åº“
                                </el-button>
                            </div>
                            
                            <!-- é«˜çº§æ“ä½œ -->
                            <div style="margin: 15px 0; border-top: 1px solid #e0e0e0; padding-top: 15px;">
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <el-button 
                                        size="small" 
                                        type="success"
                                        @click="showStorageUsage"
                                    >
                                        å­˜å‚¨ä½¿ç”¨æƒ…å†µ
                                    </el-button>
                                    <el-button 
                                        size="small" 
                                        type="danger"
                                        @click="clearAllCache"
                                    >
                                        æ¸…é™¤æ‰€æœ‰ç¼“å­˜
                                    </el-button>
                                </div>
                                <div style="margin-top: 8px; font-size: 11px; color: #999; line-height: 1.4;">
                                    "æ¸…é™¤æ‰€æœ‰ç¼“å­˜"å°†å½»åº•åˆ é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®ï¼ŒåŒ…æ‹¬äººè„¸åº“ã€è®¾ç½®å’Œç¼“å­˜ï¼Œæ“ä½œä¸å¯æ’¤é”€
                                </div>
                            </div>
                        
                        <!-- äººè„¸åº“å±•ç¤º -->
                        <div v-if="faceLibrary.length === 0" style="text-align: center; color: #909399; padding: 40px 0;">
                            æš‚æ— äººè„¸æ•°æ®<br>
                            <small>è¯·ä¸Šä¼ ç…§ç‰‡æˆ–ä»æ‘„åƒå¤´æ·»åŠ </small>
                        </div>
                        
                        <div v-else class="face-grid">
                            <div 
                                v-for="(face, index) in faceLibrary" 
                                :key="face.id"
                                class="face-card"
                                :class="{ matched: isMatched(face.id) }"
                            >
                                <button 
                                    class="delete-btn"
                                    @click="removeFace(index)"
                                    title="åˆ é™¤"
                                >
                                    Ã—
                                </button>
                                
                                <img :src="face.image" class="face-image" :alt="face.name">
                                <div class="face-name">{{ face.name }}</div>
                                <div style="font-size: 11px; color: #909399;">
                                    {{ new Date(face.timestamp).toLocaleDateString() }}
                                </div>
                                
                                <div 
                                    v-if="isMatched(face.id)" 
                                    class="confidence-badge"
                                    :title="`åŒ¹é…åº¦: ${getMatchConfidence(face.id)}%`"
                                >
                                    {{ getMatchConfidence(face.id) }}%
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- æ·»åŠ äººè„¸å¯¹è¯æ¡† -->
        <el-dialog 
            v-model="showAddDialog" 
            title="æ·»åŠ åˆ°äººè„¸åº“"
            width="500px"
            center
        >
            <div style="text-align: center;">
                <canvas 
                    ref="captureCanvas" 
                    width="300" 
                    height="300" 
                    style="border: 2px solid #e0e0e0; border-radius: 10px; margin-bottom: 20px; max-width: 250px; max-height: 250px;"
                ></canvas>
                
                <el-form label-width="80px">
                    <el-form-item label="å§“å:">
                        <el-input 
                            v-model="newFaceName" 
                            placeholder="è¯·è¾“å…¥å§“å"
                            maxlength="20"
                            show-word-limit
                        />
                    </el-form-item>
                    <el-form-item label="å¤‡æ³¨:">
                        <el-input 
                            v-model="newFaceNote" 
                            placeholder="å¯é€‰å¤‡æ³¨ä¿¡æ¯"
                            maxlength="50"
                            show-word-limit
                        />
                    </el-form-item>
                </el-form>
            </div>
            
            <template #footer>
                <el-button @click="showAddDialog = false">å–æ¶ˆ</el-button>
                <el-button type="primary" @click="confirmAddFace" :disabled="!newFaceName.trim()">
                    æ·»åŠ åˆ°äººè„¸åº“
                </el-button>
            </template>
        </el-dialog>
    </div>

    <script>
        const { createApp, ref, computed, onMounted, onUnmounted, watch } = Vue
        const { ElMessage, ElMessageBox } = ElementPlus
        
        createApp({
            setup() {
                // åŸºç¡€çŠ¶æ€
                const videoRef = ref(null)
                const canvasRef = ref(null)
                const captureCanvas = ref(null)
                const fileInput = ref(null)
                
                const isRunning = ref(false)
                const isDetecting = ref(true)
                const isLoading = ref(false)
                const modelsLoaded = ref(false)
                const comparisonMode = ref(false)
                
                // æ£€æµ‹æ•°æ®
                const faceData = ref([])
                const matchedFaces = ref([])
                const stream = ref(null)
                const detectionTimer = ref(null)
                
                // äººè„¸åº“
                const faceLibrary = ref([])
                const faceMatcher = ref(null)
                const faceDB = ref(null)
                
                // è®¾ç½®
                const recognitionThreshold = ref(0.6)
                const detectionInterval = ref(200)
                const showLandmarks = ref(true)
                const showExpressions = ref(true)
                
                // æ£€æµ‹å‚æ•°
                const detectionScore = ref(0.5)
                const inputSize = ref(416)
                const targetFPS = ref(30)
                
                // ç»Ÿè®¡ä¿¡æ¯
                const detectionCount = ref(0)
                
                // æµè§ˆå™¨æ”¯æŒæ£€æµ‹
                const browserSupport = ref(false)
                
                // UI çŠ¶æ€
                const showAddDialog = ref(false)
                const newFaceName = ref('')
                const newFaceNote = ref('')
                const currentCapturedFace = ref(null)
                const isDragging = ref(false)
                
                // æ€§èƒ½ç»Ÿè®¡
                const fps = ref(0)
                const fpsCounter = ref(0)
                const lastFpsUpdate = ref(Date.now())
                
                // ç”Ÿå‘½å‘¨æœŸ
                onMounted(async () => {
                    // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
                    checkBrowserSupport()
                    
                    // åˆå§‹åŒ–æ•°æ®åº“
                    faceDB.value = window.faceDB || new FaceDBManager()
                    await faceDB.value.init()
                    
                    // åŠ è½½æ¨¡å‹å’Œäººè„¸åº“
                    await loadModels()
                    await loadFaceLibrary()
                })
                
                onUnmounted(() => {
                    cleanup()
                })
                
                // ç›‘å¬è®¾ç½®å˜åŒ–
                watch(detectionInterval, () => {
                    if (isDetecting.value) {
                        stopDetection()
                        startDetection()
                    }
                })
                
                watch(recognitionThreshold, () => {
                    updateFaceMatcher()
                })
                
                watch(faceLibrary, () => {
                    updateFaceMatcher()
                }, { deep: true })
                
                // è®¡ç®—å±æ€§
                const isMatched = computed(() => {
                    return (faceId) => matchedFaces.value.some(match => match.faceId === faceId)
                })
                
                const getMatchConfidence = computed(() => {
                    return (faceId) => {
                        const match = matchedFaces.value.find(m => m.faceId === faceId)
                        return match ? Math.round(match.confidence * 100) : 0
                    }
                })
                
                const averageConfidence = computed(() => {
                    if (faceData.value.length === 0) return 0
                    const total = faceData.value.reduce((sum, face) => 
                        sum + face.detection.score, 0
                    )
                    return ((total / faceData.value.length) * 100).toFixed(1)
                })
                
                const features = ref([
                    'å®æ—¶äººè„¸æ£€æµ‹',
                    '68ä¸ªå…³é”®ç‚¹',
                    '7ç§è¡¨æƒ…è¯†åˆ«', 
                    'å¹´é¾„æ€§åˆ«é¢„æµ‹',
                    'å¤šäººè„¸æ£€æµ‹',
                    'äººè„¸åº“ç®¡ç†',
                    'å®æ—¶è¯†åˆ«å¯¹æ¯”',
                    'æ•°æ®æŒä¹…åŒ–'
                ])
                
                // æµè§ˆå™¨æ”¯æŒæ£€æµ‹
                const checkBrowserSupport = () => {
                    browserSupport.value = !!(
                        navigator.mediaDevices && 
                        navigator.mediaDevices.getUserMedia &&
                        document.createElement('canvas').getContext('webgl')
                    )
                }
                
                // è¡¨æƒ…æ ‡ç­¾æ˜ å°„
                const getExpressionLabel = (expression) => {
                    const labels = {
                        neutral: 'ä¸­æ€§',
                        happy: 'å¼€å¿ƒ',
                        sad: 'æ‚²ä¼¤',
                        angry: 'æ„¤æ€’',
                        fearful: 'ææƒ§',
                        disgusted: 'åŒæ¶',
                        surprised: 'æƒŠè®¶'
                    }
                    return labels[expression] || expression
                }
                
                // æ¨¡å‹åŠ è½½
                const loadModels = async () => {
                    isLoading.value = true
                    
                    try {
                        const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.12/model'
                        
                        await Promise.all([
                            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                            faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                            faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
                            faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL),
                            faceapi.nets.ageGenderNet.loadFromUri(MODEL_URL)
                        ])
                        
                        modelsLoaded.value = true
                        ElMessage.success('äººè„¸è¯†åˆ«æ¨¡å‹åŠ è½½å®Œæˆ')
                    } catch (error) {
                        console.error('æ¨¡å‹åŠ è½½å¤±è´¥:', error)
                        ElMessage.error('æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥')
                    } finally {
                        isLoading.value = false
                    }
                }
                
                // æ‘„åƒå¤´æ§åˆ¶
                const startCamera = async () => {
                    if (!modelsLoaded.value) {
                        ElMessage.warning('æ¨¡å‹å°šæœªåŠ è½½å®Œæˆ')
                        return
                    }
                    
                    try {
                        stream.value = await navigator.mediaDevices.getUserMedia({
                            video: { width: 640, height: 480, facingMode: 'user' },
                            audio: false
                        })
                        
                        videoRef.value.srcObject = stream.value
                        
                        videoRef.value.addEventListener('loadedmetadata', () => {
                            isRunning.value = true
                            isDetecting.value = true  // ç¡®ä¿æ£€æµ‹çŠ¶æ€ä¸ºå¼€å¯
                            startDetection()
                        })
                        
                        ElMessage.success('æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ')
                    } catch (error) {
                        ElMessage.error('æ‘„åƒå¤´è®¿é—®å¤±è´¥: ' + error.message)
                    }
                }
                
                const stopCamera = () => {
                    cleanup()
                    isRunning.value = false
                    isDetecting.value = false
                    comparisonMode.value = false
                    faceData.value = []
                    matchedFaces.value = []
                    fps.value = 0
                    ElMessage.info('æ‘„åƒå¤´å·²åœæ­¢')
                }
                
                // æ£€æµ‹æ§åˆ¶
                const startDetection = () => {
                    if (!isDetecting.value) return
                    
                    detectionTimer.value = setInterval(async () => {
                        await detectFaces()
                        updateFPS()
                    }, detectionInterval.value)
                }
                
                const stopDetection = () => {
                    if (detectionTimer.value) {
                        clearInterval(detectionTimer.value)
                        detectionTimer.value = null
                    }
                }
                
                // äººè„¸æ£€æµ‹
                const detectFaces = async () => {
                    const video = videoRef.value
                    const canvas = canvasRef.value
                    
                    if (!video || !canvas || !modelsLoaded.value) return
                    
                    try {
                        const options = new faceapi.TinyFaceDetectorOptions({
                            inputSize: inputSize.value,
                            scoreThreshold: detectionScore.value
                        })
                        
                        // åŸºç¡€æ£€æµ‹ï¼ˆå§‹ç»ˆå¯ç”¨ï¼‰
                        let detections = await faceapi
                            .detectAllFaces(video, options)
                            .withFaceLandmarks()
                            .withFaceExpressions()
                            .withAgeAndGender()
                        
                        // å¦‚æœéœ€è¦äººè„¸è¯†åˆ«åŠŸèƒ½ï¼Œæ·»åŠ æè¿°ç¬¦
                        if (comparisonMode.value && detections.length > 0) {
                            try {
                                detections = await faceapi
                                    .detectAllFaces(video, options)
                                    .withFaceLandmarks()
                                    .withFaceDescriptors()
                                    .withFaceExpressions()
                                    .withAgeAndGender()
                            } catch (descriptorError) {
                                console.warn('æè¿°ç¬¦æå–å¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€æ£€æµ‹:', descriptorError)
                                // ç»§ç»­ä½¿ç”¨åŸºç¡€æ£€æµ‹ç»“æœ
                            }
                        }
                        
                        // æ¸…é™¤ç”»å¸ƒ
                        const ctx = canvas.getContext('2d')
                        ctx.clearRect(0, 0, canvas.width, canvas.height)
                        
                        // æ›´æ–°æ£€æµ‹æ•°æ®
                        faceData.value = detections.map(detection => ({
                            detection: detection.detection,
                            landmarks: detection.landmarks,
                            descriptor: detection.descriptor || null,
                            expressions: detection.expressions,
                            age: detection.age,
                            gender: detection.gender
                        }))
                        
                        // äººè„¸è¯†åˆ«å¯¹æ¯”
                        if (comparisonMode.value && faceMatcher.value && detections.some(d => d.descriptor)) {
                            performFaceRecognition(detections)
                        } else {
                            matchedFaces.value = []
                        }
                        
                        // ç»˜åˆ¶ç»“æœ
                        drawDetections(detections, canvas)
                        
                        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                        detectionCount.value++
                        
                    } catch (error) {
                        console.error('æ£€æµ‹å¤±è´¥:', error)
                    }
                }
                
                // äººè„¸è¯†åˆ«å¯¹æ¯”
                const performFaceRecognition = (detections) => {
                    const matches = []
                    
                    detections.forEach((detection, index) => {
                        if (detection.descriptor && faceMatcher.value) {
                            try {
                                const bestMatch = faceMatcher.value.findBestMatch(detection.descriptor)
                                
                                if (bestMatch.distance < recognitionThreshold.value) {
                                    const faceInLibrary = faceLibrary.value.find(f => f.name === bestMatch.label)
                                    if (faceInLibrary) {
                                        matches.push({
                                            faceId: faceInLibrary.id,
                                            name: bestMatch.label,
                                            distance: bestMatch.distance,
                                            confidence: 1 - bestMatch.distance,
                                            faceImage: faceInLibrary.image,
                                            detectionIndex: index
                                        })
                                    }
                                }
                            } catch (error) {
                                console.warn('äººè„¸åŒ¹é…å¤±è´¥:', error)
                            }
                        }
                    })
                    
                    matchedFaces.value = matches
                }
                
                // ç»˜åˆ¶æ£€æµ‹ç»“æœ
                const drawDetections = (detections, canvas) => {
                    const ctx = canvas.getContext('2d')
                    
                    detections.forEach((detection, index) => {
                        const { x, y, width, height } = detection.detection.box
                        
                        // æ£€æŸ¥æ˜¯å¦æœ‰åŒ¹é…
                        const match = matchedFaces.value.find(m => m.detectionIndex === index)
                        const isMatched = !!match
                        
                        // ç»˜åˆ¶äººè„¸æ¡†
                        ctx.strokeStyle = isMatched ? '#67c23a' : '#00ff00'
                        ctx.lineWidth = isMatched ? 4 : 3
                        ctx.strokeRect(x, y, width, height)
                        
                        // ç»˜åˆ¶æ ‡ç­¾
                        const score = (detection.detection.score * 100).toFixed(1)
                        let label = `äººè„¸ ${index + 1} (${score}%)`
                        
                        if (isMatched) {
                            label = `${match.name} (${(match.confidence * 100).toFixed(1)}%)`
                        }
                        
                        ctx.font = 'bold 16px Arial'
                        const textWidth = ctx.measureText(label).width
                        
                        ctx.fillStyle = isMatched ? 'rgba(103, 194, 58, 0.9)' : 'rgba(0, 255, 0, 0.8)'
                        ctx.fillRect(x, y - 30, textWidth + 10, 25)
                        
                        ctx.fillStyle = 'white'
                        ctx.fillText(label, x + 5, y - 10)
                        
                        // ç»˜åˆ¶å¹´é¾„æ€§åˆ«ä¿¡æ¯
                        if (detection.age && detection.gender) {
                            const ageText = `å¹´é¾„: ${Math.round(detection.age)}å²`
                            const genderText = `æ€§åˆ«: ${detection.gender === 'male' ? 'ç”·' : 'å¥³'}`
                            const genderConfidence = Math.round(detection.genderProbability * 100)
                            
                            ctx.font = '12px Arial'
                            const ageWidth = ctx.measureText(ageText).width
                            const genderWidth = ctx.measureText(genderText).width
                            const maxWidth = Math.max(ageWidth, genderWidth)
                            
                            // å¹´é¾„ä¿¡æ¯
                            ctx.fillStyle = 'rgba(255, 165, 0, 0.8)'
                            ctx.fillRect(x, y + height + 5, ageWidth + 8, 18)
                            ctx.fillStyle = 'white'
                            ctx.fillText(ageText, x + 4, y + height + 18)
                            
                            // æ€§åˆ«ä¿¡æ¯
                            ctx.fillStyle = 'rgba(255, 20, 147, 0.8)'
                            ctx.fillRect(x, y + height + 25, genderWidth + 8, 18)
                            ctx.fillStyle = 'white'
                            ctx.fillText(genderText, x + 4, y + height + 38)
                            
                            // æ€§åˆ«ç½®ä¿¡åº¦
                            if (genderConfidence < 80) {
                                const confidenceText = `ç½®ä¿¡åº¦: ${genderConfidence}%`
                                ctx.font = '10px Arial'
                                const confWidth = ctx.measureText(confidenceText).width
                                ctx.fillStyle = 'rgba(255, 0, 0, 0.7)'
                                ctx.fillRect(x, y + height + 45, confWidth + 6, 14)
                                ctx.fillStyle = 'white'
                                ctx.fillText(confidenceText, x + 3, y + height + 55)
                            }
                        }
                        
                        // ç»˜åˆ¶å…³é”®ç‚¹
                        if (showLandmarks.value && detection.landmarks) {
                            ctx.fillStyle = isMatched ? '#67c23a' : '#ff0000'
                            detection.landmarks.positions.forEach(point => {
                                ctx.beginPath()
                                ctx.arc(point.x, point.y, 2, 0, 2 * Math.PI)
                                ctx.fill()
                            })
                        }
                        
                        // ç»˜åˆ¶è¡¨æƒ…ä¿¡æ¯
                        if (showExpressions.value && detection.expressions) {
                            const expressions = Object.entries(detection.expressions)
                                .sort(([,a], [,b]) => b - a)
                                .slice(0, 2) // æ˜¾ç¤ºå‰2ä¸ªè¡¨æƒ…
                            
                            expressions.forEach(([expression, confidence], i) => {
                                if (confidence > 0.3) { // åªæ˜¾ç¤ºç½®ä¿¡åº¦è¾ƒé«˜çš„è¡¨æƒ…
                                    const expressionText = `${getExpressionLabel(expression)}: ${Math.round(confidence * 100)}%`
                                    
                                    ctx.font = '12px Arial'
                                    const textWidth = ctx.measureText(expressionText).width
                                    const yPos = y + height + (detection.age && detection.gender ? 65 : 20) + i * 20
                                    
                                    ctx.fillStyle = 'rgba(0, 0, 255, 0.8)'
                                    ctx.fillRect(x, yPos - 15, textWidth + 8, 18)
                                    
                                    ctx.fillStyle = 'white'
                                    ctx.fillText(expressionText, x + 4, yPos)
                                }
                            })
                        }
                    })
                }
                
                // äººè„¸åº“ç®¡ç†
                const updateFaceMatcher = () => {
                    if (faceLibrary.value.length === 0) {
                        faceMatcher.value = null
                        console.log('ğŸ“š äººè„¸åº“ä¸ºç©ºï¼Œæ¸…é™¤äººè„¸åŒ¹é…å™¨')
                        return
                    }
                    
                    try {
                        // ä¸¥æ ¼éªŒè¯äººè„¸æè¿°ç¬¦
                        const facesWithValidDescriptors = faceLibrary.value.filter(face => {
                            if (!face.descriptor) {
                                console.log(`âš ï¸ äººè„¸ "${face.name}" ç¼ºå°‘æè¿°ç¬¦ï¼Œè·³è¿‡`)
                                return false
                            }
                            
                            // æ£€æŸ¥æè¿°ç¬¦ç±»å‹å’Œç»´åº¦
                            const isValidType = Array.isArray(face.descriptor) || face.descriptor instanceof Float32Array
                            if (!isValidType) {
                                console.warn(`âŒ äººè„¸ "${face.name}" æè¿°ç¬¦ç±»å‹æ— æ•ˆ:`, typeof face.descriptor)
                                return false
                            }
                            
                            if (face.descriptor.length !== 128) {
                                console.warn(`âŒ äººè„¸ "${face.name}" æè¿°ç¬¦ç»´åº¦é”™è¯¯: ${face.descriptor.length}ï¼ŒæœŸæœ›128ç»´`)
                                return false
                            }
                            
                            // æ£€æŸ¥æ•°å€¼æœ‰æ•ˆæ€§
                            const hasValidNumbers = Array.from(face.descriptor).every(val => 
                                typeof val === 'number' && !isNaN(val) && isFinite(val)
                            )
                            
                            if (!hasValidNumbers) {
                                console.warn(`âŒ äººè„¸ "${face.name}" æè¿°ç¬¦åŒ…å«æ— æ•ˆæ•°å€¼`)
                                return false
                            }
                            
                            console.log(`âœ… äººè„¸ "${face.name}" æè¿°ç¬¦éªŒè¯é€šè¿‡`)
                            return true
                        })
                        
                        if (facesWithValidDescriptors.length === 0) {
                            faceMatcher.value = null
                            console.log('âš ï¸ æ²¡æœ‰æœ‰æ•ˆçš„äººè„¸æè¿°ç¬¦ï¼Œæ— æ³•åˆ›å»ºäººè„¸åŒ¹é…å™¨')
                            return
                        }
                        
                        const labeledDescriptors = facesWithValidDescriptors.map(face => {
                            // ç¡®ä¿æè¿°ç¬¦æ˜¯Float32Arrayæ ¼å¼
                            const descriptor = face.descriptor instanceof Float32Array 
                                ? face.descriptor 
                                : new Float32Array(face.descriptor)
                            
                            return new faceapi.LabeledFaceDescriptors(
                                face.name,
                                [descriptor]
                            )
                        })
                        
                        faceMatcher.value = new faceapi.FaceMatcher(labeledDescriptors, recognitionThreshold.value)
                        console.log(`âœ… äººè„¸åŒ¹é…å™¨å·²æ›´æ–°ï¼ŒåŒ…å« ${labeledDescriptors.length} ä¸ªå¯è¯†åˆ«çš„äººè„¸`)
                        console.log(`ğŸ“Š äººè„¸åº“ç»Ÿè®¡ï¼šæ€»è®¡ ${faceLibrary.value.length} ä¸ªï¼Œå¯è¯†åˆ« ${facesWithValidDescriptors.length} ä¸ª`)
                    } catch (error) {
                        console.error('âŒ æ›´æ–°äººè„¸åŒ¹é…å™¨å¤±è´¥:', error)
                        console.error('é”™è¯¯è¯¦æƒ…:', error.message)
                        faceMatcher.value = null
                    }
                }
                
                const captureAndAdd = async () => {
                    console.log('ğŸ¯ å¼€å§‹æ•è·äººè„¸ï¼Œå½“å‰æ£€æµ‹åˆ°çš„äººè„¸æ•°é‡:', faceData.value.length)
                    
                    if (faceData.value.length === 0) {
                        ElMessage.warning('æœªæ£€æµ‹åˆ°äººè„¸')
                        return
                    }
                    
                    // é€‰æ‹©ç½®ä¿¡åº¦æœ€é«˜çš„äººè„¸
                    const bestFace = faceData.value.reduce((best, current) => 
                        current.detection.score > best.detection.score ? current : best
                    )
                    
                    console.log('é€‰æ‹©çš„æœ€ä½³äººè„¸:', {
                        score: bestFace.detection.score,
                        hasDescriptor: !!bestFace.descriptor,
                        box: bestFace.detection.box
                    })
                    
                    // æ£€æŸ¥è§†é¢‘å…ƒç´ 
                    const video = videoRef.value
                    
                    console.log('è§†é¢‘å…ƒç´ çŠ¶æ€:', {
                        video: !!video,
                        videoReady: video && video.readyState >= 2
                    })
                    
                    if (!video) {
                        ElMessage.error('è§†é¢‘å…ƒç´ æœªæ‰¾åˆ°')
                        return
                    }
                    
                    if (video.readyState < 2) {
                        ElMessage.warning('è§†é¢‘å°šæœªå‡†å¤‡å°±ç»ªï¼Œè¯·ç¨åå†è¯•')
                        return
                    }
                    
                    // å…ˆåˆ›å»ºä¸´æ—¶canvasæ¥æ•è·äººè„¸å›¾åƒ
                    const tempCanvas = document.createElement('canvas')
                    tempCanvas.width = 300  // å¢å¤§å°ºå¯¸
                    tempCanvas.height = 300
                    const ctx = tempCanvas.getContext('2d')
                    
                    const { x, y, width, height } = bestFace.detection.box
                    
                    // æ·»åŠ paddingï¼Œæ‰©å±•æ•è·åŒºåŸŸ
                    const padding = Math.max(width, height) * 0.3  // 30%çš„padding
                    const expandedX = Math.max(0, x - padding)
                    const expandedY = Math.max(0, y - padding)
                    const expandedWidth = Math.min(video.videoWidth - expandedX, width + padding * 2)
                    const expandedHeight = Math.min(video.videoHeight - expandedY, height + padding * 2)
                    
                    console.log('ğŸ–¼ï¸ å›¾åƒæ•è·å‚æ•°:', {
                        original: { x, y, width, height },
                        expanded: { x: expandedX, y: expandedY, width: expandedWidth, height: expandedHeight },
                        padding: padding,
                        videoSize: { width: video.videoWidth, height: video.videoHeight }
                    })
                    
                    const scale = Math.min(300 / expandedWidth, 300 / expandedHeight)
                    const scaledWidth = expandedWidth * scale
                    const scaledHeight = expandedHeight * scale
                    
                    ctx.clearRect(0, 0, 300, 300)
                    ctx.drawImage(
                        video,
                        expandedX, expandedY, expandedWidth, expandedHeight,
                        (300 - scaledWidth) / 2, (300 - scaledHeight) / 2, scaledWidth, scaledHeight
                    )
                    
                    console.log('âœ… äººè„¸æ•è·æˆåŠŸ:', {
                        scale,
                        scaledWidth,
                        scaledHeight,
                        hasDescriptor: !!bestFace.descriptor
                    })
                    
                                            // ä¸¥æ ¼çš„æè¿°ç¬¦æå–å’ŒéªŒè¯é€»è¾‘
                         let descriptor = bestFace.descriptor
                         
                         // éªŒè¯ç°æœ‰æè¿°ç¬¦çš„æœ‰æ•ˆæ€§
                         if (descriptor) {
                             if (!Array.isArray(descriptor) && !(descriptor instanceof Float32Array)) {
                                 console.warn('ç°æœ‰æè¿°ç¬¦æ ¼å¼æ— æ•ˆï¼Œé‡æ–°æå–')
                                 descriptor = null
                             } else if (descriptor.length !== 128) {
                                 console.warn(`ç°æœ‰æè¿°ç¬¦ç»´åº¦é”™è¯¯ï¼š${descriptor.length}ï¼ŒæœŸæœ›128ç»´ï¼Œé‡æ–°æå–`)
                                 descriptor = null
                             } else {
                                 // æ£€æŸ¥æ•°å€¼æœ‰æ•ˆæ€§
                                 const hasValidNumbers = Array.from(descriptor).every(val => 
                                     typeof val === 'number' && !isNaN(val) && isFinite(val)
                                 )
                                 if (!hasValidNumbers) {
                                     console.warn('ç°æœ‰æè¿°ç¬¦åŒ…å«æ— æ•ˆæ•°å€¼ï¼Œé‡æ–°æå–')
                                     descriptor = null
                                 } else {
                                     console.log('âœ… ç°æœ‰æè¿°ç¬¦éªŒè¯é€šè¿‡ï¼Œ128ç»´æœ‰æ•ˆæè¿°ç¬¦')
                                 }
                             }
                         }
                         
                         // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæè¿°ç¬¦ï¼Œå°è¯•é‡æ–°æå–
                         if (!descriptor) {
                             console.log('ğŸ”„ å¼€å§‹é‡æ–°æå–æè¿°ç¬¦...')
                             
                             // æ£€æŸ¥ Face Recognition æ¨¡å‹æ˜¯å¦å·²åŠ è½½
                             if (!modelsLoaded.value) {
                                 console.error('âŒ æ¨¡å‹æœªåŠ è½½ï¼Œæ— æ³•æå–æè¿°ç¬¦')
                                 ElMessage.error('äººè„¸è¯†åˆ«æ¨¡å‹æœªåŠ è½½å®Œæˆï¼Œè¯·ç­‰å¾…æ¨¡å‹åŠ è½½åå†è¯•')
                             } else {
                                 console.log('âœ… æ¨¡å‹å·²åŠ è½½ï¼Œå¼€å§‹é‡æ–°æå–æè¿°ç¬¦')
                                 
                                 // ä¼˜åŒ–çš„å‚æ•°ç»„åˆï¼ŒæŒ‰æˆåŠŸç‡æ’åº
                                 const detectionOptions = [
                                     new faceapi.TinyFaceDetectorOptions({ inputSize: 416, scoreThreshold: 0.4 }),
                                     new faceapi.TinyFaceDetectorOptions({ inputSize: 512, scoreThreshold: 0.3 }),
                                     new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.5 }),
                                     new faceapi.TinyFaceDetectorOptions({ inputSize: 608, scoreThreshold: 0.2 })
                                 ]
                                 
                                 for (let i = 0; i < detectionOptions.length && !descriptor; i++) {
                                     try {
                                         console.log(`ğŸ” å°è¯•å‚æ•°ç»„åˆ ${i + 1}/${detectionOptions.length}:`, {
                                             inputSize: detectionOptions[i].inputSize,
                                             scoreThreshold: detectionOptions[i].scoreThreshold
                                         })
                                         
                                         const faceDetection = await faceapi
                                             .detectSingleFace(tempCanvas, detectionOptions[i])
                                             .withFaceLandmarks()
                                             .withFaceDescriptor()
                                         
                                         if (faceDetection && faceDetection.descriptor) {
                                             const extractedDescriptor = Array.from(faceDetection.descriptor)
                                             
                                             // ä¸¥æ ¼éªŒè¯æå–çš„æè¿°ç¬¦
                                             if (extractedDescriptor.length === 128) {
                                                 const hasValidNumbers = extractedDescriptor.every(val => 
                                                     typeof val === 'number' && !isNaN(val) && isFinite(val)
                                                 )
                                                 
                                                 if (hasValidNumbers) {
                                                     descriptor = extractedDescriptor
                                                     console.log(`âœ… å‚æ•°ç»„åˆ ${i + 1} æˆåŠŸæå–æœ‰æ•ˆçš„128ç»´æè¿°ç¬¦`)
                                                     console.log(`ğŸ“Š æè¿°ç¬¦ç»Ÿè®¡: æœ€å°å€¼=${Math.min(...descriptor).toFixed(4)}, æœ€å¤§å€¼=${Math.max(...descriptor).toFixed(4)}`)
                                                     break
                                                 } else {
                                                     console.warn(`âš ï¸ å‚æ•°ç»„åˆ ${i + 1} æå–çš„æè¿°ç¬¦åŒ…å«æ— æ•ˆæ•°å€¼`)
                                                 }
                                             } else {
                                                 console.warn(`âš ï¸ å‚æ•°ç»„åˆ ${i + 1} æå–çš„æè¿°ç¬¦ç»´åº¦é”™è¯¯ï¼š${extractedDescriptor.length}`)
                                             }
                                         } else {
                                             console.warn(`âš ï¸ å‚æ•°ç»„åˆ ${i + 1} æœªæ£€æµ‹åˆ°äººè„¸æˆ–æ— æ³•æå–æè¿°ç¬¦`)
                                         }
                                     } catch (error) {
                                         console.error(`âŒ å‚æ•°ç»„åˆ ${i + 1} å‡ºé”™:`, error.message)
                                     }
                                 }
                                 
                                 if (!descriptor) {
                                     console.error('âŒ æ‰€æœ‰å‚æ•°ç»„åˆéƒ½æ— æ³•æå–æœ‰æ•ˆçš„128ç»´æè¿°ç¬¦')
                                     console.log('ğŸ’¡ å»ºè®®ï¼š')
                                     console.log('  1. ç¡®ä¿äººè„¸æ¸…æ™°ã€å…‰çº¿å……è¶³')
                                     console.log('  2. ä¿æŒäººè„¸æ­£é¢æœå‘æ‘„åƒå¤´')
                                     console.log('  3. é¿å…é®æŒ¡ï¼ˆçœ¼é•œã€å¸½å­ã€å£ç½©ç­‰ï¼‰')
                                     console.log('  4. ç¡®ä¿æ‘„åƒå¤´åˆ†è¾¨ç‡è¶³å¤Ÿ')
                                     ElMessage.warning('æ— æ³•æå–äººè„¸ç‰¹å¾ï¼Œè¯¥äººè„¸å°†ä»…ä½œä¸ºå›¾ç‰‡å­˜å‚¨ï¼Œæ— æ³•ç”¨äºè¯†åˆ«')
                                 }
                             }
                         }
                    
                    currentCapturedFace.value = {
                        detection: bestFace.detection,
                        descriptor: descriptor,
                        image: tempCanvas.toDataURL('image/jpeg', 0.9) // æé«˜å›¾ç‰‡è´¨é‡
                    }
                    
                    console.log('ğŸ”§ å¯¹è¯æ¡†çŠ¶æ€:', {
                        showAddDialog: showAddDialog.value,
                        currentCapturedFace: !!currentCapturedFace.value,
                        hasDescriptor: !!descriptor,
                        descriptorLength: descriptor ? descriptor.length : 'N/A'
                    })
                    
                    newFaceName.value = ''
                    newFaceNote.value = ''
                    showAddDialog.value = true
                    
                    // ç­‰å¾…å¯¹è¯æ¡†æ¸²æŸ“å®Œæˆåï¼Œå°†å›¾åƒç»˜åˆ¶åˆ°å¯¹è¯æ¡†ä¸­çš„canvas
                    Vue.nextTick(() => {
                        drawCapturedFaceToDialog()
                    })
                }
                
                const drawCapturedFaceToDialog = () => {
                    if (!currentCapturedFace.value || !currentCapturedFace.value.image) {
                        console.warn('âš ï¸ æ²¡æœ‰æ•è·çš„äººè„¸å›¾åƒ')
                        return
                    }
                    
                    const canvas = captureCanvas.value // è·å–å¯¹è¯æ¡†ä¸­çš„canvas
                    if (!canvas) {
                        console.warn('âš ï¸ å¯¹è¯æ¡†canvaså…ƒç´ æœªæ‰¾åˆ°ï¼Œå¯èƒ½å¯¹è¯æ¡†è¿˜æœªå®Œå…¨æ¸²æŸ“')
                        setTimeout(() => {
                            drawCapturedFaceToDialog()
                        }, 100)
                        return
                    }
                    
                    const ctx = canvas.getContext('2d')
                    if (!ctx) {
                        console.error('âŒ æ— æ³•è·å–å¯¹è¯æ¡†canvasä¸Šä¸‹æ–‡')
                        return
                    }
                    
                    const img = new Image()
                    img.onload = () => {
                        ctx.clearRect(0, 0, 300, 300)
                        ctx.drawImage(img, 0, 0, 300, 300)
                        console.log('âœ… äººè„¸å›¾åƒå·²ç»˜åˆ¶åˆ°å¯¹è¯æ¡†')
                    }
                    img.onerror = (error) => {
                        console.error('âŒ å›¾åƒåŠ è½½å¤±è´¥:', error)
                    }
                    img.src = currentCapturedFace.value.image
                }
                
                const confirmAddFace = async () => {
                    console.log('ğŸ’¾ å¼€å§‹ç¡®è®¤æ·»åŠ äººè„¸:', {
                        currentCapturedFace: !!currentCapturedFace.value,
                        newFaceName: newFaceName.value.trim(),
                        newFaceNote: newFaceNote.value.trim(),
                        hasDescriptor: !!(currentCapturedFace.value?.descriptor)
                    })
                    
                    if (!currentCapturedFace.value || !newFaceName.value.trim()) {
                        ElMessage.warning('è¯·è¾“å…¥å§“å')
                        return
                    }
                    
                    try {
                        const newFace = {
                            id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                            name: newFaceName.value.trim(),
                            note: newFaceNote.value.trim(),
                            image: currentCapturedFace.value.image,
                            descriptor: currentCapturedFace.value.descriptor ? Array.from(currentCapturedFace.value.descriptor) : null,
                            timestamp: new Date().toISOString()
                        }
                        
                        console.log('ğŸ“‹ å‡†å¤‡æ·»åŠ çš„äººè„¸æ•°æ®:', {
                            id: newFace.id,
                            name: newFace.name,
                            note: newFace.note,
                            hasImage: !!newFace.image,
                            hasDescriptor: !!newFace.descriptor,
                            descriptorLength: newFace.descriptor ? newFace.descriptor.length : 0
                        })
                        
                        // ä¿å­˜åˆ°IndexedDB
                        console.log('ğŸ—„ï¸ å¼€å§‹ä¿å­˜åˆ°IndexedDB...')
                        const savedFace = await faceDB.value.addFace(newFace)
                        
                        console.log('âœ… ä¿å­˜åˆ°æ•°æ®åº“æˆåŠŸ:', savedFace.id)
                        
                        // æ›´æ–°æœ¬åœ°äººè„¸åº“
                        faceLibrary.value.push(savedFace)
                        console.log('ğŸ“š æ›´æ–°æœ¬åœ°äººè„¸åº“ï¼Œå½“å‰æ•°é‡:', faceLibrary.value.length)
                        
                        showAddDialog.value = false
                        
                        // æ ¹æ®æ˜¯å¦æœ‰æè¿°ç¬¦ç»™å‡ºä¸åŒçš„æç¤º
                        if (savedFace.descriptor && savedFace.descriptor.length === 128) {
                            console.log('ğŸ¯ æ·»åŠ æˆåŠŸ - æ”¯æŒè¯†åˆ«')
                            ElMessage.success(`å·²æ·»åŠ  "${savedFace.name}" åˆ°äººè„¸åº“ï¼ˆæ”¯æŒè¯†åˆ«ï¼‰`)
                        } else {
                            console.log('ğŸ“¸ æ·»åŠ æˆåŠŸ - ä»…å­˜å‚¨')
                            ElMessage.warning(`å·²æ·»åŠ  "${savedFace.name}" åˆ°äººè„¸åº“ï¼ˆä»…å­˜å‚¨ï¼Œæ— æ³•è¯†åˆ«ï¼‰\nè¯·ç¡®ä¿æ‘„åƒå¤´æ¸…æ™°å¹¶é‡æ–°å°è¯•`)
                        }
                        
                        // éªŒè¯ä¿å­˜ç»“æœ
                        const allFaces = await faceDB.value.getAllFaces()
                        console.log('ğŸ” éªŒè¯ï¼šæ•°æ®åº“ä¸­çš„äººè„¸æ€»æ•°:', allFaces.length)
                        
                    } catch (error) {
                        console.error('âŒ æ·»åŠ äººè„¸å¤±è´¥:', error)
                        ElMessage.error('æ·»åŠ å¤±è´¥: ' + error.message)
                    }
                }
                
                // æ–‡ä»¶å¤„ç†
                const handleFileSelect = (event) => {
                    const files = Array.from(event.target.files)
                    processImageFiles(files)
                }
                
                const handleDrop = (event) => {
                    isDragging.value = false
                    const files = Array.from(event.dataTransfer.files)
                    processImageFiles(files.filter(file => file.type.startsWith('image/')))
                }
                
                const handleDragOver = () => {
                    isDragging.value = true
                }
                
                const handleDragLeave = () => {
                    isDragging.value = false
                }
                
                const processImageFiles = async (files) => {
                    if (files.length === 0) return
                    
                    if (!modelsLoaded.value) {
                        ElMessage.warning('æ¨¡å‹å°šæœªåŠ è½½å®Œæˆï¼Œè¯·ç¨åå†è¯•')
                        return
                    }
                    
                    const loading = ElMessage({
                        message: 'æ­£åœ¨å¤„ç†å›¾ç‰‡...',
                        type: 'info',
                        duration: 0
                    })
                    
                    let successCount = 0
                    let errorMessages = []
                    
                    try {
                        for (const file of files) {
                            try {
                                console.log(`ğŸ“¸ å¼€å§‹å¤„ç†å›¾ç‰‡: ${file.name}`)
                            await processImageFile(file)
                                successCount++
                                console.log(`âœ… æˆåŠŸå¤„ç†å›¾ç‰‡: ${file.name}`)
                            } catch (error) {
                                console.error(`âŒ å¤„ç†å›¾ç‰‡å¤±è´¥: ${file.name}`, error)
                                errorMessages.push(`${file.name}: ${error.message}`)
                        }
                        }
                        
                        loading.close()
                        
                        if (successCount > 0) {
                            ElMessage.success(`æˆåŠŸå¤„ç† ${successCount} å¼ å›¾ç‰‡`)
                        }
                        
                        if (errorMessages.length > 0) {
                            ElMessage.warning(`éƒ¨åˆ†å›¾ç‰‡å¤„ç†å¤±è´¥:\n${errorMessages.slice(0, 3).join('\n')}${errorMessages.length > 3 ? '\n...' : ''}`)
                        }
                    } catch (error) {
                        loading.close()
                        console.error('æ‰¹é‡å¤„ç†å›¾ç‰‡å¤±è´¥:', error)
                        ElMessage.error('å›¾ç‰‡å¤„ç†å¤±è´¥: ' + error.message)
                    }
                }
                
                const processImageFile = async (file) => {
                    return new Promise((resolve, reject) => {
                        const img = new Image()
                        const canvas = document.createElement('canvas')
                        const ctx = canvas.getContext('2d')
                        
                        img.onload = async () => {
                            // è°ƒæ•´å›¾ç‰‡å°ºå¯¸
                            const maxSize = 640
                            let { width, height } = img
                            
                            if (width > maxSize || height > maxSize) {
                                const ratio = Math.min(maxSize / width, maxSize / height)
                                width *= ratio
                                height *= ratio
                            }
                            
                            canvas.width = width
                            canvas.height = height
                            ctx.drawImage(img, 0, 0, width, height)
                            
                            try {
                                // å¤šç§æ£€æµ‹ç­–ç•¥ï¼Œä»å®½æ¾åˆ°ä¸¥æ ¼
                                const detectionOptions = [
                                    new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.3 }),
                                    new faceapi.TinyFaceDetectorOptions({ inputSize: 416, scoreThreshold: 0.4 }),
                                    new faceapi.TinyFaceDetectorOptions({ inputSize: 512, scoreThreshold: 0.5 }),
                                    new faceapi.TinyFaceDetectorOptions({ inputSize: 608, scoreThreshold: 0.6 })
                                ]
                                
                                let detection = null
                                
                                // å°è¯•ä¸åŒçš„æ£€æµ‹å‚æ•°
                                for (let i = 0; i < detectionOptions.length && !detection; i++) {
                                    try {
                                        console.log(`ğŸ” å°è¯•æ£€æµ‹å‚æ•° ${i + 1}/${detectionOptions.length}:`, {
                                            inputSize: detectionOptions[i].inputSize,
                                            scoreThreshold: detectionOptions[i].scoreThreshold,
                                            fileName: file.name
                                        })
                                        
                                        detection = await faceapi
                                            .detectSingleFace(canvas, detectionOptions[i])
                                    .withFaceLandmarks()
                                    .withFaceDescriptor()
                                
                                if (detection) {
                                            console.log(`âœ… å‚æ•°ç»„åˆ ${i + 1} æˆåŠŸæ£€æµ‹åˆ°äººè„¸:`, {
                                                score: detection.detection.score,
                                                box: detection.detection.box
                                            })
                                            break
                                        } else {
                                            console.log(`âš ï¸ å‚æ•°ç»„åˆ ${i + 1} æœªæ£€æµ‹åˆ°äººè„¸`)
                                        }
                                    } catch (error) {
                                        console.warn(`âŒ å‚æ•°ç»„åˆ ${i + 1} æ£€æµ‹å¤±è´¥:`, error.message)
                                    }
                                }
                                
                                if (detection) {
                                    // æå–äººè„¸åŒºåŸŸï¼ˆæ·»åŠ paddingï¼‰
                                    const { x, y, width: faceWidth, height: faceHeight } = detection.detection.box
                                    const faceCanvas = document.createElement('canvas')
                                    const faceCtx = faceCanvas.getContext('2d')
                                    
                                    faceCanvas.width = 300  // å¢å¤§è¾“å‡ºå°ºå¯¸
                                    faceCanvas.height = 300
                                    
                                    // æ·»åŠ paddingï¼Œæ‰©å±•äººè„¸åŒºåŸŸ
                                    const padding = Math.max(faceWidth, faceHeight) * 0.4  // 40%çš„padding
                                    const expandedX = Math.max(0, x - padding)
                                    const expandedY = Math.max(0, y - padding)
                                    const expandedWidth = Math.min(canvas.width - expandedX, faceWidth + padding * 2)
                                    const expandedHeight = Math.min(canvas.height - expandedY, faceHeight + padding * 2)
                                    
                                    console.log(`ğŸ“ äººè„¸åŒºåŸŸæ‰©å±• ${file.name}:`, {
                                        original: { x, y, width: faceWidth, height: faceHeight },
                                        expanded: { x: expandedX, y: expandedY, width: expandedWidth, height: expandedHeight },
                                        padding: padding
                                    })
                                    
                                    const scale = Math.min(300 / expandedWidth, 300 / expandedHeight)
                                    const scaledWidth = expandedWidth * scale
                                    const scaledHeight = expandedHeight * scale
                                    
                                    faceCtx.clearRect(0, 0, 300, 300)
                                    faceCtx.drawImage(
                                        canvas,
                                        expandedX, expandedY, expandedWidth, expandedHeight,
                                        (300 - scaledWidth) / 2, (300 - scaledHeight) / 2, scaledWidth, scaledHeight
                                    )
                                    
                                    const fileName = file.name.replace(/\.[^/.]+$/, "")
                                    const newFace = {
                                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                                        name: fileName,
                                        note: '',
                                        image: faceCanvas.toDataURL('image/jpeg', 0.9),
                                        descriptor: Array.from(detection.descriptor),
                                        timestamp: new Date().toISOString(),
                                        source: 'upload'  // æ ‡è®°æ•°æ®æ¥æº
                                    }
                                    
                                    // ä¿å­˜åˆ°IndexedDBæ•°æ®åº“
                                    const savedFace = await faceDB.value.addFace(newFace)
                                    faceLibrary.value.push(savedFace)
                                    resolve()
                                } else {
                                    reject(new Error(`æœªåœ¨å›¾ç‰‡ ${file.name} ä¸­æ£€æµ‹åˆ°äººè„¸ã€‚å»ºè®®ï¼šç¡®ä¿å›¾ç‰‡æ¸…æ™°ã€äººè„¸æ­£é¢ä¸”å æ¯”è¾ƒå¤§`))
                                }
                            } catch (error) {
                                console.error(`äººè„¸æ£€æµ‹å¤±è´¥ ${file.name}:`, error)
                                reject(new Error(`äººè„¸æ£€æµ‹å¤±è´¥: ${error.message}`))
                            }
                        }
                        
                        img.onerror = () => {
                            console.error(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${file.name}`)
                            reject(new Error(`å›¾ç‰‡åŠ è½½å¤±è´¥: ${file.name}`))
                        }
                        
                        try {
                        img.src = URL.createObjectURL(file)
                        } catch (error) {
                            console.error(`åˆ›å»ºå›¾ç‰‡URLå¤±è´¥: ${file.name}`, error)
                            reject(new Error(`åˆ›å»ºå›¾ç‰‡URLå¤±è´¥: ${error.message}`))
                        }
                    })
                }
                
                // å…¶ä»–åŠŸèƒ½
                const toggleComparison = () => {
                    comparisonMode.value = !comparisonMode.value
                    
                    if (comparisonMode.value && faceLibrary.value.length === 0) {
                        ElMessage.warning('äººè„¸åº“ä¸ºç©ºï¼Œè¯·å…ˆæ·»åŠ äººè„¸æ•°æ®')
                        comparisonMode.value = false
                        return
                    }
                    
                    ElMessage.info(comparisonMode.value ? 'äººè„¸è¯†åˆ«å·²å¼€å¯' : 'äººè„¸è¯†åˆ«å·²å…³é—­')
                }
                
                const removeFace = async (index) => {
                    try {
                        const face = faceLibrary.value[index]
                        await ElMessageBox.confirm(
                            `ç¡®å®šè¦åˆ é™¤ "${face.name}" å—ï¼Ÿ`,
                            'ç¡®è®¤åˆ é™¤',
                            { type: 'warning' }
                        )
                        
                        // ä»æ•°æ®åº“åˆ é™¤
                        await faceDB.value.deleteFace(face.id)
                        
                        // ä»æœ¬åœ°æ•°ç»„åˆ é™¤
                        faceLibrary.value.splice(index, 1)
                        ElMessage.success('åˆ é™¤æˆåŠŸ')
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('åˆ é™¤å¤±è´¥:', error)
                            ElMessage.error('åˆ é™¤å¤±è´¥: ' + error.message)
                        }
                    }
                }
                
                const clearLibrary = async () => {
                    try {
                        await ElMessageBox.confirm(
                            'ç¡®å®šè¦æ¸…ç©ºæ•´ä¸ªäººè„¸åº“å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼',
                            'ç¡®è®¤æ¸…ç©º',
                            { type: 'warning' }
                        )
                        
                        // æ¸…ç©ºæ•°æ®åº“
                        await faceDB.value.clearAllFaces()
                        
                        // æ¸…ç©ºæœ¬åœ°æ•°ç»„
                        faceLibrary.value = []
                        matchedFaces.value = []
                        ElMessage.success('äººè„¸åº“å·²æ¸…ç©º')
                    } catch (error) {
                        if (error !== 'cancel') {
                            console.error('æ¸…ç©ºå¤±è´¥:', error)
                            ElMessage.error('æ¸…ç©ºå¤±è´¥: ' + error.message)
                        }
                    }
                }
                
                const exportLibrary = async () => {
                    try {
                        // ä»æ•°æ®åº“è·å–æœ€æ–°æ•°æ®
                        const dbData = await faceDB.value.exportData()
                        
                        const blob = new Blob([JSON.stringify(dbData, null, 2)], { type: 'application/json' })
                        const url = URL.createObjectURL(blob)
                        const link = document.createElement('a')
                        link.href = url
                        link.download = `face-library-${new Date().toISOString().split('T')[0]}.json`
                        document.body.appendChild(link)
                        link.click()
                        document.body.removeChild(link)
                        URL.revokeObjectURL(url)
                        
                        ElMessage.success('äººè„¸åº“æ•°æ®å·²å¯¼å‡º')
                    } catch (error) {
                        console.error('å¯¼å‡ºå¤±è´¥:', error)
                        ElMessage.error('å¯¼å‡ºå¤±è´¥: ' + error.message)
                    }
                }
                
                // æ•°æ®æŒä¹…åŒ–å·²ç§»è‡³IndexedDB (loadFaceLibraryæ–¹æ³•åœ¨ä¸‹æ–¹)
                
                const updateFPS = () => {
                    fpsCounter.value++
                    const now = Date.now()
                    
                    if (now - lastFpsUpdate.value >= 1000) {
                        fps.value = fpsCounter.value
                        fpsCounter.value = 0
                        lastFpsUpdate.value = now
                    }
                }
                
                // å¯¼å‡ºå›¾ç‰‡ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
                const exportImages = async () => {
                    try {
                        if (faceLibrary.value.length === 0) {
                            ElMessage.warning('äººè„¸åº“ä¸ºç©ºï¼Œæ— æ³•å¯¼å‡ºå›¾ç‰‡')
                            return
                        }
                        
                        ElMessage.info('æ­£åœ¨é€ä¸ªä¸‹è½½äººè„¸å›¾ç‰‡...')
                        
                        // é€ä¸ªä¸‹è½½äººè„¸å›¾ç‰‡
                        faceLibrary.value.forEach((face, index) => {
                            if (face.image) {
                                setTimeout(() => {
                                    const link = document.createElement('a')
                                    link.href = face.image
                                const safeName = face.name.replace(/[^a-zA-Z0-9\u4e00-\u9fa5]/g, '_')
                                    link.download = `${safeName}_${face.id}.jpg`
                                    document.body.appendChild(link)
                                    link.click()
                                    document.body.removeChild(link)
                                }, index * 300) // æ¯300msä¸‹è½½ä¸€ä¸ªï¼Œé¿å…æµè§ˆå™¨é™åˆ¶
                            }
                        })
                        
                        setTimeout(() => {
                            ElMessage.success(`å·²å¼€å§‹ä¸‹è½½ ${faceLibrary.value.length} å¼ äººè„¸å›¾ç‰‡`)
                        }, 1000)
                        
                    } catch (error) {
                        console.error('å¯¼å‡ºå›¾ç‰‡å¤±è´¥:', error)
                        ElMessage.error('å¯¼å‡ºå›¾ç‰‡å¤±è´¥: ' + error.message)
                    }
                }
                
                // å¯¼å…¥äººè„¸åº“
                const importLibrary = async () => {
                    const input = document.createElement('input')
                    input.type = 'file'
                    input.accept = '.json'
                    
                    input.onchange = async (event) => {
                        const file = event.target.files[0]
                        if (!file) return
                        
                        const loading = ElMessage({
                            message: 'æ­£åœ¨å¯¼å…¥äººè„¸åº“...',
                            type: 'info',
                            duration: 0
                        })
                        
                        try {
                            const text = await file.text()
                            const data = JSON.parse(text)
                            
                            const results = await faceDB.value.importData(data)
                            
                            // é‡æ–°åŠ è½½äººè„¸åº“
                            await loadFaceLibrary()
                            
                            loading.close()
                            
                            if (results.success > 0) {
                                ElMessage.success(`å¯¼å…¥æˆåŠŸ: ${results.success} ä¸ªäººè„¸`)
                            }
                            
                            if (results.failed > 0) {
                                ElMessage.warning(`å¯¼å…¥å¤±è´¥: ${results.failed} ä¸ªäººè„¸`)
                            }
                        } catch (error) {
                            loading.close()
                            console.error('å¯¼å…¥å¤±è´¥:', error)
                            ElMessage.error('å¯¼å…¥å¤±è´¥: ' + error.message)
                        }
                    }
                    
                    input.click()
                }
                
                // æ˜¾ç¤ºå­˜å‚¨ä½¿ç”¨æƒ…å†µ
                const showStorageUsage = async () => {
                    try {
                        const usage = await faceDB.value.getStorageUsage()
                        
                        let message = `ğŸ’¾ æµè§ˆå™¨å­˜å‚¨ä½¿ç”¨æƒ…å†µ\n\n`
                        
                        if (usage.total > 0) {
                            message += `æ€»ä½¿ç”¨é‡: ${faceDB.value.formatBytes(usage.total)}\n`
                            message += `æ€»é…é¢: ${faceDB.value.formatBytes(usage.quota)}\n`
                            message += `ä½¿ç”¨ç‡: ${usage.percentage.toFixed(1)}%\n\n`
                        }
                        
                        message += `ğŸ“š IndexedDB: ${faceDB.value.formatBytes(usage.indexedDB.size)}\n`
                        message += `ğŸ—‚ï¸ LocalStorage: ${faceDB.value.formatBytes(usage.localStorage.size)}\n`
                        message += `ğŸ“‹ SessionStorage: ${faceDB.value.formatBytes(usage.sessionStorage.size)}\n\n`
                        
                        message += `ğŸ’¡ æç¤ºï¼š\n`
                        message += `â€¢ IndexedDB å­˜å‚¨äººè„¸æ•°æ®å’Œå›¾ç‰‡\n`
                        message += `â€¢ LocalStorage å­˜å‚¨åº”ç”¨è®¾ç½®\n`
                        message += `â€¢ SessionStorage å­˜å‚¨ä¸´æ—¶æ•°æ®`
                        
                        ElMessageBox.alert(message, 'å­˜å‚¨ä½¿ç”¨æƒ…å†µ', {
                            type: 'info'
                        })
                    } catch (error) {
                        console.error('è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µå¤±è´¥:', error)
                        ElMessage.error('è·å–å­˜å‚¨ä½¿ç”¨æƒ…å†µå¤±è´¥')
                    }
                }
                
                // æ¸…é™¤æ‰€æœ‰ç¼“å­˜
                const clearAllCache = async () => {
                    try {
                        await ElMessageBox.confirm(
                            'âš ï¸ è­¦å‘Šï¼šæ­¤æ“ä½œå°†å½»åº•æ¸…é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®ï¼\n\n' +
                            'å°†ä¼šåˆ é™¤ä»¥ä¸‹å†…å®¹ï¼š\n' +
                            'â€¢ æ‰€æœ‰äººè„¸åº“æ•°æ® (IndexedDB)\n' +
                            'â€¢ åº”ç”¨è®¾ç½®å’Œç¼“å­˜ (LocalStorage)\n' +
                            'â€¢ ä¸´æ—¶æ•°æ® (SessionStorage)\n' +
                            'â€¢ ç½‘é¡µç¼“å­˜ (Cache API)\n' +
                            'â€¢ Service Worker\n' +
                            'â€¢ ç›¸å…³ Cookies\n\n' +
                            'æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼Œç¡®å®šè¦ç»§ç»­å—ï¼Ÿ',
                            'æ¸…é™¤æ‰€æœ‰ç¼“å­˜',
                            {
                                confirmButtonText: 'ç¡®å®šæ¸…é™¤',
                                cancelButtonText: 'å–æ¶ˆ',
                                type: 'warning'
                            }
                        )
                        
                        // äºŒæ¬¡ç¡®è®¤
                        await ElMessageBox.confirm(
                            'ğŸ”¥ æœ€åç¡®è®¤ï¼šæ‚¨çœŸçš„è¦åˆ é™¤æ‰€æœ‰æ•°æ®å—ï¼Ÿ\n\n' +
                            'è¿™åŒ…æ‹¬æ‚¨è¾›è‹¦å»ºç«‹çš„äººè„¸åº“ï¼\n' +
                            'è¯·ç¡®ä¿æ‚¨å·²ç»å¯¼å‡ºäº†é‡è¦æ•°æ®çš„å¤‡ä»½ã€‚',
                            'æœ€åç¡®è®¤',
                            {
                                confirmButtonText: 'æ˜¯çš„ï¼Œå…¨éƒ¨åˆ é™¤',
                                cancelButtonText: 'ç­‰ç­‰ï¼Œæˆ‘å†æƒ³æƒ³',
                                type: 'error'
                            }
                        )
                        
                        const loading = ElLoading.service({
                            lock: true,
                            text: 'æ­£åœ¨æ¸…é™¤æ‰€æœ‰ç¼“å­˜...'
                        })
                        
                        try {
                            // æ‰§è¡Œæ¸…é™¤æ“ä½œ
                            const results = await faceDB.value.clearAllCache()
                            
                            loading.close()
                            
                            // é‡ç½®æœ¬åœ°çŠ¶æ€
                            faceLibrary.value = []
                            matchedFaces.value = []
                            faceMatcher.value = null
                            
                            // ç”Ÿæˆæ¸…é™¤ç»“æœæŠ¥å‘Š
                            let report = 'ğŸ§¹ ç¼“å­˜æ¸…é™¤å®Œæˆï¼\n\n'
                            report += `âœ… IndexedDB: ${results.indexedDB ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            report += `âœ… LocalStorage: ${results.localStorage ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            report += `âœ… SessionStorage: ${results.sessionStorage ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            report += `âœ… Cache API: ${results.cacheAPI ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            report += `âœ… Service Worker: ${results.serviceWorker ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            report += `âœ… Cookies: ${results.cookies ? 'å·²æ¸…é™¤' : 'æ¸…é™¤å¤±è´¥'}\n`
                            
                            if (results.errors.length > 0) {
                                report += `\nâš ï¸ éƒ¨åˆ†æ¸…é™¤å¤±è´¥ï¼š\n${results.errors.slice(0, 3).join('\n')}`
                            }
                            
                            report += '\n\nğŸ’¡ å»ºè®®åˆ·æ–°é¡µé¢ä»¥ç¡®ä¿å®Œå…¨ç”Ÿæ•ˆã€‚'
                            
                            await ElMessageBox.alert(report, 'æ¸…é™¤ç»“æœ', {
                                type: results.errors.length === 0 ? 'success' : 'warning'
                            })
                            
                            // è¯¢é—®æ˜¯å¦åˆ·æ–°é¡µé¢
                            try {
                                await ElMessageBox.confirm(
                                    'æ¸…é™¤å®Œæˆï¼æ˜¯å¦ç«‹å³åˆ·æ–°é¡µé¢ï¼Ÿ',
                                    'åˆ·æ–°é¡µé¢',
                                    { type: 'info' }
                                )
                                window.location.reload()
                            } catch {
                                // ç”¨æˆ·é€‰æ‹©ä¸åˆ·æ–°
                            }
                            
                        } catch (error) {
                            loading.close()
                            console.error('æ¸…é™¤ç¼“å­˜å¤±è´¥:', error)
                            ElMessage.error('æ¸…é™¤ç¼“å­˜å¤±è´¥: ' + error.message)
                        }
                        
                    } catch (error) {
                        // ç”¨æˆ·å–æ¶ˆæˆ–å…¶ä»–é”™è¯¯
                        console.log('æ¸…é™¤æ“ä½œå·²å–æ¶ˆ')
                    }
                }
                
                // åŠ è½½äººè„¸åº“
                const loadFaceLibrary = async () => {
                    try {
                        console.log('ğŸ“š å¼€å§‹ä»æ•°æ®åº“åŠ è½½äººè„¸åº“...')
                        
                        if (!faceDB.value) {
                            console.warn('âš ï¸ æ•°æ®åº“æœªåˆå§‹åŒ–')
                            return
                        }
                        
                        const faces = await faceDB.value.getAllFaces()
                        faceLibrary.value = faces
                        console.log('âœ… äººè„¸åº“åŠ è½½å®Œæˆï¼Œæ•°é‡:', faceLibrary.value.length)
                        
                        // è·å–ç»Ÿè®¡ä¿¡æ¯
                        const stats = await faceDB.value.getStats()
                        console.log('ğŸ“Š äººè„¸åº“ç»Ÿè®¡:', stats)
                        
                        // æ›´æ–°äººè„¸åŒ¹é…å™¨
                        updateFaceMatcher()
                    } catch (error) {
                        console.error('âŒ åŠ è½½äººè„¸åº“å¤±è´¥:', error)
                        console.log('ğŸ“ äººè„¸åº“ä¸ºç©ºï¼Œè¿™æ˜¯é¦–æ¬¡ä½¿ç”¨')
                    }
                }
                
                const cleanup = () => {
                    if (stream.value) {
                        stream.value.getTracks().forEach(track => track.stop())
                        stream.value = null
                    }
                    
                    stopDetection()
                    
                    if (videoRef.value) {
                        videoRef.value.srcObject = null
                    }
                    
                    // å…³é—­æ•°æ®åº“è¿æ¥
                    if (faceDB.value) {
                        faceDB.value.close()
                    }
                }
                
                return {
                    // refs
                    videoRef,
                    canvasRef,
                    captureCanvas,
                    fileInput,
                    
                    // state
                    isRunning,
                    isLoading,
                    modelsLoaded,
                    comparisonMode,
                    faceData,
                    matchedFaces,
                    faceLibrary,
                    
                    // settings
                    recognitionThreshold,
                    detectionInterval,
                    showLandmarks,
                    showExpressions,
                    detectionScore,
                    inputSize,
                    targetFPS,
                    
                    // UI
                    showAddDialog,
                    newFaceName,
                    newFaceNote,
                    isDragging,
                    
                    // stats
                    fps,
                    detectionCount,
                    browserSupport,
                    features,
                    
                    // computed
                    isMatched,
                    getMatchConfidence,
                    averageConfidence,
                    
                    // functions
                    checkBrowserSupport,
                    getExpressionLabel,
                    
                    // methods
                    startCamera,
                    stopCamera,
                    captureAndAdd,
                    confirmAddFace,
                    drawCapturedFaceToDialog,
                    loadFaceLibrary,
                    toggleComparison,
                    removeFace,
                    clearLibrary,
                    exportLibrary,
                    exportImages,
                    importLibrary,
                    handleFileSelect,
                    handleDrop,
                    handleDragOver,
                    handleDragLeave,
                    showStorageUsage,
                    clearAllCache
                }
            }
        }).use(ElementPlus).mount('#app')
    </script>
</body>
</html>