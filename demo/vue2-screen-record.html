<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2å½•å±+éŸ³é¢‘è½¬å­—å¹•ç³»ç»Ÿ</title>
    
    <!-- Vue2 + Element UI -->
    <script src="https://unpkg.com/vue@2/dist/vue.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css">
    <script src="https://unpkg.com/element-ui/lib/index.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .main-content {
            padding: 30px;
        }
        
        .control-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
        }
        
        .section-title {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
        }
        
        .video-container {
            width: 100%;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
            position: relative;
        }
        
        .video-container video {
            width: 100%;
            display: block;
            background: #000;
        }
        
        .video-container .video-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            color: #666;
            font-size: 1.1em;
        }
        
        .video-placeholder {
            height: 250px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 1.1em;
        }
        
        .status-card {
            margin-bottom: 20px;
        }
        
        .transcript-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .transcript-content {
            background: white;
            border-radius: 10px;
            padding: 20px;
            min-height: 300px;
            border: 1px solid #ddd;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            overflow-y: auto;
            max-height: 400px;
        }
        
        .translation-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
        }
        
        .translation-content {
            background: white;
            border-radius: 10px;
            padding: 20px;
            min-height: 300px;
            border: 1px solid #ddd;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
            overflow-y: auto;
            max-height: 400px;
        }
        
        .settings-panel {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
        }
        
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        
        .recording-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #f56c6c;
            border-radius: 50%;
            animation: pulse 1s infinite;
            margin-left: 10px;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .el-progress {
            margin: 15px 0;
        }
        
        .translation-controls {
            margin-bottom: 20px;
        }
        
        .translation-status {
            margin: 15px 0;
        }
        
        @media (max-width: 768px) {
            .control-row {
                grid-template-columns: 1fr;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <div class="header">
                <h1>ğŸ“¹ Vue2å½•å±+éŸ³é¢‘è½¬å­—å¹•ç³»ç»Ÿ</h1>
                <p>åŸºäºVue2 + Element UIçš„ä¸“ä¸šå½•å±ä¸è¯­éŸ³è¯†åˆ«è§£å†³æ–¹æ¡ˆ</p>
            </div>
            
            <div class="main-content">
                <!-- è®¾ç½®é¢æ¿ -->
                <div class="settings-panel">
                    <h2 class="section-title">âš™ï¸ å½•åˆ¶è®¾ç½®</h2>
                    <div class="settings-grid">
                        <el-select v-model="settings.videoQuality" placeholder="é€‰æ‹©è§†é¢‘è´¨é‡">
                            <el-option label="720p (æ¨è)" value="720p"></el-option>
                            <el-option label="1080p (é«˜è´¨é‡)" value="1080p"></el-option>
                            <el-option label="480p (æµç•…)" value="480p"></el-option>
                        </el-select>
                        
                        <el-select v-model="settings.audioSource" placeholder="é€‰æ‹©éŸ³é¢‘æ¥æº">
                            <el-option label="ç³»ç»ŸéŸ³é¢‘" value="system"></el-option>
                            <el-option label="éº¦å…‹é£" value="microphone"></el-option>
                            <el-option label="ç³»ç»Ÿ+éº¦å…‹é£" value="both"></el-option>
                        </el-select>
                        
                        <el-select v-model="settings.language" placeholder="è¯†åˆ«è¯­è¨€">
                            <el-option label="ä¸­æ–‡ (ç®€ä½“)" value="zh-CN"></el-option>
                            <el-option label="English (US)" value="en-US"></el-option>
                            <el-option label="æ—¥æœ¬èª" value="ja-JP"></el-option>
                            <el-option label="í•œêµ­ì–´" value="ko-KR"></el-option>
                        </el-select>
                        
                        <el-switch
                            v-model="settings.continuous"
                            active-text="è¿ç»­è¯†åˆ«">
                        </el-switch>
                    </div>
                </div>
                
                <!-- æ§åˆ¶å’Œé¢„è§ˆé¢æ¿ -->
                <div class="control-row">
                    <!-- æ§åˆ¶é¢æ¿ -->
                    <div class="panel">
                        <h2 class="section-title">ğŸ® æ§åˆ¶é¢æ¿</h2>
                        
                        <el-alert
                            :title="statusMessage"
                            :type="statusType"
                            :closable="false"
                            class="status-card">
                            <span v-if="isRecording" class="recording-indicator"></span>
                        </el-alert>
                        
                        <div style="margin-bottom: 20px;">
                            <el-button
                                type="primary"
                                icon="el-icon-video-camera"
                                @click="startRecording"
                                :disabled="isRecording || !browserSupported">
                                å¼€å§‹å½•åˆ¶
                            </el-button>
                            
                            <el-button
                                type="danger"
                                icon="el-icon-video-pause"
                                @click="stopRecording"
                                :disabled="!isRecording">
                                åœæ­¢å½•åˆ¶
                            </el-button>
                            
                            <el-button
                                type="success"
                                icon="el-icon-download"
                                @click="downloadVideo"
                                :disabled="!recordedVideo">
                                ä¸‹è½½è§†é¢‘
                            </el-button>
                            
                            <el-button
                                icon="el-icon-delete"
                                @click="clearTranscript">
                                æ¸…ç©ºå­—å¹•
                            </el-button>
                        </div>
                        
                        <el-progress
                            v-if="isRecording"
                            :percentage="recordingProgress"
                            :format="formatProgress">
                        </el-progress>
                        
                        <div v-if="recordingTime" style="color: #666; font-size: 14px;">
                            å½•åˆ¶æ—¶é—´: {{ recordingTime }}
                        </div>
                    </div>
                    
                    <!-- è§†é¢‘é¢„è§ˆé¢æ¿ -->
                    <div class="panel">
                        <h2 class="section-title">ğŸ“º è§†é¢‘é¢„è§ˆ</h2>
                        
                        <div class="video-container">
                            <video ref="videoElement" controls style="display: block;"></video>
                            <div v-if="!isRecording && !recordedVideo" class="video-placeholder">
                                ç‚¹å‡»"å¼€å§‹å½•åˆ¶"å¼€å§‹å½•å±
                            </div>
                        </div>
                        
                        <el-card shadow="never">
                            <div slot="header">å½•åˆ¶ä¿¡æ¯</div>
                            <div>{{ recordingInfo }}</div>
                        </el-card>
                    </div>
                </div>
                
                <!-- å­—å¹•é¢æ¿ -->
                <div class="transcript-panel">
                    <h2 class="section-title">ğŸ“ å®æ—¶å­—å¹•</h2>
                    
                    <div class="transcript-content">{{ transcriptText || 'ç­‰å¾…è¯­éŸ³è¾“å…¥...' }}</div>
                    
                    <div style="margin-top: 20px;">
                        <el-button
                            icon="el-icon-document"
                            @click="exportTranscript">
                            å¯¼å‡ºå­—å¹•
                        </el-button>
                        
                        <el-button
                            icon="el-icon-copy-document"
                            @click="copyTranscript">
                            å¤åˆ¶æ–‡æœ¬
                        </el-button>
                        
                        <el-button
                            icon="el-icon-folder"
                            @click="saveTranscript">
                            ä¿å­˜å­—å¹•
                        </el-button>
                    </div>
                </div>
                
                <!-- ç¿»è¯‘é¢æ¿ -->
                <div class="translation-panel">
                    <h2 class="section-title">ğŸŒ ç¿»è¯‘åŠŸèƒ½</h2>
                    
                    <div class="translation-controls">
                        <el-select v-model="currentTranslateApi" placeholder="é€‰æ‹©ç¿»è¯‘API" style="width: 180px; margin-right: 15px;">
                            <el-option label="æœ¬åœ°ç¿»è¯‘ (æ— CORSé—®é¢˜)" value="localTranslate"></el-option>
                            <el-option label="MyMemory (å…è´¹)" value="myMemory"></el-option>
                            <el-option label="Google Translate (å…è´¹)" value="googleTranslate"></el-option>
                            <el-option label="LibreTranslate (å…è´¹)" value="libreTranslate"></el-option>
                        </el-select>
                        <el-select v-model="translationSettings.targetLanguage" placeholder="é€‰æ‹©ç›®æ ‡è¯­è¨€" style="width: 200px; margin-right: 15px;">
                            <el-option label="è‹±è¯­ (English)" value="en"></el-option>
                            <el-option label="æ—¥è¯­ (æ—¥æœ¬èª)" value="ja"></el-option>
                            <el-option label="éŸ©è¯­ (í•œêµ­ì–´)" value="ko"></el-option>
                            <el-option label="æ³•è¯­ (FranÃ§ais)" value="fr"></el-option>
                            <el-option label="å¾·è¯­ (Deutsch)" value="de"></el-option>
                            <el-option label="è¥¿ç­ç‰™è¯­ (EspaÃ±ol)" value="es"></el-option>
                            <el-option label="ä¿„è¯­ (Ğ ÑƒÑÑĞºĞ¸Ğ¹)" value="ru"></el-option>
                            <el-option label="é˜¿æ‹‰ä¼¯è¯­ (Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©)" value="ar"></el-option>
                            <el-option label="è‘¡è„ç‰™è¯­ (PortuguÃªs)" value="pt"></el-option>
                            <el-option label="æ„å¤§åˆ©è¯­ (Italiano)" value="it"></el-option>
                        </el-select>
                        
                        <el-button
                            type="warning"
                            icon="el-icon-refresh"
                            @click="translateTranscript"
                            :loading="isTranslating"
                            :disabled="!transcriptText || transcriptText === 'ç­‰å¾…è¯­éŸ³è¾“å…¥...'">
                            ç¿»è¯‘å­—å¹•
                        </el-button>
                        
                        <el-button
                            icon="el-icon-delete"
                            @click="clearTranslation">
                            æ¸…ç©ºç¿»è¯‘
                        </el-button>
                    </div>
                    
                    <div class="translation-status" v-if="translationStatus.show">
                        <el-alert
                            :title="translationStatus.message"
                            :type="translationStatus.type"
                            :closable="false">
                        </el-alert>
                    </div>
                    
                    <div class="translation-content">{{ translationText || 'ç­‰å¾…ç¿»è¯‘...' }}</div>
                    
                    <div style="margin-top: 20px;">
                        <el-button
                            icon="el-icon-document"
                            @click="exportTranslation"
                            :disabled="!translationText || translationText === 'ç­‰å¾…ç¿»è¯‘...'">
                            å¯¼å‡ºç¿»è¯‘
                        </el-button>
                        
                        <el-button
                            icon="el-icon-copy-document"
                            @click="copyTranslation"
                            :disabled="!translationText || translationText === 'ç­‰å¾…ç¿»è¯‘...'">
                            å¤åˆ¶ç¿»è¯‘
                        </el-button>
                        
                        <el-button
                            icon="el-icon-folder"
                            @click="saveTranslation"
                            :disabled="!translationText || translationText === 'ç­‰å¾…ç¿»è¯‘...'">
                            ä¿å­˜ç¿»è¯‘
                        </el-button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        new Vue({
            el: '#app',
            data() {
                return {
                    // å½•åˆ¶ç›¸å…³
                    mediaRecorder: null,
                    recordedChunks: [],
                    stream: null,
                    recognition: null,
                    isRecording: false,
                    startTime: null,
                    videoUrl: '',
                    recordedVideo: false,
                    
                    // å­—å¹•ç›¸å…³
                    transcriptText: '',
                    
                    // ç¿»è¯‘ç›¸å…³
                    translationText: '',
                    isTranslating: false,
                    translationSettings: {
                        targetLanguage: 'en'
                    },
                    translationStatus: {
                        show: false,
                        message: '',
                        type: 'info'
                    },
                    
                    // çŠ¶æ€ç›¸å…³
                    statusMessage: 'ç³»ç»Ÿå°±ç»ª',
                    statusType: 'success',
                    recordingInfo: 'ç­‰å¾…å¼€å§‹å½•åˆ¶...',
                    recordingTime: '',
                    recordingProgress: 0,
                    browserSupported: true,
                    
                    // è®¾ç½®
                    settings: {
                        videoQuality: '720p',
                        audioSource: 'system',
                        language: 'zh-CN',
                        continuous: true
                    },
                    
                    // å®šæ—¶å™¨
                    timer: null,
                    
                    // ç¿»è¯‘APIé…ç½® - æä¾›å¤šä¸ªé€‰é¡¹
                    translateApis: {
                        localTranslate: {
                            url: 'local',
                            name: 'æœ¬åœ°ç¿»è¯‘ (æ— CORSé—®é¢˜)',
                            cors: true
                        },
                        myMemory: {
                            url: 'https://api.mymemory.translated.net/get',
                            name: 'MyMemory (å…è´¹)',
                            cors: true
                        },
                        googleTranslate: {
                            url: 'https://translate.googleapis.com/translate_a/single',
                            name: 'Google Translate (å…è´¹)',
                            cors: true
                        },
                        libreTranslate: {
                            url: 'https://libretranslate.de/translate',
                            name: 'LibreTranslate (å…è´¹)',
                            cors: false
                        }
                    },
                    // æ£€æµ‹æ˜¯å¦ä¸ºæœ¬åœ°æ–‡ä»¶è¿è¡Œ
                    isLocalFile: window.location.protocol === 'file:',
                    currentTranslateApi: window.location.protocol === 'file:' ? 'localTranslate' : 'myMemory' // æœ¬åœ°æ–‡ä»¶é»˜è®¤ä½¿ç”¨æœ¬åœ°ç¿»è¯‘
                }
            },
            
            mounted() {
                this.checkBrowserSupport();
                this.loadSavedTranscript();
                this.loadSavedTranslation();
            },
            
            beforeDestroy() {
                if (this.timer) {
                    clearInterval(this.timer);
                }
                if (this.isRecording) {
                    this.stopRecording();
                }
            },
            
            methods: {
                // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
                checkBrowserSupport() {
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                        this.browserSupported = false;
                        this.statusMessage = 'æµè§ˆå™¨ä¸æ”¯æŒå±å¹•å½•åˆ¶åŠŸèƒ½';
                        this.statusType = 'error';
                        this.$message.error('æµè§ˆå™¨ä¸æ”¯æŒå±å¹•å½•åˆ¶åŠŸèƒ½');
                    }
                },
                
                // åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«
                initSpeechRecognition() {
                    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                        this.recognition = new SpeechRecognition();
                        
                        this.recognition.lang = this.settings.language;
                        this.recognition.continuous = this.settings.continuous;
                        this.recognition.interimResults = true;
                        this.recognition.maxAlternatives = 1;

                        this.recognition.onstart = () => {
                            console.log('ğŸ¤ è¯­éŸ³è¯†åˆ«å·²å¼€å§‹');
                        };

                        this.recognition.onresult = (event) => {
                            let finalTranscript = '';

                            for (let i = event.resultIndex; i < event.results.length; i++) {
                                const transcript = event.results[i][0].transcript;
                                if (event.results[i].isFinal) {
                                    finalTranscript += transcript;
                                }
                            }

                            if (finalTranscript) {
                                const timestamp = this.getTimestamp();
                                const line = `[${timestamp}] ${finalTranscript}\n`;
                                this.transcriptText += line;
                            }
                        };

                        this.recognition.onerror = (event) => {
                            console.error('è¯­éŸ³è¯†åˆ«é”™è¯¯:', event.error);
                            this.$message.error('è¯­éŸ³è¯†åˆ«é”™è¯¯: ' + event.error);
                        };

                        this.recognition.onend = () => {
                            if (this.isRecording) {
                                setTimeout(() => {
                                    if (this.isRecording) {
                                        this.recognition.start();
                                    }
                                }, 100);
                            }
                        };

                        return true;
                    } else {
                        this.$message.error('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«åŠŸèƒ½');
                        return false;
                    }
                },
                
                // å¼€å§‹å½•åˆ¶
                async startRecording() {
                    try {
                        // é‡ç½®ä¹‹å‰çš„å½•åˆ¶çŠ¶æ€
                        if (this.stream) {
                            this.stream.getTracks().forEach(track => track.stop());
                        }
                        
                        const displayStream = await navigator.mediaDevices.getDisplayMedia({
                            video: this.getVideoConstraints(),
                            audio: true
                        });

                        let audioStream = null;
                        if (this.settings.audioSource === 'microphone' || this.settings.audioSource === 'both') {
                            try {
                                audioStream = await navigator.mediaDevices.getUserMedia({
                                    audio: true
                                });
                            } catch (err) {
                                console.warn('æ— æ³•è·å–éº¦å…‹é£æƒé™:', err);
                                this.$message.warning('æ— æ³•è·å–éº¦å…‹é£æƒé™');
                            }
                        }

                        this.stream = displayStream;

                        // è®¾ç½®å®æ—¶é¢„è§ˆ - ä½¿ç”¨srcObjectè€Œä¸æ˜¯createObjectURL
                        this.videoUrl = '';
                        this.$nextTick(() => {
                            const videoElement = this.$refs.videoElement;
                            if (videoElement) {
                                try {
                                    videoElement.srcObject = displayStream;
                                    videoElement.onloadedmetadata = () => {
                                        videoElement.play().catch(e => {
                                            console.log('è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢:', e);
                                            this.$message.info('è¯·æ‰‹åŠ¨ç‚¹å‡»æ’­æ”¾æŒ‰é’®å¼€å§‹é¢„è§ˆ');
                                        });
                                    };
                                    videoElement.onerror = (e) => {
                                        console.error('è§†é¢‘é¢„è§ˆé”™è¯¯:', e);
                                        this.$message.error('è§†é¢‘é¢„è§ˆåŠ è½½å¤±è´¥');
                                    };
                                } catch (err) {
                                    console.error('è®¾ç½®è§†é¢‘é¢„è§ˆå¤±è´¥:', err);
                                    this.$message.error('è§†é¢‘é¢„è§ˆè®¾ç½®å¤±è´¥');
                                }
                            }
                        });

                        this.recordedChunks = [];
                        
                        // æ£€æŸ¥æ”¯æŒçš„MIMEç±»å‹
                        let mimeType = 'video/webm;codecs=vp9';
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'video/webm;codecs=vp8';
                        }
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'video/webm';
                        }
                        
                        this.mediaRecorder = new MediaRecorder(this.stream, {
                            mimeType: mimeType
                        });

                        this.mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                this.recordedChunks.push(event.data);
                            }
                        };

                        this.mediaRecorder.onstop = () => {
                            const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                            this.videoUrl = URL.createObjectURL(blob);
                            this.recordedVideo = true;
                            
                            // æ¸…é™¤å®æ—¶é¢„è§ˆçš„srcObject
                            this.$nextTick(() => {
                                const videoElement = this.$refs.videoElement;
                                if (videoElement) {
                                    videoElement.srcObject = null;
                                }
                            });
                            
                            this.statusMessage = 'å½•åˆ¶å®Œæˆï¼Œå¯ä»¥ä¸‹è½½è§†é¢‘';
                            this.statusType = 'success';
                            this.$message.success('å½•åˆ¶å®Œæˆ');
                        };

                        this.mediaRecorder.start(1000);
                        this.isRecording = true;
                        this.startTime = Date.now();

                        if (this.initSpeechRecognition()) {
                            this.recognition.start();
                        }

                        this.statusMessage = 'æ­£åœ¨å½•åˆ¶ä¸­...';
                        this.statusType = 'warning';
                        this.recordingInfo = 'å½•åˆ¶è¿›è¡Œä¸­...';
                        this.startTimer();

                        this.stream.getVideoTracks()[0].onended = () => {
                            this.stopRecording();
                        };

                        this.$message.success('å½•åˆ¶å¼€å§‹');

                    } catch (err) {
                        console.error('å¼€å§‹å½•åˆ¶å¤±è´¥:', err);
                        this.$message.error('å¼€å§‹å½•åˆ¶å¤±è´¥: ' + err.message);
                        this.statusMessage = 'å½•åˆ¶å¤±è´¥: ' + err.message;
                        this.statusType = 'error';
                    }
                },
                
                // åœæ­¢å½•åˆ¶
                stopRecording() {
                    if (this.mediaRecorder && this.isRecording) {
                        this.mediaRecorder.stop();
                        this.isRecording = false;

                        if (this.recognition) {
                            this.recognition.stop();
                        }

                        if (this.stream) {
                            this.stream.getTracks().forEach(track => track.stop());
                        }

                        if (this.timer) {
                            clearInterval(this.timer);
                        }

                        this.statusMessage = 'å½•åˆ¶å·²åœæ­¢';
                        this.statusType = 'info';
                        this.recordingInfo = 'å½•åˆ¶å·²å®Œæˆ';
                        this.recordingProgress = 0;
                        
                        this.$message.info('å½•åˆ¶å·²åœæ­¢');
                    }
                },
                
                // ä¸‹è½½è§†é¢‘
                downloadVideo() {
                    if (this.recordedChunks.length > 0) {
                        const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `vue2-screen-recording-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.webm`;
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        this.$message.success('è§†é¢‘ä¸‹è½½å¼€å§‹');
                    }
                },
                
                // è·å–è§†é¢‘çº¦æŸ
                getVideoConstraints() {
                    const constraints = {
                        '1080p': { width: 1920, height: 1080, frameRate: 30 },
                        '720p': { width: 1280, height: 720, frameRate: 30 },
                        '480p': { width: 854, height: 480, frameRate: 24 }
                    };
                    
                    return constraints[this.settings.videoQuality];
                },
                
                // è·å–æ—¶é—´æˆ³
                getTimestamp() {
                    if (!this.startTime) return '00:00:00';
                    
                    const elapsed = Date.now() - this.startTime;
                    const hours = Math.floor(elapsed / 3600000);
                    const minutes = Math.floor((elapsed % 3600000) / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    
                    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                },
                
                // å¼€å§‹è®¡æ—¶å™¨
                startTimer() {
                    this.timer = setInterval(() => {
                        if (!this.isRecording) {
                            clearInterval(this.timer);
                            return;
                        }
                        
                        const elapsed = Date.now() - this.startTime;
                        const minutes = Math.floor(elapsed / 60000);
                        const seconds = Math.floor((elapsed % 60000) / 1000);
                        
                        this.recordingTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                        
                        const maxTime = 30 * 60 * 1000;
                        this.recordingProgress = Math.min((elapsed / maxTime) * 100, 100);
                    }, 1000);
                },
                
                // æ ¼å¼åŒ–è¿›åº¦
                formatProgress(percentage) {
                    return percentage === 100 ? 'å½•åˆ¶å³å°†ç»“æŸ' : `${percentage.toFixed(1)}%`;
                },
                
                // æ¸…ç©ºå­—å¹•
                clearTranscript() {
                    this.transcriptText = '';
                    this.$message.success('å­—å¹•å·²æ¸…ç©º');
                },
                
                // å¯¼å‡ºå­—å¹•
                exportTranscript() {
                    if (!this.transcriptText) {
                        this.$message.warning('æ²¡æœ‰å­—å¹•å†…å®¹å¯å¯¼å‡º');
                        return;
                    }
                    
                    const blob = new Blob([this.transcriptText], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `vue2-transcript-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    this.$message.success('å­—å¹•å¯¼å‡ºæˆåŠŸ');
                },
                
                // å¤åˆ¶å­—å¹•
                copyTranscript() {
                    if (!this.transcriptText) {
                        this.$message.warning('æ²¡æœ‰å­—å¹•å†…å®¹å¯å¤åˆ¶');
                        return;
                    }
                    
                    navigator.clipboard.writeText(this.transcriptText).then(() => {
                        this.$message.success('å­—å¹•å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    }).catch(err => {
                        console.error('å¤åˆ¶å¤±è´¥:', err);
                        this.$message.error('å¤åˆ¶å¤±è´¥');
                    });
                },
                
                // ä¿å­˜å­—å¹•
                saveTranscript() {
                    if (!this.transcriptText) {
                        this.$message.warning('æ²¡æœ‰å­—å¹•å†…å®¹å¯ä¿å­˜');
                        return;
                    }
                    
                    localStorage.setItem('vue2SavedTranscript', this.transcriptText);
                    localStorage.setItem('vue2SavedTranscriptTime', new Date().toISOString());
                    this.$message.success('å­—å¹•å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
                },
                
                // åŠ è½½ä¿å­˜çš„å­—å¹•
                loadSavedTranscript() {
                    const savedTranscript = localStorage.getItem('vue2SavedTranscript');
                    if (savedTranscript) {
                        const savedTime = localStorage.getItem('vue2SavedTranscriptTime');
                        this.$confirm(`å‘ç°ä¿å­˜çš„å­—å¹•å†…å®¹ (${new Date(savedTime).toLocaleString()})ï¼Œæ˜¯å¦æ¢å¤ï¼Ÿ`, 'æç¤º', {
                            confirmButtonText: 'æ¢å¤',
                            cancelButtonText: 'å–æ¶ˆ',
                            type: 'info'
                        }).then(() => {
                            this.transcriptText = savedTranscript;
                            this.$message.success('å­—å¹•å†…å®¹å·²æ¢å¤');
                        }).catch(() => {
                            // ç”¨æˆ·å–æ¶ˆ
                        });
                    }
                },
                
                // ç¿»è¯‘åŠŸèƒ½
                async translateTranscript() {
                    if (!this.transcriptText || this.transcriptText === 'ç­‰å¾…è¯­éŸ³è¾“å…¥...') {
                        this.$message.warning('æ²¡æœ‰å­—å¹•å†…å®¹å¯ç¿»è¯‘');
                        return;
                    }

                    if (this.isTranslating) {
                        this.$message.warning('æ­£åœ¨ç¿»è¯‘ä¸­ï¼Œè¯·ç¨å€™...');
                        return;
                    }

                    this.isTranslating = true;
                    this.translationStatus.show = true;
                    this.translationStatus.message = 'æ­£åœ¨ç¿»è¯‘...';
                    this.translationStatus.type = 'info';

                    try {
                        // å°†å­—å¹•æ–‡æœ¬æŒ‰è¡Œåˆ†å‰²å¹¶ç¿»è¯‘
                        const lines = this.transcriptText.split('\n').filter(line => line.trim());
                        let translatedLines = [];

                        for (let i = 0; i < lines.length; i++) {
                            const line = lines[i];
                            if (line.trim()) {
                                // æå–æ—¶é—´æˆ³å’Œæ–‡æœ¬å†…å®¹
                                const match = line.match(/^(\[.*?\]) (.*)$/);
                                if (match) {
                                    const timestamp = match[1];
                                    const text = match[2];
                                    
                                    try {
                                        const translatedText = await this.translateText(text, 'zh', this.translationSettings.targetLanguage);
                                        translatedLines.push(`${timestamp} ${translatedText}`);
                                        this.translationStatus.message = `æ­£åœ¨ç¿»è¯‘ç¬¬ ${i + 1}/${lines.length} è¡Œ...`;
                                    } catch (err) {
                                        console.error('ç¿»è¯‘å¤±è´¥:', err);
                                        translatedLines.push(`${timestamp} [ç¿»è¯‘å¤±è´¥] ${text}`);
                                    }
                                } else {
                                    translatedLines.push(line);
                                }
                            }
                        }

                        this.translationText = translatedLines.join('\n');
                        this.translationStatus.message = 'ç¿»è¯‘å®Œæˆ';
                        this.translationStatus.type = 'success';
                        
                        setTimeout(() => {
                            this.translationStatus.show = false;
                        }, 3000);

                    } catch (err) {
                        console.error('ç¿»è¯‘è¿‡ç¨‹å‡ºé”™:', err);
                        let errorMessage = 'ç¿»è¯‘å¤±è´¥: ' + err.message;
                        
                        // å¦‚æœæ˜¯CORSé”™è¯¯ï¼Œæä¾›è§£å†³æ–¹æ¡ˆ
                        if (err.message.includes('CORS') || err.message.includes('preflight')) {
                            errorMessage = 'ç¿»è¯‘å¤±è´¥: CORSè·¨åŸŸé—®é¢˜ã€‚è¯·å°è¯•åˆ‡æ¢åˆ°å…¶ä»–ç¿»è¯‘APIï¼Œæˆ–ä½¿ç”¨æœ¬åœ°æœåŠ¡å™¨è¿è¡Œæ­¤æ–‡ä»¶ã€‚';
                        }
                        
                        this.translationStatus.message = errorMessage;
                        this.translationStatus.type = 'error';
                        setTimeout(() => {
                            this.translationStatus.show = false;
                        }, 8000);
                    } finally {
                        this.isTranslating = false;
                    }
                },

                // ç¿»è¯‘å•è¡Œæ–‡æœ¬
                async translateText(text, sourceLang, targetLang) {
                    const api = this.translateApis[this.currentTranslateApi];
                    
                    try {
                        let response;
                        
                        switch (this.currentTranslateApi) {
                            case 'localTranslate':
                                // æœ¬åœ°ç¿»è¯‘é€»è¾‘
                                console.log('ä½¿ç”¨æœ¬åœ°ç¿»è¯‘API');
                                // åœ¨æœ¬åœ°æ–‡ä»¶è¿è¡Œæ—¶ï¼Œç›´æ¥è¿”å›åŸå§‹æ–‡æœ¬
                                if (this.isLocalFile) {
                                    return text;
                                }
                                // åœ¨æœåŠ¡å™¨ä¸Šè¿è¡Œæ—¶ï¼Œæ¨¡æ‹ŸAPIè°ƒç”¨
                                await new Promise(resolve => setTimeout(resolve, 100)); // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
                                return `[æœ¬åœ°ç¿»è¯‘] ${text}`; // ç¤ºä¾‹æœ¬åœ°ç¿»è¯‘
                                
                            case 'myMemory':
                                // MyMemory API - GETè¯·æ±‚ï¼ŒCORSå‹å¥½
                                const myMemoryUrl = `${api.url}?q=${encodeURIComponent(text)}&langpair=${sourceLang}|${targetLang}`;
                                response = await fetch(myMemoryUrl);
                                if (!response.ok) {
                                    throw new Error(`MyMemory APIè¯·æ±‚å¤±è´¥: ${response.status}`);
                                }
                                const myMemoryData = await response.json();
                                return myMemoryData.responseData.translatedText;
                                
                            case 'googleTranslate':
                                // Google Translate API - GETè¯·æ±‚ï¼ŒCORSå‹å¥½
                                const googleUrl = `${api.url}?client=gtx&sl=${sourceLang}&tl=${targetLang}&dt=t&q=${encodeURIComponent(text)}`;
                                response = await fetch(googleUrl);
                                if (!response.ok) {
                                    throw new Error(`Google Translate APIè¯·æ±‚å¤±è´¥: ${response.status}`);
                                }
                                const googleData = await response.json();
                                return googleData[0][0][0];
                                
                            case 'libreTranslate':
                                // LibreTranslate API - POSTè¯·æ±‚ï¼Œå¯èƒ½æœ‰CORSé—®é¢˜
                                response = await fetch(api.url, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                    },
                                    body: JSON.stringify({
                                        q: text,
                                        source: sourceLang,
                                        target: targetLang,
                                        format: 'text'
                                    })
                                });
                                if (!response.ok) {
                                    throw new Error(`LibreTranslate APIè¯·æ±‚å¤±è´¥: ${response.status}`);
                                }
                                const libreData = await response.json();
                                return libreData.translatedText;
                                
                            default:
                                throw new Error('æœªçŸ¥çš„ç¿»è¯‘API');
                        }
                    } catch (error) {
                        console.error('ç¿»è¯‘è¯·æ±‚å¤±è´¥:', error);
                        // å¦‚æœå½“å‰APIå¤±è´¥ï¼Œå°è¯•åˆ‡æ¢åˆ°å…¶ä»–API
                        if (this.currentTranslateApi !== 'localTranslate') { // é¿å…æ— é™å¾ªç¯
                            console.log('å°è¯•åˆ‡æ¢åˆ°æœ¬åœ°ç¿»è¯‘API...');
                            this.currentTranslateApi = 'localTranslate';
                            return await this.translateText(text, sourceLang, targetLang);
                        }
                        throw error;
                    }
                },

                // æ¸…ç©ºç¿»è¯‘
                clearTranslation() {
                    this.translationText = '';
                    this.translationStatus.show = false;
                    this.$message.success('ç¿»è¯‘å·²æ¸…ç©º');
                },

                // å¯¼å‡ºç¿»è¯‘
                exportTranslation() {
                    if (!this.translationText || this.translationText === 'ç­‰å¾…ç¿»è¯‘...') {
                        this.$message.warning('æ²¡æœ‰ç¿»è¯‘å†…å®¹å¯å¯¼å‡º');
                        return;
                    }
                    
                    const blob = new Blob([this.translationText], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `vue2-translation-${this.translationSettings.targetLanguage}-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    this.$message.success('ç¿»è¯‘å¯¼å‡ºæˆåŠŸ');
                },

                // å¤åˆ¶ç¿»è¯‘
                copyTranslation() {
                    if (!this.translationText || this.translationText === 'ç­‰å¾…ç¿»è¯‘...') {
                        this.$message.warning('æ²¡æœ‰ç¿»è¯‘å†…å®¹å¯å¤åˆ¶');
                        return;
                    }
                    
                    navigator.clipboard.writeText(this.translationText).then(() => {
                        this.$message.success('ç¿»è¯‘å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                    }).catch(err => {
                        console.error('å¤åˆ¶å¤±è´¥:', err);
                        this.$message.error('å¤åˆ¶å¤±è´¥');
                    });
                },

                // ä¿å­˜ç¿»è¯‘
                saveTranslation() {
                    if (!this.translationText || this.translationText === 'ç­‰å¾…ç¿»è¯‘...') {
                        this.$message.warning('æ²¡æœ‰ç¿»è¯‘å†…å®¹å¯ä¿å­˜');
                        return;
                    }
                    
                    localStorage.setItem('vue2SavedTranslation', this.translationText);
                    localStorage.setItem('vue2SavedTranslationTime', new Date().toISOString());
                    localStorage.setItem('vue2SavedTranslationLang', this.translationSettings.targetLanguage);
                    this.$message.success('ç¿»è¯‘å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');
                },

                // åŠ è½½ä¿å­˜çš„ç¿»è¯‘
                loadSavedTranslation() {
                    const savedTranslation = localStorage.getItem('vue2SavedTranslation');
                    if (savedTranslation) {
                        const savedTime = localStorage.getItem('vue2SavedTranslationTime');
                        const savedLang = localStorage.getItem('vue2SavedTranslationLang');
                        
                        this.$confirm(`å‘ç°ä¿å­˜çš„ç¿»è¯‘å†…å®¹ (${new Date(savedTime).toLocaleString()}, è¯­è¨€: ${savedLang})ï¼Œæ˜¯å¦æ¢å¤ï¼Ÿ`, 'æç¤º', {
                            confirmButtonText: 'æ¢å¤',
                            cancelButtonText: 'å–æ¶ˆ',
                            type: 'info'
                        }).then(() => {
                            this.translationText = savedTranslation;
                            this.translationSettings.targetLanguage = savedLang || 'en';
                            this.$message.success('ç¿»è¯‘å†…å®¹å·²æ¢å¤');
                        }).catch(() => {
                            // ç”¨æˆ·å–æ¶ˆ
                        });
                    }
                }
            },
            
            watch: {
                'settings.language'(newVal) {
                    if (this.recognition) {
                        this.recognition.lang = newVal;
                    }
                },
                
                'settings.continuous'(newVal) {
                    if (this.recognition) {
                        this.recognition.continuous = newVal;
                    }
                },
                
                'currentTranslateApi'(newVal) {
                    console.log('åˆ‡æ¢åˆ°ç¿»è¯‘API:', this.translateApis[newVal].name);
                    
                    // å¦‚æœæ˜¯æœ¬åœ°æ–‡ä»¶ä¸”é€‰æ‹©äº†éœ€è¦ç½‘ç»œçš„APIï¼Œç»™å‡ºæç¤º
                    if (this.isLocalFile && newVal !== 'localTranslate') {
                        this.$message.warning('æ³¨æ„ï¼šåœ¨æœ¬åœ°æ–‡ä»¶è¿è¡Œæ—¶ï¼Œç½‘ç»œç¿»è¯‘APIå¯èƒ½é‡åˆ°CORSé—®é¢˜ã€‚å»ºè®®ä½¿ç”¨"æœ¬åœ°ç¿»è¯‘"é€‰é¡¹ã€‚');
                    }
                }
            }
        });
    </script>
</body>
</html>
